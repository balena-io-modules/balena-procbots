{"version":3,"sources":["versionbot.ts"],"names":[],"mappings":"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","file":"versionbot.js","sourcesContent":["/*\nCopyright 2016 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// VersionBot listens for merges of a PR to the `master` branch and then\n// updates any packages for it.\nimport * as ProcBot from './procbot';\nimport * as GithubBot from './githubbot';\nimport * as Promise from 'bluebird';\nimport * as _ from 'lodash';\nimport * as path from 'path';\nimport * as GithubApi from 'github';\n\nconst temp: any = Promise.promisifyAll(require('temp').track());\nconst mkdirp: any = Promise.promisify(require('mkdirp'));\nconst rmdir: any = Promise.promisify(require('rmdir'));\nconst exec: any = Promise.promisify(require('child_process').exec);\nconst fs: any = Promise.promisifyAll(require('fs'));\n\n// Specific to VersionBot\ninterface FileMapping {\n    file: string,\n    encoding: string\n}\n\ninterface EncodedFile extends FileMapping {\n    treeEntry: GithubBot.TreeEntry,\n    blobSha: string\n};\n\n// The VersionBot is built ontop of GithubBot, which does all the heavy lifting and scheduling.\n// It is designed to check for valid `versionist` commit semantics and alter (or merge) a PR\n// accordingly.\nexport class VersionBot extends GithubBot.GithubBot {\n\n    // Name ourself and register the events and labels we're interested in.\n    constructor(integration: number) {\n        super(integration);\n\n        // This is the VersionBot.\n        this._botname = 'VersionBot';\n\n        // We have two different WorkerMethods here:\n        // 1) Status checks on PR open and commits\n        // 2) PR review and label checks for merge\n        _.forEach([\n            {\n                name: 'CheckVersionistCommitStatus',\n                events: [ 'pull_request' ],\n                suppressionLabels: [ 'flow/no-version-checks' ],\n                workerMethod: this.checkVersioning\n            },\n            {\n                name: 'CheckForReadyMergeState',\n                events: [ 'pull_request', 'pull_request_review' ],\n                triggerLabels: [ 'flow/ready-to-merge' ],\n                suppressionLabels: [ 'flow/no-version-checks' ],\n                workerMethod: this.mergePR\n            }\n        ], (reg: GithubBot.GithubActionRegister) => {\n            this.registerAction(reg);\n        });\n\n        // Authenticate the Github API.\n        this.authenticate();\n    }\n\n    // Checks the newly opened PR and its commits.\n    //  1. Triggered by an 'opened' or 'synchronize' event.\n    //  2. If any PR commit has a 'Change-Type: <type>' commit, we create a status approving the PR.\n    //  3. If no PR commit has a 'Change-Type: <type>' commit, we create a status failing the PR.\n    protected checkVersioning = (action: GithubBot.GithubAction, data: GithubBot.PullRequestEvent) => {\n        const githubApi = this.githubApi;\n        const pr = data.pull_request;\n        const head = data.pull_request.head;\n        const owner = head.repo.owner.login;\n        const name = head.repo.name;\n\n        this.log(ProcBot.LogLevel.DEBUG, `${action.name}: entered`);\n\n        // Only for opened or synced actions.\n        if ((data.action !== 'opened') && (data.action !== 'synchronize')) {\n            return Promise.resolve();\n        }\n\n        return this.gitCall(githubApi.pullRequests.getCommits, {\n            owner: owner,\n            repo: name,\n            number: pr.number\n        }).then((commits: GithubBot.Commit[]) => {\n            let changetypeFound: boolean = false;\n            // Go through all the commits. We're looking for, at a minimum, a 'change-type:' tag.\n            for (let index = 0; index < commits.length; index += 1) {\n                const commit: GithubBot.Commit = commits[index];\n                const commitMessage: string = commit.commit.message;\n                const invalidCommit = !commitMessage.match(/^change-type:\\s*(patch|minor|major)\\s*$/mi);\n\n                if (!invalidCommit) {\n                    changetypeFound = true;\n                    break;\n                }\n            }\n\n            // If we found a change-type message, then mark this commit as ok.\n            if (changetypeFound) {\n                return this.gitCall(githubApi.repos.createStatus, {\n                    owner: owner,\n                    repo: name,\n                    sha: head.sha,\n                    state: 'success',\n                    description: 'Found a valid Versionist `Change-Type` tag',\n                    context: 'Versionist'\n                }).return(true);\n            }\n\n            // Else we mark it as having failed.\n            this.log(ProcBot.LogLevel.DEBUG, `${action.name}: No valid 'Change-Type' tag found, failing last commit`);\n            return this.gitCall(githubApi.repos.createStatus, {\n                owner: owner,\n                repo: name,\n                sha: head.sha,\n                state: 'failure',\n                description: 'None of the commits in the PR have a `Change-Type` tag',\n                context: 'Versionist'\n            }).return(false);\n        }).then(() => {\n            // If the author was Versionbot and the file marked was CHANGELOG, then\n            // we are now going to go ahead and perform a merge.\n            //\n            // Get the list of commits for the PR, then get the very last commit SHA.\n            return this.gitCall(githubApi.repos.getCommit, {\n                owner,\n                repo: name,\n                sha: head.sha\n            }).then((headCommit: GithubBot.Commit) => {\n                // We will go ahead and perform a merge if we see Versionbot has committed\n                // something with 'CHANGELOG.md' in it.\n                const commit = headCommit.commit;\n                const files = headCommit.files;\n\n                if ((commit.committer.name === process.env.VERSIONBOT_NAME) &&\n                    _.find(files, (file: GithubBot.CommitFile) => {\n                        return file.filename === 'CHANGELOG.md';\n                    })) {\n                        // We go ahead and merge.\n                        const commitVersion = commit.message;\n                        return this.gitCall(githubApi.pullRequests.merge, {\n                            owner,\n                            repo: name,\n                            number: pr.number,\n                            commit_title: `Auto-merge for PR ${pr.number} via Versionbot`\n                        }, 3).then((mergedData:GithubBot. Merge) => {\n                            // We get an SHA back when the merge occurs, and we use this for a tag.\n                            // Note date gets filed in automatically by API.\n                            return this.gitCall(githubApi.gitdata.createTag, {\n                                owner,\n                                repo: name,\n                                tag: commitVersion,\n                                message: commitVersion,\n                                object: mergedData.sha,\n                                type: 'commit',\n                                tagger: {\n                                    name: process.env.VERSIONBOT_NAME,\n                                    email: process.env.VERSIONBOT_EMAIL\n                                }\n                            });\n                        }).then((newTag: GithubBot.Tag) => {\n                            // We now have a SHA back that contains the tag object.\n                            // Create a new reference based on it.\n                            return this.gitCall(githubApi.gitdata.createReference, {\n                                owner,\n                                repo: name,\n                                ref: `refs/tags/${commitVersion}`,\n                                sha: newTag.sha\n                            });\n                        });\n                    }\n            });\n        });\n    }\n\n    // Merges a PR, if appropriate:\n    //  1. Triggered by a 'labeled' event ('flow/ready-to-merge') or a 'pull_request_review_comment'\n    //  2. Checks all review comments to ensure that at least one approves the PR (and that no comment\n    //     that may come after it includes a 'CHANGES_REQUESTED' state).\n    //  3. Commit new version upped files to the branch, which will cause a 'synchronized' event,\n    //     which will finalise the merge.\n    //\n    // It should be noted that this will, of course, result in a 'closed' event on a PR, which\n    // in turn will feed into the 'generateVersion' method below.\n    protected mergePR = (action: GithubBot.GithubAction, data:GithubBot.PullRequestEvent | GithubBot.PullRequestReviewEvent) => {\n        // States for review comments are:\n        //  * COMMENT\n        //  * CHANGES_REQUESTED\n        //  * APPROVED\n        //\n        // We *only* go through with a merge should:\n        //  * The 'flow/ready-to-merge' label appear on the PR issue\n        //  * There is an 'APPROVED' review comment *and* no comment after is of state 'CHANGES_REQUESTED'\n        // The latter overrides the label should it exist, as it will be assumed it is in error.\n        const githubApi = this.githubApi;\n        const pr = data.pull_request;\n        const head = data.pull_request.head;\n        const owner = head.repo.owner.login;\n        const repo = head.repo.name;\n        const repoFullName = `${owner}/${repo}`;\n        const cwd = process.cwd();\n        let newVersion: string;\n        let fullPath: string;\n        let branchName: string;\n        let newTreeSha: string;\n\n        this.log(ProcBot.LogLevel.DEBUG, `${action.name}: entered`);\n\n        // Check the action on the event to see what we're dealing with.\n        switch (data.action) {\n            // Submission is a PR review\n            case 'submitted':\n            case 'labeled':\n            case 'unlabeled':\n                break;\n\n            default:\n                // We have no idea what sparked this, but we're not doing anything!\n                this.log(ProcBot.LogLevel.INFO, `${action.name}:${data.action} isn't a useful action`);\n                return Promise.resolve();\n        }\n\n        // Get the reviews for the PR.\n        return this.gitCall(githubApi.pullRequests.getReviews, {\n            owner: owner,\n            repo: repo,\n            number: pr.number\n        }).then((reviews: GithubBot.Review[]) => {\n            // Cycle through reviews, ensure that any approved review occurred after any requiring changes.\n            let approved = false;\n            // Ooo, this is a good one. We can't do this:\n            //    reviews.forEach((review: GithubBot.Review) => {\n            //      if (review.state === 'APPROVED') {\n            //            approved = true;\n            //      } else if (review.state === 'CHANGES_REQUESTED') {\n            //            approved = false;\n            //      }\n            //     });\n            //\n            // Because of the CFA going on here: https://github.com/Microsoft/TypeScript/issues/11498\n            // This errors because it's optimistic that [].forEach() execution can't affect the\n            // 'approved' variable, therefore it implicitly believes it can only ever be 'false'\n            // and barfs on the 'if (approved === true)' line claiming 'true' cannot be 'false'.\n            // Not great. Still, easy to use a straight for() loop.\n            approved = false;\n            for (let index = 0; index < reviews.length; index += 1) {\n                const review = reviews[index];\n                if (review.state === 'APPROVED') {\n                    approved = true;\n                } else if (review.state === 'CHANGES_REQUESTED') {\n                    approved = false;\n                }\n            }\n\n            if (approved === false) {\n                this.log(ProcBot.LogLevel.INFO, `Unable to merge, no approval comment`);\n                return Promise.resolve();\n            }\n\n            // Actually generate a new version of a component:\n            // 1. Clone the repo\n            // 2. Checkout the appropriate branch given the PR number\n            // 3. Run `versionist`\n            // 4. Read the `CHANGELOG.md` (and any `package.json`, if present)\n            // 5. Base64 encode them\n            // 6. Call Github to update them, in serial, CHANGELOG last (important for merging expectations)\n            // 7. Finish\n            this.log(ProcBot.LogLevel.INFO, 'PR is ready to merge, attempting to carry out a version up');\n\n            // Get the branch for this PR.\n            return this.gitCall(githubApi.pullRequests.get, {\n                owner: owner,\n                repo: repo,\n                number: pr.number\n            }).then((prInfo: GithubBot.PullRequest) => {\n                // Get the relevant branch.\n                branchName = prInfo.head.ref;\n\n                // Create new work dir.\n                return temp.mkdirAsync(`${repo}-${pr.number}_`).then((tempDir: string) => {\n                    fullPath = `${tempDir}${path.sep}`;\n\n                    // Clone the repository inside the directory using the commit name and the run versionist.\n                    // We only care about output from the git status.\n                    // IMPORTANT NOTE: Currently, Versionist will fail if it doesn't find a\n                    //     `package.json` file. This needs rectifying in Versionist, as this code doesn't pick it up.\n                    const promiseResults: string[] = [];\n                    return Promise.mapSeries([\n                        `git clone https://${process.env.WEBHOOK_SECRET}:x-oauth-basic@github.com/${repoFullName} ${fullPath}`,\n                        `git checkout ${branchName}`,\n                        'versionist',\n                        'git status -s'\n                    ], (command) => {\n                        return exec(command, { cwd: fullPath });\n                    }).get(3)\n                });\n            }).then((status: string) => {\n                const moddedFiles: string[] = [];\n                let changeLines = status.split('\\n');\n                let changeLogFound = false;\n\n                if (changeLines.length === 0) {\n                    throw new Error(`Couldn't find any status changes after running 'versionist', exiting`);\n                }\n                changeLines = _.slice(changeLines, 0, changeLines.length - 1);\n                // For each change, get the name of the change. We shouldn't see *anything* that isn't\n                // expected, and we should only see modifications. Log anything else as an issue\n                // (but not an error).\n                changeLines.forEach((line) => {\n                    // If we get anything other than an 'M', flag this.\n                    const match = line.match(/^\\sM\\s(.+)$/);\n                    if (!match) {\n                        throw new Error(`Found a spurious git status entry: ${line.trim()}, abandoning version up`);\n                    } else {\n                        // Remove the status so we just get a filename.\n                        if (match[1] !== 'CHANGELOG.md') {\n                            moddedFiles.push(match[1]);\n                        } else {\n                            changeLogFound = true;\n                        }\n                    }\n                });\n\n                // Ensure that the CHANGELOG.md file is always the last and that it exists!\n                if (!changeLogFound) {\n                    throw new Error(`Couldn't find the CHANGELOG.md file, abandoning version up`);\n                }\n                moddedFiles.push(`CHANGELOG.md`);\n\n                // Now we get the new version from the CHANGELOG (*not* the package.json, it may not exist).\n                return exec(`cat ${fullPath}${_.last(moddedFiles)}`).then((contents: string) => {\n                    // Only interested in the first match for '## v...'\n                    const match = contents.match(/^## (v[0-9]\\.[0-9]\\.[0-9]).+$/m);\n\n                    if (!match) {\n                        throw new Error('Cannot find new version for ${repoFullName}-#${pr.number}');\n                    }\n\n                    newVersion = match[1];\n                }).return(moddedFiles);\n            }).then((files: string[]) => {\n                // Read each file and base64 encode it.\n                return Promise.map(files, (file: string) => {\n                    return fs.readFileAsync(`${fullPath}${file}`).call(`toString`, 'base64').then((encoding: string) => {\n                        let newFile: FileMapping = {\n                            file,\n                            encoding,\n                        };\n                        return newFile;\n                    });\n                })\n            }).then((files: FileMapping[]) => {\n                // We use the Github API to now update every file in our list, ending with the CHANGELOG.md\n                // We need this to be the final file updated, as it'll kick off our actual merge.\n                //\n                // Turn all this into a single method, cleaner.\n                // CommitEncodedFile, or something.\n\n                // Get the top level hierarchy for the branch. It includes the files we need.\n                return this.gitCall(githubApi.gitdata.getTree, {\n                    owner,\n                    repo,\n                    sha: branchName\n                }).then((treeData: GithubBot.Tree) => {\n                    // We need to save the tree data, we'll be modifying it for updates in a moment.\n\n                    // Create a new blob for our files.\n                    // Implicit cast.\n                    return Promise.map(files, (file: EncodedFile) => {\n                        // Find the relevant entry in the tree.\n                        const treeEntry = _.find(treeData.tree, (treeEntry: GithubBot.TreeEntry) => {\n                            return treeEntry.path === file.file;\n                        });\n\n                        if (!treeEntry) {\n                            throw new Error(`Couldn't find a git tree entry for the file ${file.file}`);\n                        }\n\n                        file.treeEntry = treeEntry;\n                        return this.gitCall(githubApi.gitdata.createBlob, {\n                            owner,\n                            repo,\n                            content: file.encoding,\n                            encoding: 'base64'\n                        }).then((blob: GithubBot.Blob) => {\n                            if (file.treeEntry) {\n                                file.treeEntry.sha = blob.sha;\n                            }\n                        }).return(file);\n                    }).then((files: EncodedFile[]) => {\n                        // We now have a load of update tree path entries. We write the\n                        // data back to Github to get a new SHA for it.\n                        const newTree: GithubBot.TreeEntry[] = [];\n\n                        files.forEach((file: EncodedFile) => {\n                            newTree.push({\n                                path: file.treeEntry.path,\n                                mode: file.treeEntry.mode,\n                                type: 'blob',\n                                sha: file.treeEntry.sha\n                            })\n                        });\n\n                        // Now write this new tree and get back an SHA for it.\n                        return this.gitCall(githubApi.gitdata.createTree, {\n                            owner,\n                            repo,\n                            tree: newTree,\n                            base_tree: treeData.sha\n                        });\n                    }).then((newTree: GithubBot.Tree) => {\n                        newTreeSha = newTree.sha;\n\n                        // Get the last commit for the branch.\n                        return this.gitCall(githubApi.repos.getCommit, {\n                            owner,\n                            repo,\n                            sha: `${branchName}`\n                        });\n                    }).then((lastCommit: GithubBot.Commit) => {\n                        // We have new tree object, we now want to create a new commit referencing it.\n                        return this.gitCall(githubApi.gitdata.createCommit, {\n                            owner,\n                            repo,\n                            message: `${newVersion}`,\n                            tree: newTreeSha,\n                            parents: [ lastCommit.sha ],\n                            committer: {\n                                name: 'Versionbot',\n                                email: 'versionbot@whaleway.net'\n                            }\n                        });\n                    }).then((commit: GithubBot.Commit) => {\n                        // Finally, we now update the reference to the branch that's changed.\n                        // This should kick off the change for status.\n                        return this.gitCall(githubApi.gitdata.updateReference, {\n                            owner,\n                            repo,\n                            ref: `heads/${branchName}`,\n                            sha: commit.sha,\n                            force: false // Not that I'm paranoid...\n                        });\n                    });\n                });\n            }).then(() => {\n                this.log(ProcBot.LogLevel.INFO, `Upped version of ${repoFullName} to ${newVersion}; tagged and pushed.`);\n            });\n            // Maybe on an error, we should comment on the PR directly?\n        });\n    };\n}\n\n// Export the Versionbot to the app.\n// We register the Github events we're interested in here.\nexport function createBot(integration: number): VersionBot {\n    if (!(process.env.VERSIONBOT_NAME && process.env.VERSIONBOT_EMAIL)) {\n        throw new Error(`'VERSIONBOT_NAME' and 'VERSIONBOT_EMAIL' environment variables need setting`);\n    }\n\n    return new VersionBot(process.env.INTEGRATION_ID);\n}\n"],"sourceRoot":"../lib"}