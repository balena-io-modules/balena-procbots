{"version":3,"sources":["versionbot.ts"],"names":[],"mappings":"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","file":"versionbot.js","sourcesContent":["/*\nCopyright 2016 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// VersionBot listens for merges of a PR to the `master` branch and then\n// updates any packages for it.\nimport * as ProcBot from './procbot';\nimport { GithubBot, GithubCall, GithubPRCall } from './githubbot';\nimport { WorkerMethod, BotEvent } from './procbot';\nimport * as Promise from 'bluebird';\nimport Path = require('path');\nimport * as _ from 'lodash';\nimport * as path from 'path';\n\n//const temp: any = Promise.promisifyAll(require('temp').track());\nconst temp: any = Promise.promisifyAll(require('temp'));\nconst mkdirp: any = Promise.promisify(require('mkdirp'));\nconst rmdir: any = Promise.promisify(require('rmdir'));\nconst exec: any = Promise.promisify(require('child_process').exec);\nconst fs: any = Promise.promisifyAll(require('fs'));\n\n// TBD\n// Constant a load of the text ('Versionbot' + email + etc.)\n\n// Here's something worth noting, some of the URLs that the 'github' API\n// calls have changed and are no longer valid. Sigh.\n// PR reviews are notable in this regard.\nconst GithubApi: any = require('github');\n\n// The VersionBot is built ontop of GithubBot, which does all the heavy lifting and scheduling.\nexport class VersionBot extends GithubBot {\n\t// Name and register ourself.\n\tconstructor(webhooks: string[], integration: number) {\n\t\tsuper(webhooks, integration);\n\n\t\t// This is the VersionBot.\n\t\tthis._botname = 'VersionBot';\n\n\t\t// Authenticate the Github API.\n\t\tthis._github.authenticate();\n\n\t\tthis.log(ProcBot.LogLevel.INFO, 'Starting up');\n\t}\n\n\t// When a relevant event occurs, this is fired.\n\tfiredEvent(event: string, repoEvent: any): void {\n\t\t// Just call GithubBot's queueEvent method, telling it which method to use.\n\t\t// QueueEvent needs to become QueueTrigger (Action?) and what needs to be passed is\n\t\t// a number of events that will cause this to fire, as well as optional labels.\n\t\t// Should triggerLabels exist, then these are all the labels that are required for\n\t\t// an operation to occur (should it be valid). suppressLabels must not be passed!\n\t\t// Should suppressLabels exist, then these are all the labels that need to exist\n\t\t// for the trigger to be suppressed. Obviously fewer labels mean greater suppression.\n\t\t// triggerLabels must not be passed!\n\t\t//\n\t\t// {\n\t\t// \t  events: [...],\n\t\t//    triggerLabels: [...]  \\\n\t\t//    suppressLabels: [...] /  ONLY one of these may be filled in\n\t\t// }\n\t\t// Actually, we don't do this here. What we do is have a separate registration function\n\t\t// specifically for GithubBot which notes the events and the labels we want.\n\t\t// queueEvent merely sends the event and the data for it.\n\t\t// This means we have a separate handler which GithubBot registers for *all* events to the\n\t\t// worker thread, which always calls it and determines where the event/labels should go to\n\t\t// or if the action should be suppressed:\n\t\t//\n\t\t// versionbot: githubBot.registerAction(events, labels, suppressions, workerMethod)\n\t\t// -> githubBot: worker.registerHandler(githubbot.eventCheck);\n\t\t// Event fires: queueEvent(event, data) -> githubBot.eventCheck(event, data)\n\t\t// -> checking stuff -> versionbot.action(event, data)\n\t\tthis.queueEvent({\n\t\t\tevent: event,\n\t\t\trepoData: repoEvent,\n\t\t\tworkerMethod: this.prHandler\n\t\t});\n\t}\n\n\t// Handle a particular PR event.\n\tprotected prHandler = (event: string, data: any) => {\n\t\tlet method = Promise.resolve();\n\n\t\tif (event === 'pull_request') {\n\t\t\tswitch (data.action) {\n\t\t\t\t// Version check for a PR open or commit against it.\n\t\t\t\tcase 'opened':\n\t\t\t\tcase 'synchronize':\n\t\t\t\t\tmethod = this.checkVersioning(event, data);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Check the rest at merge, if it's not for it it'll exit.\n\t\t\t\tdefault:\n\t\t\t\t\tmethod = this.mergePR(event, data);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (event === 'pull_request_review') {\n\t\t\tmethod = this.mergePR(event, data);\n\t\t}\n\n\t\treturn method;\n\t}\n\n\t// Checks the newly opened PR and its commits.\n\t//  1. Triggered by an 'opened' or 'synchronize' event.\n\t//  2. If any PR commit has a 'Change-Type: <type>' commit, we create a status approving the PR.\n\t//  3. If no PR commit has a 'Change-Type: <type>' commit, we create a status failing the PR.\n\tprotected checkVersioning = (event: string, data: any) => {\n\t\tconst githubApi = this._github.githubApi;\n\t\tconst gitCall = this._github.makeCall;\n\t\tconst pr = data.pull_request;\n\t\tconst head = data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst name = head.repo.name;\n\t\tconsole.log('PR has been opened or synchronised, check for commits');\n\n\t\treturn gitCall(githubApi.pullRequests.getCommits, {\n\t\t\towner: owner,\n\t\t\trepo: name,\n\t\t\tnumber: pr.number\n\t\t}).then((commits: any) => {\n\t\t\tlet changetypeFound: boolean = false;\n\t\t\t// Go through all the commits. We're looking for, at a minimum, a 'change-type:' tag.\n\t\t\tfor (let index = 0; index < commits.length; index += 1) {\n\t\t\t\tconst commit: any = commits[index];\n\t\t\t\tconst commitMessage: string = commit.commit.message;\n\t\t\t\tconst invalidCommit = !commitMessage.match(/^change-type:\\s*(patch|minor|major)\\s*$/mi);\n\n\t\t\t\tif (!invalidCommit) {\n\t\t\t\t\tchangetypeFound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we found a change-type message, then mark this commit as ok.\n\t\t\tif (changetypeFound) {\n\t\t\t\treturn gitCall(githubApi.repos.createStatus, {\n\t\t\t\t\towner: owner,\n\t\t\t\t\trepo: name,\n\t\t\t\t\tsha: head.sha,\n\t\t\t\t\tstate: 'success',\n\t\t\t\t\tdescription: 'Found a valid Versionist `Change-Type` tag',\n\t\t\t\t\tcontext: 'Versionist'\n\t\t\t\t}).return(true);\n\t\t\t}\n\n\t\t\t// Else we mark it as having failed.\n\t\t\treturn gitCall(githubApi.repos.createStatus, {\n\t\t\t\towner: owner,\n\t\t\t\trepo: name,\n\t\t\t\tsha: head.sha,\n\t\t\t\tstate: 'failure',\n\t\t\t\tdescription: 'None of the commits in the PR have a `Change-Type` tag',\n\t\t\t\tcontext: 'Versionist'\n\t\t\t}).return(false);\n\t\t}).then(() => {\n\t\t\t// If the author was Versionbot and the file marked was CHANGELOG, then\n\t\t\t// we are now going to go ahead and perform a merge.\n\t\t\t//\n\t\t\t// Get the list of commits for the PR, then get the very last commit SHA.\n\t\t\treturn gitCall(githubApi.repos.getCommit, {\n\t\t\t\towner,\n\t\t\t\trepo: name,\n\t\t\t\tsha: head.sha\n\t\t\t}).then((headCommit: any) => {\n\t\t\t\t// We will go ahead and perform a merge if we see Versionbot has committed\n\t\t\t\t// something with 'CHANGELOG.md' in it.\n\t\t\t\tconst commit = headCommit.commit;\n\t\t\t\tconst files = headCommit.files;\n\n\t\t\t\tif ((commit.committer.name === 'Versionbot') &&\n\t\t\t\t\t_.find(files, (file: any) => {\n\t\t\t\t\t\treturn file.filename === 'CHANGELOG.md';\n\t\t\t\t})) {\n\t\t\t\t\t\t// We go ahead and merge.\n\t\t\t\t\t\tconst commitVersion = commit.message;\n\t\t\t\t\t\treturn gitCall(githubApi.pullRequests.merge, {\n\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\trepo: name,\n\t\t\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\t\t\tcommit_title: `Auto-merge for PR ${pr.number} via Versionbot`\n\t\t\t\t\t\t}, 3).then((mergedData: any) => {\n\t\t\t\t\t\t\t// We get an SHA back when the merge occurs, and we use this for a tag.\n\t\t\t\t\t\t\t// Note date gets filed in automatically by API.\n\t\t\t\t\t\t\treturn gitCall(githubApi.gitdata.createTag, {\n\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\trepo: name,\n\t\t\t\t\t\t\t\ttag: commitVersion,\n\t\t\t\t\t\t\t\tmessage: commitVersion,\n\t\t\t\t\t\t\t\tobject: mergedData.sha,\n\t\t\t\t\t\t\t\ttype: 'commit',\n\t\t\t\t\t\t\t\ttagger: {\n\t\t\t\t\t\t\t\t\tname: 'Versionbot',\n\t\t\t\t\t\t\t\t\temail: 'versionbot@whaleway.net'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}).then((newTag: any) => {\n\t\t\t\t\t\t\tconsole.log(newTag);\n\t\t\t\t\t\t\t// We now have a SHA back that contains the tag object.\n\t\t\t\t\t\t\t// Create a new reference based on it.\n\t\t\t\t\t\t\treturn gitCall(githubApi.gitdata.createReference, {\n\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\trepo: name,\n\t\t\t\t\t\t\t\tref: `refs/tags/${commitVersion}`,\n\t\t\t\t\t\t\t\tsha: newTag.sha\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Merges a PR, if appropriate:\n\t//  1. Triggered by a 'labeled' event ('flow/ready-to-merge') or a 'pull_request_review_comment'\n\t//  2. Checks all review comments to ensure that at least one approves the PR (and that no comment\n\t//     that may come after it includes a 'CHANGES_REQUESTED' state).\n\t//  3. Merges the PR to master, deletes the branch (does *not* close any associated PR).\n\t//\n\t// It should be noted that this will, of course, result in a 'closed' event on a PR, which\n\t// in turn will feed into the 'generateVersion' method below.\n\tprotected mergePR = (event: string, data: any) => {\n\t\t// States for review comments are:\n\t\t//  * COMMENT\n\t\t//  * CHANGES_REQUESTED\n\t\t//  * APPROVED\n\t\t//\n\t\t// We *only* go through with a merge should:\n\t\t//  * The 'flow/ready-to-merge' label appear on the PR issue\n\t\t//  * There is an 'APPROVED' review comment *and* no comment after is of state 'CHANGES_REQUESTED'\n\t\t// The latter overrides the label should it exist, as it will be assumed it is in error.\n\t\tconst githubApi = this._github.githubApi;\n\t\tconst gitCall = this._github.makeCall;\n\t\tconst pr = data.pull_request;\n\t\tconst head = data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst name = head.repo.name;\n\t\tlet approvePromise: Promise<boolean> = Promise.resolve(false);\n\t\tlet labelPromise: Promise<boolean> = Promise.resolve(false);\n\n\t\tconsole.log('PR has been updated with comments or a label');\n\n\t\tconst getReviewComments = () => {\n\t\t\treturn gitCall(githubApi.pullRequests.getReviews, {\n\t\t\t\towner: owner,\n\t\t\t\trepo: name,\n\t\t\t\tnumber: pr.number\n\t\t\t}).then((reviews: any[]) => {\n\t\t\t\t// Cycle through reviews, ensure that any approved review occurred after any requiring changes.\n\t\t\t\tlet approved: boolean = false;\n\t\t\t\treviews.forEach((review: any) => {\n\t\t\t\t\tif (review.state === 'APPROVED') {\n\t\t\t\t\t\tapproved = true;\n\t\t\t\t\t} else if (review.state === 'CHANGES_REQUESTED') {\n\t\t\t\t\t\tapproved = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn approved;\n\t\t\t});\n\t\t};\n\n\t\tconst getLabels = ()=> {\n\t\t\treturn gitCall(githubApi.issues.getIssueLabels, {\n\t\t\t\towner: owner,\n\t\t\t\trepo: name,\n\t\t\t\tnumber: pr.number\n\t\t\t}).then((labels: any) => {\n\t\t\t\t// Check to see if we have a 'flow/ready-to-merge' label.\n\t\t\t\tlet mergeLabelFound = false;\n\t\t\t\tlabels.forEach((label: any) => {\n\t\t\t\t\tif (label.name === 'flow/ready-to-merge') {\n\t\t\t\t\t\tmergeLabelFound = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn mergeLabelFound;\n\t\t\t});\n\t\t};\n\n\t\t// Check the action on the event to see what we're dealing with.\n\t\tswitch (data.action) {\n\t\t\t// Submission is a PR review\n\t\t\tcase 'submitted':\n\t\t\t\t// Data action will always be submitted.\n\t\t\t\t// Do we need changes? If so we short-circuit.\n\t\t\t\tif (data.review.state === 'changes_requested') {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t} else if (data.review.state === 'approved') {\n\t\t\t\t\t// Else if approved, just get the labels.\n\t\t\t\t\tapprovePromise = Promise.resolve(true);\n\t\t\t\t} else {\n\t\t\t\t\t// For every other type of comment, get the list of review comments.\n\t\t\t\t\tapprovePromise = getReviewComments();\n\t\t\t\t}\n\n\t\t\t\t// We always need to get the labels.\n\t\t\t\tlabelPromise = getLabels();\n\t\t\t\tbreak;\n\n\t\t\t// Labeled or unlabeled is... a label.\n\t\t\tcase 'labeled':\n\t\t\tcase 'unlabeled':\n\t\t\t\t// If the label was just created, or edited, then it's valid!\n\t\t\t\tif (data.label.name === 'flow/ready-to-merge') {\n\t\t\t\t\t// If deleted, short-circuit, not ready to merge.\n\t\t\t\t\tif (data.action === 'unlabeled') {\n\t\t\t\t\t\tconsole.log('Label: deleted');\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelPromise = Promise.resolve(true);\n\t\t\t\t} else {\n\t\t\t\t\tlabelPromise = getLabels();\n\t\t\t\t}\n\n\t\t\t\t// We always need to get the review comments.\n\t\t\t\tapprovePromise = getReviewComments();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// We have no idea what sparked this, but we're not doing anything!\n\t\t\t\tconsole.log(`Data action wasn't useful for merging`);\n\t\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.all([\n\t\t\tapprovePromise,\n\t\t\tlabelPromise\n\t\t]).then((results: boolean[]) => {\n\t\t\tif (!_.includes(results, false)) {\n\t\t\t\t// If all is well, we now generate a new version.\n\t\t\t\t// This will end up committing relevant files, which in turn will get\n\t\t\t\t// `sychronized`, kicking off a status check and final merge.\n\t\t\t\treturn this.generateVersion(owner, name, pr.number);\n\t\t\t}\n\n\t\t\tconsole.log(`Unable to merge: PRapproved(${results[0]}, Labels(${results[1]})`);\n\t\t});\n\t};\n\n\t// Actually generate a new version of a component:\n\t// 1. Clone the repo\n\t// 2. Checkout the appropriate branch given the PR number\n\t// 3. Run `versionist`\n\t// 4. Read the `CHANGELOG.md` (and any `package.json`, if present)\n\t// 5. Base64 encode them\n\t// 6. Call Github to update them, in serial, CHANGELOG last (important for merging expectations)\n\t// 7. Finish\n\tprotected generateVersion = (owner: string, repo: string, pr: number) => {\n\t\tconsole.log('PR is ready to merge, attempting to carry out a version up.');\n\n\t\t// Ensure we have a base directory to use.\n\t\tconst githubApi = this._github.githubApi;\n\t\tconst gitCall = this._github.makeCall;\n\t\tconst repoFullName = `${owner}/${repo}`;\n\t\tconst cwd = process.cwd();\n\t\tlet newVersion: string;\n\t\tlet fullPath: string;\n\t\tlet branchName: string;\n\t\tlet newTreeSha: string;\n\n\t\tinterface EncodedFile {\n\t\t\tfile: string,\n\t\t\tencoding: string,\n\t\t\ttreeEntry?: any,\n\t\t\tblobSha?: string\n\t\t};\n\n\t\t// Get the branch for this PR.\n\t\treturn gitCall(githubApi.pullRequests.get, {\n\t\t\towner: owner,\n\t\t\trepo: repo,\n\t\t\tnumber: pr\n\t\t}).then((prInfo: any) => {\n\t\t\t// Get the relevant branch.\n\t\t\tbranchName = prInfo.head.ref;\n\n\t\t\t// Create new work dir.\n\t\t\treturn temp.mkdirAsync(`${repo}-${pr}_`).then((tempDir: string) => {\n\t\t\t\tfullPath = `${tempDir}${path.sep}`;\n\n\t\t\t\t// Clone the repository inside the directory using the commit name and the run versionist.\n\t\t\t\t// We only care about output from the git status.\n\t\t\t\t// IMPORTANT NOTE: Currently, Versionist will fail if it doesn't find a\n\t\t\t\t// \t`package.json` file. This needs rectifying in Versionist, as this code doesn't pick it up.\n\t\t\t\tconst promiseResults: string[] = [];\n\t\t\t\treturn Promise.mapSeries([\n\t\t\t\t\t`git clone https://${process.env.WEBHOOK_SECRET}:x-oauth-basic@github.com/${repoFullName} ${fullPath}`,\n\t\t\t\t\t`git checkout ${branchName}`,\n\t\t\t\t\t'versionist',\n\t\t\t\t\t'git status -s'\n\t\t\t\t], (command) => {\n\t\t\t\t\treturn exec(command, { cwd: fullPath });\n\t\t\t\t}).get(3)\n\t\t\t});\n\t\t}).then((status: string) => {\n\t\t\t// Split the changes by line\n\t\t\tlet changeLines = status.split('\\n');\n\t\t\tconst moddedFiles: string[] = [];\n\t\t\tlet changeLogFound = false;\n\n\t\t\tif (changeLines.length === 0) {\n\t\t\t\tthrow new Error(`Couldn't find any status changes after running 'versionist', exiting`);\n\t\t\t}\n\t\t\tchangeLines = _.slice(changeLines, 0, changeLines.length - 1);\n\t\t\t// For each change, get the name of the change. We shouldn't see *anything* that isn't\n\t\t\t// expected, and we should only see modifications. Log anything else as an issue\n\t\t\t// (but not an error).\n\t\t\tchangeLines.forEach((line) => {\n\t\t\t\t// If we get anything other than an 'M', flag this.\n\t\t\t\tconst match = line.match(/^\\sM\\s(.+)$/);\n\t\t\t\tif (!match) {\n\t\t\t\t\tthrow new Error(`Found a spurious git status entry: ${line.trim()}, abandoning version up`);\n\t\t\t\t} else {\n\t\t\t\t\t// Remove the status so we just get a filename.\n\t\t\t\t\tif (match[1] !== 'CHANGELOG.md') {\n\t\t\t\t\t\tmoddedFiles.push(match[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchangeLogFound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Ensure that the CHANGELOG.md file is always the last and that it exists!\n\t\t\tif (!changeLogFound) {\n\t\t\t\tthrow new Error(`Couldn't find the CHANGELOG.md file, abandoning version up`);\n\t\t\t}\n\t\t\tmoddedFiles.push(`CHANGELOG.md`);\n\n\t\t\t// Now we get the new version from the CHANGELOG (*not* the package.json, it may not exist).\n\t\t\treturn exec(`cat ${fullPath}${_.last(moddedFiles)}`).then((contents: string) => {\n\t\t\t\t// Only interested in the first match for '## v...'\n\t\t\t\tconst match = contents.match(/^## (v[0-9]\\.[0-9]\\.[0-9]).+$/m);\n\n\t\t\t\tif (!match) {\n\t\t\t\t\tthrow new Error('Cannot find new version for ${repo}-${pr}');\n\t\t\t\t}\n\n\t\t\t\tnewVersion = match[1];\n\t\t\t}).return(moddedFiles);\n\t\t}).then((files: string[]) => {\n\t\t\t// Read each file and base64 encode it.\n\t\t\treturn Promise.map(files, (file: string) => {\n\t\t\t\treturn fs.readFileAsync(`${fullPath}${file}`).call(`toString`, 'base64').then((encoding: string) => {\n\t\t\t\t\tlet newFile: EncodedFile = {\n\t\t\t\t\t\tfile,\n\t\t\t\t\t\tencoding\n\t\t\t\t\t};\n\t\t\t\t\treturn newFile;\n\t\t\t\t});\n\t\t\t})\n\t\t}).then((files: EncodedFile[]) => {\n\t\t\t// We use the Github API to now update every file in our list, ending with the CHANGELOG.md\n\t\t\t// We need this to be the final file updated, as it'll kick off our actual merge.\n\t\t\t//\n\t\t\t// Turn all this into a single method, cleaner.\n\t\t\t// CommitEncodedFile, or something.\n\n\t\t\t// Get the top level hierarchy for the branch. It includes the files we need.\n\t\t\treturn gitCall(githubApi.gitdata.getTree, {\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tsha: branchName\n\t\t\t}).then((treeData: any) => {\n\t\t\t\t// We need to save the tree data, we'll be modifying it for updates in a moment.\n\n\t\t\t\t// Create a new blob for our files.\n\t\t\t\treturn Promise.map(files, (file: EncodedFile) => {\n\t\t\t\t\t// Find the relevant entry in the tree.\n\t\t\t\t\tfile.treeEntry = _.find(treeData.tree, (treeEntry: any) => {\n\t\t\t\t\t\treturn treeEntry.path === file.file;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!file.treeEntry) {\n\t\t\t\t\t\tthrow new Error(`Couldn't find a git tree entry for the file ${file.file}`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn gitCall(githubApi.gitdata.createBlob, {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t\tcontent: file.encoding,\n\t\t\t\t\t\tencoding: 'base64'\n\t\t\t\t\t}).then((blob: any) => {\n\t\t\t\t\t\tfile.treeEntry.sha = blob.sha;\n\t\t\t\t\t}).return(file);\n\t\t\t\t}).then((files: EncodedFile[]) => {\n\t\t\t\t\t// We now have a load of update tree path entries. We write the\n\t\t\t\t\t// data back to Github to get a new SHA for it.\n\t\t\t\t\tconst newTree: any[] = [];\n\n\t\t\t\t\tfiles.forEach((file: EncodedFile) => {\n\t\t\t\t\t\tnewTree.push({\n\t\t\t\t\t\t\tpath: file.treeEntry.path,\n\t\t\t\t\t\t\tmode: file.treeEntry.mode,\n\t\t\t\t\t\t\ttype: 'blob',\n\t\t\t\t\t\t\tsha: file.treeEntry.sha\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\t// Now write this new tree and get back an SHA for it.\n\t\t\t\t\treturn gitCall(githubApi.gitdata.createTree, {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t\ttree: newTree,\n\t\t\t\t\t\tbase_tree: treeData.sha\n\t\t\t\t\t});\n\t\t\t\t}).then((newTree: any) => {\n\t\t\t\t\tnewTreeSha = newTree.sha;\n\n\t\t\t\t\t// Get the last commit for the branch.\n\t\t\t\t\treturn gitCall(githubApi.repos.getCommit, {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t\tsha: `${branchName}`\n\t\t\t\t\t});\n\t\t\t\t}).then((lastCommit: any) => {\n\t\t\t\t\t// We have new tree object, we now want to create a new commit referencing it.\n\t\t\t\t\treturn gitCall(githubApi.gitdata.createCommit, {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t\tmessage: `${newVersion}`,\n\t\t\t\t\t\ttree: newTreeSha,\n\t\t\t\t\t\tparents: [ lastCommit.sha ],\n\t\t\t\t\t\tcommitter: {\n\t\t\t\t\t\t\tname: 'Versionbot',\n\t\t\t\t\t\t\temail: 'versionbot@whaleway.net'\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}).then((commit: any) => {\n\t\t\t\t\t// Finally, we now update the reference to the branch that's changed.\n\t\t\t\t\t// This should kick off the change for status.\n\t\t\t\t\treturn gitCall(githubApi.gitdata.updateReference, {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t\tref: `heads/${branchName}`,\n\t\t\t\t\t\tsha: commit.sha,\n\t\t\t\t\t\tforce: false // Not that I'm paranoid...\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}).then(() => {\n\t\t\tconsole.log(`Upped version of ${repoFullName} to ${newVersion}; tagged and pushed.`);\n\t\t}).catch((err: Error) => {\n\t\t\t// We post to the PR, informing we couldn't continue the merge.\n\t\t\tconsole.log(err);\n\t\t});\n\t}\n}\n\n// Export the Versionbot to the app.\n// We register the Github events we're interested in here.\nexport function createBot(integration: number): VersionBot {\n\n\treturn new VersionBot([ 'pull_request', 'pull_request_review' ], process.env.INTEGRATION_ID);\n}\n"],"sourceRoot":"../lib"}