{"version":3,"sources":["framework/procbot.ts"],"names":[],"mappings":"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","file":"procbot.js","sourcesContent":["/*\nCopyright 2016-2017 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport TypedError = require('typed-error');\nimport * as Promise from 'bluebird';\nimport * as ChildProcess from 'child_process';\nimport * as FS from 'fs';\nimport * as yaml from 'js-yaml';\nimport * as _ from 'lodash';\nimport { ServiceEmitRequest, ServiceEmitResponse, ServiceEmitter, ServiceFactory,\n\tServiceListener } from '../services/service-types';\nimport { Logger } from '../utils/logger';\nimport { ConfigurationLocation, ProcBotConfiguration, ProcBotErrorCode } from './procbot-types';\nconst fsReadFile = Promise.promisify(FS.readFile);\nconst exec: (command: string, options?: any) => Promise<{}> = Promise.promisify(ChildProcess.exec);\n\nexport class ProcBotError extends TypedError {\n\tprivate errorCode: ProcBotErrorCode;\n\n\tconstructor(code: ProcBotErrorCode, message: string) {\n\t\tsuper(message);\n\t\tthis.errorCode = code;\n\t}\n\n\tpublic get code() {\n\t\treturn this.errorCode;\n\t}\n}\n\n/**\n * The ProcBot class is a parent class that can be used for some top-level tasks:\n * * Schedule the processing of events clustered by a given context\n * * Support the addition of listeners or emitters by the child class, and dispatch events\n *   to emitters\n * * Retrieve configuration file from either the local FS or a ServiceEmitter\n */\nexport class ProcBot {\n\tprotected _botname: string;\n\tprotected logger = new Logger();\n\tprivate emitters: ServiceEmitter[] = [];\n\tprivate listeners: ServiceListener[] = [];\n\tprivate nodeBinPath: string;\n\n\tconstructor(name = 'ProcBot') {\n\t\tthis._botname = name;\n\t}\n\n\t/**\n\t * Retrieve the binary path for the Node dependencies.\n\t * @return  A string containing the absolute path.\n\t */\n\tpublic getNodeBinPath(): Promise<string> {\n\t\tif (this.nodeBinPath) {\n\t\t\treturn Promise.resolve(this.nodeBinPath);\n\t\t}\n\n\t\treturn exec('npm bin').then((binPath: string) => {\n\t\t\tthis.nodeBinPath = binPath.trim();\n\t\t\treturn this.nodeBinPath;\n\t\t});\n\t}\n\n\t/**\n\t * Process a configuration file from YAML into a nested object.\n\t * @param configFile  The configuration file as a string.\n\t * @return            The configuration object or void.\n\t */\n\tprotected processConfiguration(configFile: string): ProcBotConfiguration | void {\n\t\tconst config: ProcBotConfiguration = yaml.safeLoad(configFile);\n\n\t\tif (!config) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Swap out known tags that become booleans.\n\t\tconst minimumVersion = ((config || {}).procbot || {}).minimum_version;\n\t\tif (minimumVersion && process.env.npm_package_version) {\n\t\t\tif (process.env.npm_package_version < minimumVersion) {\n\t\t\t\tthrow new Error('Current ProcBot implementation does not meet minimum required version to run ');\n\t\t\t}\n\t\t}\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Retrieve a ProcBotConfiguration file from a ServiceEmitter or inbuilt route.\n\t * @param details  An object detailing the service to retrieve the configuration file from, and its location.\n\t * @return         A Promise containing configuration object should one have been found, or void.\n\t */\n\tprotected retrieveConfiguration(details: ConfigurationLocation): Promise<ProcBotConfiguration | void> {\n\t\tlet retrievePromise: Promise<string | void>;\n\t\tif (typeof details.emitter === 'string') {\n\t\t\tretrievePromise = fsReadFile(details.location).call('toString');\n\t\t} else {\n\t\t\tif (details.emitter.getConfigurationFile) {\n\t\t\t\tretrievePromise = details.emitter.getConfigurationFile(details);\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t}\n\n\t\treturn retrievePromise.then((configFile: string | void) => {\n\t\t\tif (configFile) {\n\t\t\t\treturn this.processConfiguration(configFile);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Add a new type of ServiceListener to the client.\n\t * Should the ServiceListener already exist on the client, this will do nothing.\n\t * @param name   The name of the ServiceListener to add.\n\t * @param data?  Any relevant data required to construct the ServiceListener.\n\t * @return       The constructed ServiceListener or void should it already exist or fail.\n\t */\n\tprotected addServiceListener(name: string, data?: any): ServiceListener | void {\n\t\tconst service = this.getService(name);\n\t\tlet listener;\n\n\t\tif (service && !_.find(this.listeners, [ 'serviceName', name ])) {\n\t\t\tlistener = service.createServiceListener(data);\n\t\t\tthis.listeners.push(listener);\n\t\t}\n\n\t\treturn listener;\n\t}\n\n\t/**\n\t * Add a new type of ServiceEmitter to the client.\n\t * Should the ServiceEmitter already exist on the client, this will do nothing.\n\t * @param name   The name of the ServiceEmitter to add.\n\t * @param data?  Any relevant data required to construct the ServiceEmitter.\n\t * @return       The constructed ServiceEmitter or void should it already exist or fail.\n\t */\n\tprotected addServiceEmitter(name: string, data?: any): ServiceEmitter | void {\n\t\tconst service = this.getService(name);\n\t\tlet emitter;\n\n\t\tif (service && !_.find(this.emitters, [ 'serviceName', name ])) {\n\t\t\temitter = service.createServiceEmitter(data);\n\t\t\tthis.emitters.push(emitter);\n\t\t}\n\n\t\treturn emitter;\n\t}\n\n\t/**\n\t * Find a particular attached ServiceListener based upon its name.\n\t * @param name  Name of the ServiceListener instance to find.\n\t * @return      Instance of the ServiceListener found, or void if not found.\n\t */\n\tprotected getListener(name: string): ServiceListener | void {\n\t\treturn _.find(this.listeners, (listener) => listener.serviceName === name);\n\t}\n\n\t/**\n\t * Find a particular attached ServiceEmitter based upon its name.\n\t * @param name  Name of the ServiceEmitter instance to find.\n\t * @return      Instance of the ServiceEmitter found, or void if not found.\n\t */\n\tprotected getEmitter(name: string): ServiceEmitter | void {\n\t\treturn _.find(this.emitters, (emitter) => emitter.serviceName === name);\n\t}\n\n\t// Returns a promise containing the results of all final send statuses.\n\t/**\n\t * Dispatch to the specified emitter.\n\t * This method exists as a shortcut to avoid having to retrieve a specific\n\t * emitter before sending to it.\n\t * @param data  The ServiceEmitRequest to use. This will be dispatched to all ServiceEmitters.\n\t * @return      An array of ServiceEmitResponses from all the ServiceEmitters.\n\t */\n\tprotected dispatchToAllEmitters(data: ServiceEmitRequest): Promise<ServiceEmitResponse[]> {\n\t\tlet results: ServiceEmitResponse[] = [];\n\n\t\t// If there's not a context for a particular emmiter, it will result in a response\n\t\t// with an error contained with in specifying as such. It is up to clients to determine\n\t\t// whether this is an issue or not\n\t\treturn Promise.map(this.emitters, (emitter) => {\n\t\t\treturn emitter.sendData(data)\n\t\t\t.then((result) => { results.push(result); })\n\t\t\t.catch((error) => { results.push(error); });\n\t\t}).return(results);\n\t}\n\n\t/**\n\t * Dispatch to a specific ServiceEmitter.\n\t * This method exists as a shortcut to avoid having to retrieve a specific\n\t * emitter before sending to it.\n\t * @param name  The name of the ServiceEmitter to dispatch to.\n\t * @param data  Emitter appropriate data to send.\n\t * @return      Data returned from the service represented by the ServiceEmitter.\n\t * @throws      Any error returned from the service represented by the ServiceEmitter.\n\t */\n\tprotected dispatchToEmitter(name: string, data: any): Promise<any> {\n\t\t// If emitter not found, this is an error\n\t\tconst emitInstance = _.find(this.emitters, (emitter) => emitter.serviceName === name);\n\n\t\tif (!emitInstance) {\n\t\t\tthrow new Error(`${name} emitter is not attached`);\n\t\t}\n\n\t\t// Create a new ServiceEmitRequest based on the data passed, the name of the service\n\t\t// to use and our name.\n\t\tconst request: ServiceEmitRequest = {\n\t\t\tcontexts: {},\n\t\t\tsource: this._botname\n\t\t};\n\t\trequest.contexts[name] = data;\n\n\t\treturn emitInstance.sendData(request).then((result) => {\n\t\t\t// If an error occured, throw it.\n\t\t\tif (result.err) {\n\t\t\t\tthrow result.err;\n\t\t\t}\n\n\t\t\treturn result.response;\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves and loads a ServiceListener or ServiceEmitter by name.\n\t * @param name  The name of the ServiceListener or ServiceEmitter to load.\n\t * @return      The relevant ServiceFactory for the service.\n\t */\n\tprivate getService(name: string): ServiceFactory {\n\t\t// Actually what we could do is just do a require, where the Service\n\t\t// exports a newly made object. We know that this always has a\n\t\t// `registerAction`, so that's all we care about.\n\t\tconst service: ServiceFactory = require(`../services/${name}`);\n\t\tif (!service) {\n\t\t\tthrow new Error(`Couldn't find Service: ${name}`);\n\t\t}\n\n\t\treturn service;\n\t}\n}\n"],"sourceRoot":"../../lib"}