{"version":3,"sources":["services/messenger.ts"],"names":[],"mappings":"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","file":"messenger.js","sourcesContent":["/*\n Copyright 2016-2017 Resin.io\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\nimport * as Promise from 'bluebird';\nimport * as bodyParser from 'body-parser';\nimport * as express from 'express';\nimport TypedError = require('typed-error');\nimport * as _ from 'lodash';\nimport { Worker } from '../framework/worker';\nimport { WorkerClient } from '../framework/worker-client';\nimport {\n\tLogger,\n\tLogLevel,\n} from '../utils/logger';\nimport {\n\tInterimContext,\n\tMessengerEmitResponse,\n\tMessengerEvent, MessengerIds,\n\tMessengerWorkerEvent, Metadata,\n\tReceiptContext, TransmitContext,\n} from './messenger-types';\nimport {\n\tServiceAPIHandle,\n\tServiceEmitContext,\n\tServiceEmitRequest,\n\tServiceEmitter,\n\tServiceListener,\n\tServiceRegistration,\n} from './service-types';\n\nexport abstract class Messenger extends WorkerClient<string|null> implements ServiceListener, ServiceEmitter {\n\t/**\n\t * Make a handle context, using a receipt context and some extra information.\n\t * @param event  Event to be converted.\n\t * @param to     Destination for the handle context.\n\t * @param toIds  Pre-populate the toIds, if desired.\n\t * @returns      Newly created context for handling a message.\n\t */\n\tpublic static initInterimContext(event: ReceiptContext, to: string, toIds: MessengerIds = {}): InterimContext {\n\t\treturn {\n\t\t\t// Details from the ReceiptContext\n\t\t\taction: event.action,\n\t\t\tfirst: event.first,\n\t\t\tgenesis: event.genesis,\n\t\t\thidden: event.hidden,\n\t\t\tsource: event.source,\n\t\t\tsourceIds: event.sourceIds,\n\t\t\ttext: event.text,\n\t\t\ttitle: event.title,\n\t\t\t// Details from the arguments\n\t\t\tto,\n\t\t\ttoIds,\n\t\t};\n\t}\n\n\t/** A place to put output for debug and reference. */\n\tprotected static logger = new Logger();\n\n\t/**\n\t * Retrieve from the environment array of strings to use as indicators of visibility\n\t * @returns  Object of arrays of indicators, shown and hidden.\n\t */\n\tprotected static getIndicatorArrays(): { 'shown': string[], 'hidden': string[] } {\n\t\tlet shown;\n\t\tlet hidden;\n\t\ttry {\n\t\t\t// Retrieve publicity indicators from the environment\n\t\t\tshown = JSON.parse(process.env.MESSAGE_CONVERTOR_PUBLIC_INDICATORS);\n\t\t\thidden = JSON.parse(process.env.MESSAGE_CONVERTOR_PRIVATE_INDICATORS);\n\t\t} catch (error) {\n\t\t\tthrow new Error('Message convertor environment variables not set correctly');\n\t\t}\n\t\tif (shown.length === 0 || hidden.length === 0) {\n\t\t\tthrow new Error('Message convertor environment variables not set correctly');\n\t\t}\n\t\treturn { hidden, shown };\n\t}\n\n\t/**\n\t * Encode the metadata of an event into a string to embed in the message.\n\t * @param data    Event to gather details from.\n\t * @param format  Optional, markdown or plaintext, defaults to markdown.\n\t * @returns       Text with data embedded.\n\t */\n\tprotected static stringifyMetadata(data: TransmitContext, format: 'markdown'|'plaintext' = 'markdown'): string {\n\t\tconst indicators = Messenger.getIndicatorArrays();\n\t\t// Build the content with the indicator and genesis at the front\n\t\tswitch (format) {\n\t\t\tcase 'markdown':\n\t\t\t\treturn `[${data.hidden ? indicators.hidden[0] : indicators.shown[0]}](${data.source})`;\n\t\t\tcase 'plaintext':\n\t\t\t\treturn `${data.hidden ? indicators.hidden[0] : indicators.shown[0]}:${data.source}`;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`${format} format not recognised`);\n\t\t}\n\t}\n\n\t/**\n\t * Given a basic string this will extract a more rich context for the event, if embedded.\n\t * @param message  Basic string that may contain metadata.\n\t * @returns        Object of content, genesis and hidden.\n\t */\n\tprotected static extractMetadata(message: string): Metadata {\n\t\tconst indicators = Messenger.getIndicatorArrays();\n\t\tconst visible = indicators.shown.join('|\\\\');\n\t\tconst hidden = indicators.hidden.join('|\\\\');\n\t\t// Anchored with new line; followed by whitespace.\n\t\t// Captured, the show/hide; brackets to enclose.\n\t\t// Then comes genesis; parens may surround.\n\t\t// The case we ignore; a Regex we form!\n\t\tconst findMetadata = new RegExp(`(?:^|\\\\r|\\\\n)(?:\\\\s*)\\\\[?(${hidden}|${visible})\\\\]?:?\\\\(?(\\\\w*)\\\\)?`, 'i');\n\t\tconst metadata = message.match(findMetadata);\n\t\tif (metadata) {\n\t\t\t// The content without the metadata, the word after the emoji, and whether the emoji is in the visible set\n\t\t\treturn {\n\t\t\t\tcontent: message.replace(findMetadata, '').trim(),\n\t\t\t\tgenesis: metadata[2] || null,\n\t\t\t\thidden: !_.includes(indicators.shown, metadata[1]),\n\t\t\t};\n\t\t}\n\t\t// Return some default values if there wasn't any metadata\n\t\treturn {\n\t\t\tcontent: message,\n\t\t\tgenesis: null,\n\t\t\thidden: true,\n\t\t};\n\t}\n\n\t/** A singleton express instance for all web-hook based message services to share. */\n\tprivate static _app: express.Express;\n\n\t/**\n\t * Create or retrieve the singleton express app.\n\t * @returns  Singleton express server app.\n\t */\n\tprotected static get app(): express.Express {\n\t\tif (!Messenger._app) {\n\t\t\t// Either MESSAGE_SERVICE_PORT from environment or PORT from Heroku environment\n\t\t\tconst port = process.env.MESSAGE_SERVICE_PORT || process.env.PORT;\n\t\t\tif (!port) {\n\t\t\t\tthrow new Error('No inbound port specified for express server');\n\t\t\t}\n\t\t\t// Create and log an express instance\n\t\t\tMessenger._app = express();\n\t\t\tMessenger._app.use(bodyParser.json());\n\t\t\tMessenger._app.listen(port);\n\t\t\tMessenger.logger.log(LogLevel.INFO, `---> Started MessageService shared web server on port '${port}'`);\n\t\t}\n\t\treturn Messenger._app;\n\t}\n\n\t/**\n\t * Promise to find the comment history of a particular thread.\n\t * @param thread  id of the thread to search.\n\t * @param room    id of the room in which the thread resides.\n\t * @param filter  Criteria to match.\n\t * @param search  Optional, some words which may be used to shortlist the results.\n\t */\n\tpublic abstract fetchNotes: (thread: string, room: string, filter: RegExp, search?: string) => Promise<string[]>;\n\n\t/**\n\t * Promise to turn the data enqueued into a generic message format.\n\t * @param data  Raw data from the enqueue, remembering this is as dumb and quick as possible.\n\t * @returns     A promise that resolves to the generic form of the event.\n\t */\n\tpublic abstract makeGeneric: (data: MessengerEvent) => Promise<ReceiptContext>;\n\n\t/**\n\t * Promise to turn a generic message format into a form suitable for emitting.\n\t * @param data  Generic message format to encode.\n\t * @returns     A promise that resolves to an emit context, which is as dumb as possible.\n\t */\n\tpublic abstract makeSpecific: (data: TransmitContext) => Promise<ServiceEmitContext>;\n\n\t/** Awaken this class as a listener. */\n\tprotected abstract activateMessageListener: () => void;\n\n\t/**\n\t * Deliver the payload to the service. Sourcing the relevant context has already been performed.\n\t * @param data  The object to be delivered to the service.\n\t * @returns     Response from the service endpoint.\n\t */\n\tprotected abstract sendPayload: (data: ServiceEmitContext) => Promise<MessengerEmitResponse>;\n\n\t/** A boolean flag for if this object has been activated as a listener. */\n\tprivate listening: boolean = false;\n\t/** An object of arrays storing events by trigger and their actions. */\n\tprivate _eventListeners: { [event: string]: ServiceRegistration[] } = {};\n\n\t/**\n\t * Build this service, specifying whether to awaken as a listener.\n\t * @param listener  Whether to start listening during construction.\n\t */\n\tconstructor(listener: boolean) {\n\t\tsuper();\n\t\tif (listener) {\n\t\t\t// Allow the sub-constructor to set up sessions, etc, before listening\n\t\t\tprocess.nextTick(this.listen);\n\t\t}\n\t}\n\n\t/** Start the object listening if it isn't already. */\n\tpublic listen = () => {\n\t\t// Ensure the code in the child object gets executed a maximum of once\n\t\tif (!this.listening) {\n\t\t\tthis.listening = true;\n\t\t\tthis.activateMessageListener();\n\t\t\tMessenger.logger.log(LogLevel.INFO, `---> Started '${this.serviceName}' listener`);\n\t\t}\n\t}\n\n\t/**\n\t * Store an event of interest, so that the method gets triggered appropriately.\n\t * @param registration  Registration object with event trigger and other details.\n\t */\n\tpublic registerEvent(registration: ServiceRegistration): void {\n\t\t// Store each event registration in an object of arrays.\n\t\tfor (const event of registration.events) {\n\t\t\tif (this._eventListeners[event] == null) {\n\t\t\t\tthis._eventListeners[event] = [];\n\t\t\t}\n\t\t\tthis._eventListeners[event].push(registration);\n\t\t}\n\t}\n\n\t/**\n\t * Emit data to the service.\n\t * @param data  Service Emit Request to send, if relevant.\n\t * @returns     Details of the successful transmission from the service.\n\t */\n\tpublic sendData(data: ServiceEmitRequest): Promise<MessengerEmitResponse> {\n\t\t// Check that the data has specifies a task for our emitter, before passing it on\n\t\tif (data.contexts[this.serviceName]) {\n\t\t\treturn this.sendPayload(data.contexts[this.serviceName]);\n\t\t}\n\t\t// If this data has no task for us then no-op is the correct resolution\n\t\treturn Promise.resolve({\n\t\t\terr: new TypedError(`No ${this.serviceName} context`),\n\t\t\tsource: this.serviceName,\n\t\t});\n\t}\n\n\t /**\n\t * Queue an event ready for running in a child.\n\t * @param data  The WorkerEvent to add to the queue for processing.\n\t */\n\tpublic queueEvent(data: MessengerWorkerEvent) {\n\t\t// This type guards a simple pass-through\n\t\tsuper.queueEvent(data);\n\t}\n\n\t/**\n\t * Turns the generic, messenger, name for an event into a specific trigger name for this class.\n\t * @param eventType  Name of the event to translate, eg 'message'.\n\t * @returns          This class's equivalent, eg 'post'.\n\t */\n\tpublic abstract translateEventName(eventType: string): string;\n\n\t/**\n\t * Pass an event to registered listenerMethods.\n\t * @param event  Enqueued event from the listener.\n\t * @returns      Promise that resolves once the event is handled.\n\t */\n\tprotected handleEvent = (event: MessengerEvent): Promise<void> => {\n\t\t// Retrieve and execute all the listener methods, squashing their responses\n\t\tconst listeners = this._eventListeners[event.cookedEvent.type] || [];\n\t\treturn Promise.map(listeners, (listener) => {\n\t\t\treturn listener.listenerMethod(listener, event);\n\t\t}).return();\n\t}\n\n\t/**\n\t * Get a Worker object for the provided event, threaded by context.\n\t * @param event  Event as enqueued by the listener.\n\t * @returns      Worker for the context associated.\n\t */\n\tprotected getWorker = (event: MessengerWorkerEvent): Worker<string|null> => {\n\t\t// Attempt to retrieve an active worker for the context\n\t\tconst context = event.data.cookedEvent.context;\n\t\tconst retrieved = this.workers.get(context);\n\t\tif (retrieved) {\n\t\t\treturn retrieved;\n\t\t}\n\t\t// Create and store a worker for the context\n\t\tconst created = new Worker<string>(context, this.removeWorker);\n\t\tthis.workers.set(context, created);\n\t\treturn created;\n\t}\n\n\t/**\n\t * Get the service name, as required by the framework.\n\t * @return  Name of the service.\n\t */\n\tabstract get serviceName(): string\n\n\t/**\n\t * Retrieve the SDK API instance handle for the service, should one exist.\n\t * @return  Service SDK API handle or void.\n\t */\n\tabstract get apiHandle(): ServiceAPIHandle | void;\n}\n"],"sourceRoot":"../../lib"}