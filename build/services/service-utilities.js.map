{"version":3,"sources":["services/service-utilities.ts"],"names":[],"mappings":"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","file":"service-utilities.js","sourcesContent":["/*\n Copyright 2016-2017 Resin.io\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\nimport TypedError = require('typed-error');\nimport * as Promise from 'bluebird';\nimport * as bodyParser from 'body-parser';\nimport * as express from 'express';\nimport { Worker } from '../framework/worker';\nimport { WorkerClient } from '../framework/worker-client';\nimport { Logger, LogLevel } from '../utils/logger';\nimport {\n\tServiceAPIHandle, ServiceEmitContext, ServiceEmitRequest, ServiceEmitResponse,\n\tServiceEmitter, ServiceListener, ServiceRegistration,\n} from './service-types';\nimport {\n\tUtilityServiceEvent, UtilityWorkerEvent\n} from './service-utilities-types';\n\n/**\n * A utility class to handle a bunch of the repetitive work associated with being a ServiceListener and ServiceEmitter\n *\n * This class provides:\n * - An always connect then maybe listen constructor flow.\n * - An express app, if asked for.\n * - A logger.\n * - An event registration and handling standard.\n * - Checks for and extracts data from context.\n * - A standard way of getting contextualised workers.\n * - Ensure activating as a listener only gets called once.\n *\n * In exchange you agree to:\n * - provide a `connect` method to connect this class to the service, called during construction and only once.\n * - provide a `startListening` method to activate this class as a listener, calling queueEvent as required.\n * - provide a `emitData` method which takes a ServiceEmitContext and returns a promise.\n * - provide a `verify` function which should check that incoming data isn't spoofed.\n * - provide a `serviceName` getter, which because it is based on file path cannot be inherited away.\n * - provide a `apiHandle` getter, which should return the underlying object that executes the requests.\n * - enqueue your events with `context` and `event` in cookedData, as per `UtilityServiceEvent`.\n */\nexport abstract class ServiceUtilities extends WorkerClient<string> implements ServiceListener, ServiceEmitter {\n\t/** A place to put output for debug and reference. */\n\tprivate _logger = new Logger();\n\n\t/** A singleton express instance for all web-hook based services to share. */\n\tprivate _expressApp: express.Express;\n\n\t/** Store a list of actions to perform when particular actions happen */\n\tprivate eventListeners: { [event: string]: ServiceRegistration[] } = {};\n\n\t/** A boolean flag for if this object has been activated as a listener. */\n\tprivate listening: boolean = false;\n\n\t/**\n\t * Build this service, specifying whether to awaken as a listener.\n\t * @param data    Object containing the required details for the service.\n\t * @param listen  Whether to start listening during construction.\n\t */\n\tconstructor(data: object, listen: boolean) {\n\t\tsuper();\n\t\tthis.connect(data);\n\t\tthis.logger.log(LogLevel.INFO, `---> '${this.serviceName}' connected.`);\n\t\tif (listen) {\n\t\t\tthis.listen();\n\t\t}\n\t}\n\n\t/**\n\t * Store an event of interest, so that the method gets triggered appropriately.\n\t * @param registration  Registration object with event trigger and other details.\n\t */\n\tpublic registerEvent(registration: ServiceRegistration): void {\n\t\t// Store each event registration in an object of arrays.\n\t\tfor (const event of registration.events) {\n\t\t\tif (!this.eventListeners[event]) {\n\t\t\t\tthis.eventListeners[event] = [];\n\t\t\t}\n\t\t\tthis.eventListeners[event].push(registration);\n\t\t}\n\t}\n\n\t/**\n\t * Emit data to the service.\n\t * @param data  Service Emit Request to send, if relevant.\n\t * @returns     Details of the successful transmission from the service.\n\t */\n\tpublic sendData(data: ServiceEmitRequest): Promise<ServiceEmitResponse> {\n\t\ttry {\n\t\t\tconst context = data.contexts[this.serviceName] as ServiceEmitContext;\n\t\t\tif (context) {\n\t\t\t\treturn new Promise<ServiceEmitResponse>((resolve) => {\n\t\t\t\t\tthis.emitData(context)\n\t\t\t\t\t.then((response: any) => {\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\tsource: this.serviceName,\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch((err: TypedError) => {\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\tsource: this.serviceName,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve({\n\t\t\t\t\terr: new TypedError(`No ${this.serviceName} context`),\n\t\t\t\t\tsource: this.serviceName,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch(err) {\n\t\t\treturn Promise.resolve({\n\t\t\t\terr,\n\t\t\t\tsource: this.serviceName,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Queue an event ready for running in a child, here to type guard.\n\t * @param data  The WorkerEvent to add to the queue for processing.\n\t */\n\tprotected queueData = (data: UtilityServiceEvent) => {\n\t\tif (this.verify(data)) {\n\t\t\tsuper.queueEvent({\n\t\t\t\tdata,\n\t\t\t\tworkerMethod: this.handleEvent\n\t\t\t});\n\t\t} else {\n\t\t\tthis.logger.log(LogLevel.WARN, `Event failed verification.`);\n\t\t}\n\t}\n\n\t/**\n\t * Connect to the service, used as part of construction.\n\t * @param data  Object containing the required details for the service.\n\t */\n\tprotected abstract connect(data: any): void\n\n\t/**\n\t * Emit a payload to the endpoint defined, resolving when done.\n\t * endpoint  Definition of the endpoint to emit to.\n\t * payload   Data to be delivered.\n\t */\n\tprotected abstract emitData(data: ServiceEmitContext): any;\n\n\t/** Awaken this class as a listener. */\n\tprotected abstract startListening(): void;\n\n\t/**\n\t * Verify the event before enqueueing.  A naive approach could be to simply return true, but that must be explicit.\n\t * @param data  The data object that was enqueued.\n\t */\n\tprotected abstract verify(data: UtilityServiceEvent): boolean\n\n\t/**\n\t * Get a Worker object for the provided event, threaded by context.\n\t * @param event  Event as enqueued by the listener.\n\t * @returns      Worker for the context associated.\n\t */\n\tprotected getWorker = (event: UtilityWorkerEvent): Worker<string> => {\n\t\t// Attempt to retrieve an active worker for the context\n\t\tconst context = event.data.cookedEvent.context;\n\t\tconst retrieved = this.workers.get(context);\n\t\tif (retrieved) {\n\t\t\treturn retrieved;\n\t\t}\n\t\t// Create and store a worker for the context\n\t\tconst created = new Worker<string>(context, this.removeWorker);\n\t\tthis.workers.set(context, created);\n\t\treturn created;\n\t}\n\n\t/**\n\t * Create or retrieve the express app.\n\t * @returns  Express server app.\n\t */\n\tprotected get expressApp(): express.Express {\n\t\tif (!this._expressApp) {\n\t\t\t// Either MESSAGE_SERVICE_PORT from environment or PORT from Heroku environment\n\t\t\tconst port = process.env.MESSAGE_SERVICE_PORT || process.env.PORT;\n\t\t\tif (!port) {\n\t\t\t\tthrow new Error('No inbound port specified for express server.');\n\t\t\t}\n\t\t\t// Create and log an express instance\n\t\t\tthis._expressApp = express();\n\t\t\tthis._expressApp.use(bodyParser.json());\n\t\t\tthis._expressApp.listen(port);\n\t\t\tthis.logger.log(LogLevel.INFO, `---> Started ProcBot shared web server on port '${port}'.`);\n\t\t}\n\t\treturn this._expressApp;\n\t}\n\n\t/**\n\t * Retrieve the logger, here to write-protect it\n\t * @returns  Logger instance for this class\n\t */\n\tprotected get logger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Pass an event to registered listenerMethods.\n\t * @param data  Enqueued data from the listener.\n\t * @returns     Promise that resolves once the event is handled.\n\t */\n\tprotected handleEvent = (data: UtilityServiceEvent): Promise<void> => {\n\t\t// Retrieve and execute all the listener methods, squashing their responses\n\t\tconst listeners = this.eventListeners[data.cookedEvent.event] || [];\n\t\treturn Promise.map(listeners, (listener) => {\n\t\t\treturn listener.listenerMethod(listener, data);\n\t\t}).return();\n\t}\n\n\t/** Start the object listening if it isn't already. */\n\tprivate listen = () => {\n\t\t// Ensure the code in the child object gets executed a maximum of once\n\t\tif (!this.listening) {\n\t\t\tthis.listening = true;\n\t\t\tthis.startListening();\n\t\t\tthis.logger.log(LogLevel.INFO, `---> '${this.serviceName}' listening.`);\n\t\t}\n\t}\n\n\t/**\n\t * Get the service name, as required by the framework.\n\t * @return  Name of the service.\n\t */\n\tabstract get serviceName(): string\n\n\t/**\n\t * Retrieve the SDK API instance handle for the service, should one exist.\n\t * @return  Service SDK API handle or void.\n\t */\n\tabstract get apiHandle(): ServiceAPIHandle | void;\n}\n"],"sourceRoot":"../../lib"}