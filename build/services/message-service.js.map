{"version":3,"sources":["services/message-service.ts"],"names":[],"mappings":"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","file":"message-service.js","sourcesContent":["import * as Promise from 'bluebird';\nimport * as bodyParser from 'body-parser';\nimport * as express from 'express';\nimport { Worker } from '../framework/worker';\nimport { WorkerClient } from '../framework/worker-client';\nimport {\n    Logger,\n    LogLevel,\n} from '../utils/logger';\nimport {\n    MessageEmitResponse,\n    MessageEvent,\n    MessageWorkerEvent,\n    ReceiptContext,\n} from '../utils/message-types';\nimport {\n    ServiceAPIHandle,\n    ServiceEmitContext,\n    ServiceEmitRequest,\n    ServiceEmitter,\n    ServiceListener,\n    ServiceRegistration,\n} from './service-types';\n\n/**\n * Abstract class to define a common set of utilities and standards for all messenger classes\n */\nexport abstract class MessageService extends WorkerClient<string|null> implements ServiceListener, ServiceEmitter {\n    protected static logger = new Logger();\n    private static _app: express.Express;\n    private listening: boolean = false;\n    private _eventListeners: { [event: string]: ServiceRegistration[] } = {};\n\n    /**\n     * All messenger classes share a single express instance\n     */\n    protected static get app(): express.Express {\n        // Heroku uses process.env.PORT to indicate which local area port the edge NAT maps down to\n        const port = process.env.MESSAGE_SERVICE_PORT || process.env.PORT;\n        if (!port) {\n            throw new Error('No inbound port specified for express server');\n        }\n        if (!MessageService._app) {\n            MessageService._app = express();\n            MessageService._app.use(bodyParser.json());\n            MessageService._app.listen(port);\n        }\n        return MessageService._app;\n    }\n\n    /**\n     * @param listener selector for whether this instance should listen\n     */\n    constructor(listener: boolean) {\n        super();\n        if (listener) {\n            this.listen();\n        }\n    }\n\n    /**\n     * Instruct the child to start listening if we haven't already\n     */\n    public listen() {\n        if (!this.listening) {\n            this.listening = true;\n            this.activateMessageListener();\n            MessageService.logger.log(LogLevel.INFO, `---> Started '${this.serviceName}' listener`);\n        }\n    }\n\n    /**\n     * Express an interest in a particular type of event\n     * @param registration Object detailing event type, callback, etc\n     */\n    public registerEvent(registration: ServiceRegistration): void {\n        // For each event type being registered\n        for (const event of registration.events) {\n            // Ensure we have a listener array for it\n            if (this._eventListeners[event] == null) {\n                this._eventListeners[event] = [];\n            }\n            // Store the expression of interest\n            this._eventListeners[event].push(registration);\n        }\n    }\n\n    /**\n     * Emit data to the external service\n     * @param data ServiceEmitRequest to parse\n     */\n    public sendData(data: ServiceEmitRequest): Promise<MessageEmitResponse> {\n        // Check the contexts for relevance before passing down the inheritance\n        if (data.contexts[this.serviceName]) {\n            return this.sendMessage(data.contexts[this.serviceName]);\n        } else {\n            // If we have a context to emit to this service, then no-op is correct resolution\n            return Promise.resolve({\n                err: new Error(`No ${this.serviceName} context`),\n                source: this.serviceName,\n            });\n        }\n    }\n\n    /**\n     * Enqueue a MessageWorkerEvent\n     * @param data event to enqueue\n     */\n    public queueEvent(data: MessageWorkerEvent) {\n        // This simply passes it up the chain...\n        // but ensures that MessageServices only enqueue the correct type\n        super.queueEvent(data);\n    }\n\n    // TODO: event should be in the same format as emitted\n    /**\n     * Retrieve the comments in a thread that match an optional filter\n     * @param event details to identify the event\n     * @param filter regex of comments to match\n     */\n    public fetchThread(_event: ReceiptContext, _filter: RegExp): Promise<string[]> {\n        return Promise.reject(new Error('Not yet implemented'));\n    }\n\n    // TODO: event should be in the same format as emitted\n    /**\n     * Retrieve the private message history with a user\n     * @param event details of the event to consider\n     * @param filter optional criteria that must be met\n     */\n    public fetchPrivateMessages(_event: ReceiptContext, _filter: RegExp): Promise<string[]> {\n        return Promise.reject(new Error('Not yet implemented'));\n    }\n\n    /**\n     * Activate this object as a listener\n     */\n    protected abstract activateMessageListener(): void;\n\n    /**\n     * Emit data to the API\n     * @param data emit context\n     */\n    protected abstract sendMessage(data: ServiceEmitContext): Promise<MessageEmitResponse>\n\n    /**\n     * Retrieve the scope for event order preservation\n     * @param event details to examine\n     */\n    protected abstract getWorkerContextFromMessage(event: MessageWorkerEvent): string\n\n    /**\n     * Retrieve the event type for event firing\n     * @param event details to examine\n     */\n    protected abstract getEventTypeFromMessage(event: MessageEvent): string\n\n    /**\n     * Handle an event once it's turn in the queue comes round\n     * Bound to the object instance using =>\n     */\n    protected handleEvent = (event: MessageEvent): Promise<void> => {\n        // Retrieve and execute all the listener methods, nerfing their responses\n        const listeners = this._eventListeners[event.cookedEvent.type] || [];\n        return Promise.map(listeners, (listener) => {\n            return listener.listenerMethod(listener, event);\n        }).return();\n    }\n\n    /**\n     * Retrieve or create a worker for an event\n     */\n    protected getWorker = (event: MessageWorkerEvent): Worker<string|null> => {\n        // Attempt to retrieve an active worker for the context\n        const context = this.getWorkerContextFromMessage(event);\n        const retrieved = this.workers.get(context);\n        if (retrieved) {\n            return retrieved;\n        // Create and store a worker for the context\n        } else {\n            const created = new Worker<string>(context, this.removeWorker);\n            this.workers.set(context, created);\n            return created;\n        }\n    }\n\n    /**\n     * get the service name, as required by the framework\n     */\n    abstract get serviceName(): string\n\n    // Retrieve the API handle, if any.\n    abstract get apiHandle(): ServiceAPIHandle | void;\n}\n"],"sourceRoot":"../../lib"}