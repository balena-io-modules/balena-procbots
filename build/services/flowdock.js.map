{"version":3,"sources":["services/flowdock.ts"],"names":[],"mappings":"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","file":"flowdock.js","sourcesContent":["/*\nCopyright 2016-2017 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as Promise from 'bluebird';\nimport {\n    Session\n} from 'flowdock';\nimport * as _ from 'lodash';\nimport * as path from 'path';\nimport * as request from 'request-promise';\nimport {\n    FlowdockHandle,\n    FlowdockMessage,\n    FlowdockMessageEmitContext,\n} from '../services/flowdock-types';\nimport {\n    MessageEmitResponse,\n    MessageEvent,\n    MessageWorkerEvent,\n    ReceiptContext,\n} from '../utils/message-types';\nimport {\n    MessageService\n} from './message-service';\nimport {\n    ServiceEmitter,\n    ServiceListener,\n} from './service-types';\n\n/**\n * Class for interacting with the Discourse API\n * Is a MessageService, ServiceListener and ServiceEmitter\n */\nexport class FlowdockService extends MessageService implements ServiceEmitter, ServiceListener {\n    private static session = new Session(process.env.FLOWDOCK_LISTENER_ACCOUNT_API_TOKEN);\n    private static _serviceName = path.basename(__filename.split('.')[0]);\n    private flowIdToFlowName = new Map<string, string>();\n\n    /**\n     * Retrieve the comments in a thread that match an optional filter\n     * @param event details to identify the event\n     * @param filter regex of comments to match\n     */\n    public fetchThread(event: ReceiptContext, filter: RegExp): Promise<string[]> {\n        // Check that the event being asked about orginated with us\n        if (event.source !== this.serviceName) {\n            return Promise.reject(new Error('Cannot get flowdock thread from non-flowdock event'));\n        }\n        return new Promise<string[]>((resolve, reject) => {\n            // Create an options array that'll shortlist the responses, if possible\n            const keywords = filter.source.match(/(\\w+)/g);\n            const options = keywords === null ? {} : { search: keywords.join(' ') };\n            // Query the API via the SDK\n            const org = process.env.FLOWDOCK_ORGANIZATION_PARAMETERIZED_NAME;\n            const room = event.sourceIds.room;\n            const thread = event.sourceIds.thread;\n            FlowdockService.session.get(\n                `/flows/${org}/${room}/threads/${thread}/messages`,\n                options,\n                (error?: Error, result?: FlowdockMessage[]) => {\n                    // Massage the callback response into promises\n                    if (error) {\n                        reject(error);\n                    } else if (result) {\n                        resolve(_.map(result, (value: FlowdockMessage) => {\n                                // Clean the response to just the content\n                                return value.content;\n                            }).filter((value: string) => {\n                                // Filter the response to just matches\n                                const match = value.match(filter);\n                                return match !== null && match.length > 0;\n                            })\n                        );\n                    // This should never happen, since the callback pattern should have error or response\n                    // ...but this respects typing\n                    } else {\n                        reject(new Error('Something weird happened in the flowdock SDK'));\n                    }\n                }\n            );\n        });\n    }\n\n    /**\n     * Retrieve the private message history with a user\n     * @param event details of the event to consider\n     * @param filter optional criteria that must be met\n     */\n    public fetchPrivateMessages(event: ReceiptContext, filter: RegExp): Promise<string[]> {\n        // Check that the event being asked about orginated with us\n        if (event.source !== this.serviceName) {\n            return Promise.reject(new Error('Cannot get flowdock thread from non-flowdock event'));\n        }\n        return new Promise<string[]>((resolve, reject) => {\n            // Create an options array for shortlisting, if possible\n            const keywords = filter.source.match(/(\\w+)/g);\n            const options = keywords === null ? {} : { search: keywords.join(' ') };\n            // Query the API via the SDK\n            FlowdockService.session.get(\n            `/private/${event.sourceIds.user}/messages`, options,\n            (error?: Error, result?: FlowdockMessage[]) => {\n                // Massage the callback response into promises\n                if (error) {\n                    reject(error);\n                } else if (result) {\n                    resolve(_\n                        // Clean the response to just the content\n                        .map(result, (value: FlowdockMessage) => {\n                            return value.content;\n                        })\n                        // Filter the response to just matches\n                        .filter((value: string) => {\n                            const match = value.match(filter);\n                            return match !== null && match.length > 0;\n                        })\n                    );\n                // This should never happen, since the callback pattern should have error or response\n                // ...but this respects typing\n                } else {\n                    reject(new Error('Something weird happened in the flowdock SDK'));\n                }\n            });\n        });\n    }\n\n    /**\n     * Activate this object as a listener\n     */\n    protected activateMessageListener(): void {\n        // Get a list of known flows from the session\n        FlowdockService.session.flows((error: any, flows: any) => {\n            if (error) {\n                throw error;\n            }\n            // Store the names and stream retrieved flows\n            const ids = [];\n            for (const flow of flows) {\n                ids.push(flow.id);\n                this.flowIdToFlowName.set(flow.id, flow.parameterized_name);\n            }\n            const stream = FlowdockService.session.stream(ids);\n            // Listen to messages and check they are messages\n            stream.on('message', (message: any) => {\n                if (message.event === 'message') {\n                    // Enqueue new message events\n                    this.queueEvent({\n                        data: {\n                            cookedEvent: {\n                                context: message.thread_id,\n                                flow: this.flowIdToFlowName.get(message.flow),\n                                type: message.event,\n                            },\n                            rawEvent: message,\n                            source: this.serviceName,\n                        },\n                        workerMethod: this.handleEvent,\n                    });\n                }\n            });\n        });\n        // Create a keep-alive endpoint\n        MessageService.app.get(`/${this.serviceName}/`, (_formData, response) => {\n            response.send('ok');\n        });\n    }\n\n    /**\n     * Retrieve the scope for event order preservation\n     * @param event details to examine\n     */\n    protected getWorkerContextFromMessage(event: MessageWorkerEvent): string {\n        return event.data.cookedEvent.context;\n    }\n\n    /**\n     * Retrieve the event type for event firing\n     * @param event details to examine\n     */\n    protected getEventTypeFromMessage(event: MessageEvent): string {\n        return event.cookedEvent.type;\n    }\n\n    /**\n     * Emit data to the API\n     * @param data emit context\n     */\n    protected sendMessage(body: FlowdockMessageEmitContext): Promise<MessageEmitResponse> {\n        // Extract a couple of details from the environment\n        const org = process.env.FLOWDOCK_ORGANIZATION_PARAMETERIZED_NAME;\n        const token = new Buffer(process.env.FLOWDOCK_LISTENER_ACCOUNT_API_TOKEN).toString('base64');\n        // Post to the API\n        const requestOpts = {\n            body,\n            headers: {\n                'Authorization': `Basic ${token}`,\n                'X-flowdock-wait-for-message': true,\n            },\n            json: true,\n            url: `https://api.flowdock.com/flows/${org}/${body.flow}/messages/`,\n        };\n        return request.post(requestOpts).then((resData: any) => {\n            // Massage the response into a suitable form for the framework\n            return {\n                response: {\n                    ids: {\n                        message: resData.id,\n                        thread: resData.thread_id,\n                    }\n                },\n                source: this.serviceName,\n            };\n        });\n    }\n\n    /**\n     * get the service name, as required by the framework\n     */\n    get serviceName(): string {\n        return FlowdockService._serviceName;\n    }\n\n    // Retrieve the API handle for Flowdock.\n    get apiHandle(): FlowdockHandle {\n        return {\n            flowdock: FlowdockService.session\n        };\n    }\n}\n\n/**\n * Return this class activated and typed as a listener\n */\nexport function createServiceListener(): ServiceListener {\n    return new FlowdockService(true);\n}\n\n/**\n * Return this class typed as an emitter\n */\nexport function createServiceEmitter(): ServiceEmitter {\n    return new FlowdockService(false);\n}\n\n/**\n * Return this class typed as a messenger\n */\nexport function createMessageService(): MessageService {\n    return new FlowdockService(false);\n}\n"],"sourceRoot":"../../lib"}