{"version":3,"sources":["services/service-scaffold.ts"],"names":[],"mappings":"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","file":"service-scaffold.js","sourcesContent":["/*\n Copyright 2016-2017 Resin.io\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n/* tslint:disable: max-classes-per-file */\n\nimport TypedError = require('typed-error');\nimport * as Promise from 'bluebird';\nimport * as bodyParser from 'body-parser';\nimport * as express from 'express';\nimport { RequestHandler } from 'express';\nimport * as _ from 'lodash';\nimport { Worker } from '../framework/worker';\nimport { WorkerClient } from '../framework/worker-client';\nimport { Logger, LogLevel } from '../utils/logger';\nimport {\n\tServiceScaffoldConstructor,\n\tServiceScaffoldErrorCode, ServiceScaffoldEvent, ServiceScaffoldWorkerEvent\n} from './service-scaffold-types';\nimport {\n\tServiceAPIHandle, ServiceEmitContext, ServiceEmitRequest, ServiceEmitResponse,\n\tServiceEmitter, ServiceListener, ServiceRegistration,\n} from './service-types';\n\n/**\n * A TypedError that encapsulates the subtype of the error and message provided.\n */\nexport class ServiceScaffoldError extends TypedError {\n\t/** What category of thing went wrong. */\n\tpublic code: ServiceScaffoldErrorCode;\n\n\t/**\n\t * @param code     Sub-type of the error.\n\t * @param message  The error message, is stored in the standard location.\n\t */\n\tconstructor(code: ServiceScaffoldErrorCode, message: string) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t}\n}\n\n/**\n * A scaffold class to handle a bunch of the repetitive work associated with being a ServiceListener and ServiceEmitter\n *\n * This class provides:\n * - An express app, if asked for.\n * - A logger.\n * - An event registration and handling standard.\n * - Checks for and extracts data from context.\n * - A standard way of getting contextualised workers.\n *\n * Any inheriting child must:\n * - Provide a `emitData` method which takes a ServiceEmitContext and returns a promise.\n * - Provide a `verify` function which should check that incoming data isn't spoofed.\n * - Provide a `serviceName` getter, which because it is based on file path cannot be inherited away.\n * - Provide a `apiHandle` getter, which should return the underlying object that executes the requests.\n * - Enqueue events with `context` and `event`, as per `ServiceScaffoldEvent`.\n */\nexport abstract class ServiceScaffold<T> extends WorkerClient<T> implements ServiceListener, ServiceEmitter {\n\t/** Endpoint listener that may be used to, for example, receive web hooks. */\n\tprotected expressApp?: express.Express;\n\n\t/** A place to put output for debug and reference. */\n\tprivate loggerInstance = new Logger();\n\n\t/** Store a list of actions to perform when particular actions happen */\n\tprivate eventListeners: { [event: string]: ServiceRegistration[] } = {};\n\n\t// https://github.com/resin-io-modules/resin-procbots/issues/262\n\tconstructor(data: ServiceScaffoldConstructor) {\n\t\tsuper();\n\t\tif (typeof data.server === 'number') {\n\t\t\t// Construction details provided a port number, so use that.\n\t\t\tconst port = data.server;\n\t\t\tthis.expressApp = express();\n\t\t\tthis.expressApp.use(bodyParser.json());\n\t\t\tthis.expressApp.listen(port);\n\t\t\tthis.logger.log(LogLevel.INFO, `---> Created Express app on provided port ${port} for '${this.serviceName}'.`);\n\t\t} else if (data.server) {\n\t\t\t// Construction details provided an express.Express (only value left that's truthy), so use it.\n\t\t\tthis.expressApp = data.server;\n\t\t\tthis.logger.log(LogLevel.INFO, `---> Using provided Express app for '${this.serviceName}'.`);\n\t\t}\n\t}\n\n\t/**\n\t * Store an event of interest, so that the method gets triggered appropriately.\n\t * @param registration  Registration object with event trigger and other details.\n\t */\n\tpublic registerEvent(registration: ServiceRegistration): void {\n\t\t// Store each event registration in an object of arrays.\n\t\tfor (const event of registration.events) {\n\t\t\tif (!this.eventListeners[event]) {\n\t\t\t\tthis.eventListeners[event] = [];\n\t\t\t}\n\t\t\tthis.eventListeners[event].push(registration);\n\t\t}\n\t}\n\n\t/**\n\t * Emit data to the service.\n\t * @param data  Service Emit Request to send, if relevant.\n\t * @returns     Details of the successful transmission from the service.\n\t */\n\tpublic sendData(data: ServiceEmitRequest): Promise<ServiceEmitResponse> {\n\t\t// Check that the payload being emitted is relevant to this emitter.\n\t\tconst context = data.contexts[this.serviceName];\n\t\tif (!context) {\n\t\t\treturn Promise.resolve({\n\t\t\t\terr: new ServiceScaffoldError(ServiceScaffoldErrorCode.ContextAbsent, `No ${this.serviceName} context`),\n\t\t\t\tsource: this.serviceName,\n\t\t\t});\n\t\t}\n\n\t\t// Emit the payload, massaging the Promise style result into a ProcBot style result.\n\t\treturn this.emitData(context)\n\t\t.then((response: any) => {\n\t\t\treturn {\n\t\t\t\tresponse,\n\t\t\t\tsource: this.serviceName,\n\t\t\t};\n\t\t})\n\t\t.catch((err: TypedError) => {\n\t\t\treturn {\n\t\t\t\terr,\n\t\t\t\tsource: this.serviceName,\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Verify and enqueue an event ready for passing to a child's registered listeners.\n\t * @param data  The WorkerEvent to add to the queue for processing.\n\t */\n\tprotected queueData = (data: ServiceScaffoldEvent) => {\n\t\t// Check that the event passes verification\n\t\tif (this.verify(data)) {\n\t\t\t// Enqueue the event\n\t\t\tsuper.queueEvent({\n\t\t\t\tdata,\n\t\t\t\t// Delivering it to registered listener methods\n\t\t\t\tworkerMethod: this.handleEvent\n\t\t\t});\n\t\t} else {\n\t\t\t// Since the data failed verification, it could be anything, so our most useful debug is a simple dump.\n\t\t\tthis.logger.log(LogLevel.WARN, `Event failed verification.\\n${JSON.stringify(data)}`);\n\t\t}\n\t}\n\n\t/**\n\t * Emit a payload to the endpoint defined, resolving when done.\n\t * @param data   details of the call and associated data\n\t * @returns      A promise that resolves to the response\n\t */\n\tprotected abstract emitData(data: ServiceEmitContext): Promise<any>;\n\n\t/**\n\t * Verify the event before enqueueing.  A naive approach could be to simply return true, but that must be explicit.\n\t * @param data  The data object that was enqueued.\n\t */\n\tprotected abstract verify(data: ServiceScaffoldEvent): boolean\n\n\t/**\n\t * Get a Worker object for the provided event, threaded by context.\n\t * @param event  Event as enqueued by the listener.\n\t * @returns      Worker for the context associated.\n\t */\n\tprotected getWorker = (event: ServiceScaffoldWorkerEvent): Worker<T> => {\n\t\t// Attempt to retrieve an active worker for the context\n\t\tconst context = event.data.context;\n\t\tconst retrieved = this.workers.get(context);\n\t\tif (retrieved) {\n\t\t\treturn retrieved;\n\t\t}\n\t\t// Create and store a worker for the context\n\t\tconst created = new Worker<T>(context, this.removeWorker);\n\t\tthis.workers.set(context, created);\n\t\treturn created;\n\t}\n\n\t/**\n\t * Register a handler for a particular path with our express instance.\n\t * @param path     Path to register for.\n\t * @param handler  Method to invoke when the path is requested.\n\t */\n\tprotected registerHandler(path: string, handler: RequestHandler): void {\n\t\tif (this.expressApp) {\n\t\t\tthis.expressApp.post(`/${path}/`, handler);\n\t\t} else {\n\t\t\tthrow new ServiceScaffoldError(\n\t\t\t\tServiceScaffoldErrorCode.NoExpressServer,\n\t\t\t\t'Attempted to register a handler, but no express app configured.'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the logger, here to write-protect it\n\t * @returns  Logger instance for this class\n\t */\n\tprotected get logger(): Logger {\n\t\treturn this.loggerInstance;\n\t}\n\n\t/**\n\t * Retrieve a list of the event names being listened to\n\t * @returns  list of event names\n\t */\n\tprotected get eventsRegistered(): string[] {\n\t\treturn _.keys(this.eventListeners);\n\t}\n\n\t/**\n\t * Pass an event to registered listenerMethods.\n\t * @param data  Enqueued data from the listener.\n\t * @returns     Promise that resolves once the event is handled.\n\t */\n\tprotected handleEvent = (data: ServiceScaffoldEvent): Promise<void> => {\n\t\t// Retrieve and execute all the listener methods, squashing their responses\n\t\tconst listeners: ServiceRegistration[] = _.get(this.eventListeners, data.type, []);\n\t\treturn Promise.map(listeners, (listener) => {\n\t\t\treturn listener.listenerMethod(listener, data)\n\t\t\t.catch((error: Error) =>\n\t\t\t\tthis.logger.alert(LogLevel.WARN, `Error thrown in handler queue processing:${error}`)\n\t\t\t);\n\t\t}).return();\n\t}\n\n\t/**\n\t * Get the service name, as required by the framework.\n\t * @return  Name of the service.\n\t */\n\tabstract get serviceName(): string\n\n\t/**\n\t * Retrieve the SDK API instance handle for the service, should one exist.\n\t * @return  Service SDK API handle or void.\n\t */\n\tabstract get apiHandle(): ServiceAPIHandle | void;\n}\n"],"sourceRoot":"../../lib"}