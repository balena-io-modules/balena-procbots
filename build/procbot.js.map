{"version":3,"sources":["procbot.ts"],"names":[],"mappings":"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","file":"procbot.js","sourcesContent":["/*\nCopyright 2016 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// The ProcBot class is the parent of all Procbots.\n// It currently includes the following functionality:\n//  * Logging (with DEBUG, INFO, WARN levels)\n//  * Alerting (with ERROR, CRITICAL levels)\n//\n// It is intended as a generic class for all functionality that is required\n// by child bots.\nimport * as Promise from 'bluebird';\nimport * as _ from 'lodash';\n\n// A note on coding style here.\n// Exported enums and types are considered as a similar pattern to static types in\n// C++. That is, we can import a module using `import * as ProcBot from `./procbot'` and\n// then reference the enums/types as if these were static, eg. `thing = ProcBot.LogLevel.WARN`\n// The advantage with this is it's obvious where it comes from.\n// Ideally, we'd have enums protected in the class, but we don't appear to be able to do that\n// in TS.\n\n// Worker ----------------------------------------------------------------------------------\n\n// Standard worker method type that all other bots must implement.\nexport type WorkerMethod = <T>(event: string, data: T) => Promise<void>;\n\n// The RepoQueue is important. It's entirely possible we'll receive\n// payloads for the same repository in a space of time that makes\n// servicing them all before receiving the payload for the next\n// impossible. So, we queue them.\n// When fireEvent is called, it looks at the repository that\n// was acted upon and adds it to the relevant queue. It then\n// schedules the worker task to go through the queues until\n// they're exhausted.\n// A separate worker task exists for each repo queue and dies\n// upon exit.\n\n// An entry in a queue used to schedule the next worker and\n// the data to work upon, for a specific repo.\ninterface QueueEntry {\n    worker: WorkerMethod;\n    event: string;\n    data: any;\n};\n\n// An event passed from an extended Bot, detailing the event it\n// wished to work due to, the data to work on and the method to use.\nexport interface BotEvent {\n    event: string,\n    data: any,\n    workerMethod: WorkerMethod\n};\n\n// WorkerMap type.\ntype WorkerMap<T> = Map<T, Worker<T>>;\n\n// The worker class is created for each unique repo that is seen.\n// This ensures that multiple repos can be operated on in parallel,\n// but operations only occur in series for each unique repo.\nexport class Worker<T> {\n    private _context: T;\n    private parentMap: WorkerMap<T>;\n    private queue: QueueEntry[] = [];\n\n    constructor(context: T, parentMap: WorkerMap<T>) {\n        this._context = context;\n        this.parentMap = parentMap;\n    }\n\n    get context(): T {\n        return this._context;\n    }\n\n    // Add a new event and worker method to the queue for this repo.\n    addEvent(event: string, data: string, worker: WorkerMethod): void {\n        this.queue.push({ event, data, worker });\n        // If this is a new worker, ensure it operates.\n        if (this.queue.length === 1) {\n            this.runWorker();\n        }\n    }\n\n    // Run as many workers as are queued. Do this atomically, in FIFO order.\n    private runWorker(): void {\n        // Get the next thing from the queue.\n        const entry = <QueueEntry>this.queue.shift();\n        const self: this = this;\n\n        // Run worker, proceed to next worker.\n        entry.worker(entry.event, entry.data)\n        .then(() => {\n            if (this.queue.length > 0) {\n                process.nextTick(this.runWorker);\n            } else {\n                // Unlink ourselves from our parent list.\n                self.parentMap.delete(self.context);\n            }\n        });\n    }\n}\n\n// ProcBot ----------------------------------------------------------------------------------\n\n// Logging levels are stacked, with a chosen logging level also triggering all\n// levels below it; choosing a logging level of DEBUG will cause all DEBUG,\n// INFO & WARN levels to be output, choosing a logging level of WARN will only cause\n// WARN levels to be output.\n// They are arranged this way to allow additional items to be added if required.\nexport enum LogLevel {\n    WARN = 0,\n    INFO,\n    DEBUG\n};\n\n// Alerting levels are stacked, with a chosen alerting level also triggering all\n// levels below it; choosing an alerting level of ERROR will cause both\n// ERROR & CRITICAL output to be sent to the alert system; choosing CRITICAL will only\n// output CRITICAL errors to the alert system.\n// They are arranged this way to allow additional items to be added if required.\nexport enum AlertLevel {\n    CRITICAL = 0,\n    ERROR\n};\n\n\nexport class ProcBot<T> {\n    // Defaults.\n    // Log and Alert levels are taken from an envvar or set to the minimum.\n    // These can be overriden by specific methods.\n    protected _botname = 'Procbot';\n    protected _logLevel = process.env.PROCBOT_LOG_LEVEL | LogLevel.WARN;\n    protected _alertLevel = process.env.PROCBOT_ALERT_LEVEL | AlertLevel.CRITICAL;\n    protected workers: WorkerMap<T> = new Map<T, Worker<T>>();\n\n    // This generic method must be implemented in children extended from a ProcBot.\n    // It defines the context type used for Workers.\n    protected getWorker: (event: BotEvent) => Worker<T>;\n\n    private logLevelStrings = [\n        'WARNING',\n        'INFO',\n        'DEBUG'\n    ];\n\n    private alertLevelStrings = [\n        'CRITICAL',\n        'ERROR'\n    ];\n\n    // Dummy constructor ATM.\n    constructor() {\n        // Nada.\n    }\n\n    // Get the name of the bot.\n    protected get botname() {\n        return this._botname;\n    }\n\n    // Get the log level.\n    protected get logLevel() {\n        return this._logLevel;\n    }\n\n    // Set logLevel\n    protected set logLevel(level: number) {\n        this._logLevel = level;\n    }\n\n    // Get alert level.\n    protected get alertLevel() {\n        return this._alertLevel;\n    }\n\n    // Set logLevel\n    protected set alertLevel(level: number) {\n        this._alertLevel = level;\n    }\n\n    // Generic output method for either type.\n    // FIXME: Alter this to output to the correct service.\n    private output(level: number, classLevel: number, levelStrings: Array<string>, message: string) {\n        if (level >= classLevel) {\n            console.log(`${levelStrings[level]} - ${message}`);\n        }\n    }\n\n    // Log output.\n    protected log(level: number, message: string): void {\n        this.output(level, this._logLevel, this.logLevelStrings, message);\n    }\n\n    // Alert output.\n    protected alert(level: number, message: string): void {\n        this.output(level, this._alertLevel, this.alertLevelStrings, message);\n    }\n\n\n    // Queue an event ready for running in a child.\n    protected queueEvent(event: BotEvent): void {\n        let entry: Worker<T> | undefined;\n\n        if (!event.workerMethod) {\n            console.log(`WorkerMethod must be passed into the Githubbot.firedEvent() method`);\n            return;\n        }\n\n        // Look at the repo. If there's no repo, we can't actually do anything with this.\n        if (!event.data) {\n            console.log('Could not find a payload for the event');\n            return;\n        }\n\n        // Retrieve any worker with a matching context, or create a new one.\n        // Bot implementation specific.\n        entry = this.getWorker(event);\n\n        // Now add the event to the found/created repo worker.\n        entry.addEvent(event.event, event.data, event.workerMethod);\n\n        return;\n    }\n}"],"sourceRoot":"../lib"}