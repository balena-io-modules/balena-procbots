{"version":3,"sources":["translators/flowdock.ts"],"names":[],"mappings":";;AAiBA,uCAAmC;AAGnC,6CAAiD;AAGjD,wBAAgC,SAAQ,8BAAiB;IAIxD,YAAY,IAA+B;QAC1C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,IAAI,kBAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC;IAC9B,CAAC;IAEM,eAAe,CAAC,KAAoB;QAC1C,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC5C,CAAC;IAEM,eAAe,CAAC,QAAyB;QAC/C,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC5C,CAAC;IAEM,eAAe,CAAC,UAAkB;QACxC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC5C,CAAC;CACD;AArBD,gDAqBC;AAED,0BAAiC,IAA+B;IAC/D,MAAM,CAAC,IAAI,kBAAkB,CAAC,IAAI,CAAC,CAAC;AACrC,CAAC;AAFD,4CAEC","file":"flowdock.js","sourcesContent":["/*\nCopyright 2016-2017 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as Promise from 'bluebird';\nimport { Session } from 'flowdock';\nimport { FlowdockConnectionDetails, FlowdockEmitContext, FlowdockEvent } from '../services/flowdock-types';\nimport { MessageContext, TransmitContext } from '../services/messenger-types';\nimport { MessageTranslator } from './translator';\n\n// TODO: Implement\nexport class FlowdockTranslator extends MessageTranslator {\n\tprivate session: Session;\n\tprivate org: string;\n\n\tconstructor(data: FlowdockConnectionDetails) {\n\t\tsuper();\n\t\tthis.session = new Session(data.token);\n\t\tthis.org = data.organization;\n\t}\n\n\tpublic dataIntoMessage(_data: FlowdockEvent): Promise<MessageContext> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tpublic messageIntoEmit(_message: TransmitContext): Promise<FlowdockEmitContext> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tpublic eventIntoEvents(_eventName: string): string[] {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport function createTranslator(data: FlowdockConnectionDetails): MessageTranslator {\n\treturn new FlowdockTranslator(data);\n}\n\n// export class FlowdockService extends Messenger implements ServiceEmitter, ServiceListener, DataHub {\n// \tprivate static _serviceName = path.basename(__filename.split('.')[0]);\n// \tprivate session: Session;\n// \tprivate data: FlowdockConstructor;\n//\n// \tpublic constructor(data: FlowdockConstructor, listen = true ) {\n// \t\tsuper(listen);\n// \t\tthis.data = data;\n// \t\tthis.session = new Session(data.token);\n// \t}\n//\n// \t/**\n// \t * Promise to turn the data enqueued into a generic message format.\n// \t * @param data  Raw data from the enqueue, remembering this is as dumb and quick as possible.\n// \t * @returns     A promise that resolves to the generic form of the event.\n// \t */\n// \tpublic makeGeneric = (data: MessengerEvent): Promise<ReceiptContext> => {\n// \t\treturn new Promise<ReceiptContext>((resolve) => {\n// \t\t\t// Separate out some parts of the message\n// \t\t\tconst metadata = Messenger.extractMetadata(data.rawEvent.content);\n// \t\t\tconst titleAndText = metadata.content.match(/^(.*)\\n--\\n((?:\\r|\\n|.)*)$/);\n// \t\t\tconst flow = data.cookedEvent.flow;\n// \t\t\tconst thread = data.rawEvent.thread_id;\n// \t\t\tconst userId = data.rawEvent.user;\n// \t\t\tconst org = this.data.organization;\n// \t\t\tconst returnValue = {\n// \t\t\t\taction: MessengerAction.Create,\n// \t\t\t\tfirst: data.rawEvent.id === data.rawEvent.thread.initial_message,\n// \t\t\t\tgenesis: metadata.genesis || data.source,\n// \t\t\t\thidden: metadata.hidden,\n// \t\t\t\tsource: data.source,\n// \t\t\t\tsourceIds: {\n// \t\t\t\t\tmessage: data.rawEvent.id,\n// \t\t\t\t\tflow,\n// \t\t\t\t\tthread,\n// \t\t\t\t\turl: `https://www.flowdock.com/app/${org}/${flow}/threads/${thread}`,\n// \t\t\t\t\tuser: 'duff', // gets replaced\n// \t\t\t\t},\n// \t\t\t\ttext: titleAndText ? titleAndText[2] : metadata.content,\n// \t\t\t\ttitle: titleAndText ? titleAndText[1] : undefined,\n// \t\t\t};\n// \t\t\t// If the data provided a username\n// \t\t\tif (data.rawEvent.external_user_name) {\n// \t\t\t\treturnValue.sourceIds.user = data.rawEvent.external_user_name;\n// \t\t\t\tresolve(returnValue);\n// \t\t\t} else {\n// \t\t\t\tthis.fetchFromSession(`/organizations/${org}/users/${userId}`)\n// \t\t\t\t.then((user) => {\n// \t\t\t\t\treturnValue.sourceIds.user = user.nick;\n// \t\t\t\t\tresolve(returnValue);\n// \t\t\t\t});\n// \t\t\t}\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Promise to turn the generic message format into a specific form to be emitted.\n// \t * @param data  Generic message format object to be encoded.\n// \t * @returns     Promise that resolves to the emit suitable form.\n// \t */\n// \tpublic makeSpecific = (data: TransmitContext): Promise<FlowdockEmitContext> => {\n// \t\t// Build a string for the title, if appropriate.\n// \t\tconst titleText = data.first && data.title ? data.title + '\\n--\\n' : '';\n// \t\tconst org = this.data.organization;\n// \t\tconst flow = data.toIds.flow;\n// \t\treturn new Promise<FlowdockEmitContext>((resolve) => {\n// \t\t\tresolve({\n// \t\t\t\tendpoint: {\n// \t\t\t\t\ttoken: data.toIds.token,\n// \t\t\t\t\turl: `https://api.flowdock.com/flows/${org}/${flow}/messages/`,\n// \t\t\t\t},\n// \t\t\t\tmeta: {\n// \t\t\t\t\tflow,\n// \t\t\t\t\torg,\n// \t\t\t\t},\n// \t\t\t\tpayload: {\n// \t\t\t\t\t// The concatenated string, of various data nuggets, to emit\n// \t\t\t\t\tcontent: titleText + data.text + '\\n' + Messenger.stringifyMetadata(data),\n// \t\t\t\t\tevent: 'message',\n// \t\t\t\t\texternal_user_name:\n// \t\t\t\t\t// If this is using the generic token, then they must be an external user, so indicate this\n// \t\t\t\t\t\tdata.toIds.token === this.data.token ? data.toIds.user.substring(0, 16) : undefined,\n// \t\t\t\t\tthread_id: data.toIds.thread,\n// \t\t\t\t},\n// \t\t\t});\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Turns the generic, messenger, name for an event into a specific trigger name for this class.\n// \t * @param eventType  Name of the event to translate, eg 'message'.\n// \t * @returns          This class's equivalent, eg 'post'.\n// \t */\n// \tpublic translateEventName(eventType: string): string {\n// \t\tconst equivalents: {[key: string]: string} = {\n// \t\t\tmessage: 'message',\n// \t\t};\n// \t\treturn equivalents[eventType];\n// \t}\n//\n// \t/**\n// \t * Promise to find the comment history of a particular thread.\n// \t * @param thread  id of the thread to search.\n// \t * @param room    id of the room in which the thread resides.\n// \t * @param filter  Criteria to match.\n// \t * @param search  Optional, some words which may be used to shortlist the results.\n// \t */\n// \tpublic fetchNotes = (thread: string, room: string, filter: RegExp, search?: string): Promise<string[]> => {\n// \t\t// Query the API\n// \t\tconst org = this.data.organization;\n// \t\treturn this.fetchFromSession(`/flows/${org}/${room}/threads/${thread}/messages`, search)\n// \t\t.then((messages) => {\n// \t\t\treturn _.map(messages, (value: FlowdockMessage) => {\n// \t\t\t\t// Clean the response to just the content\n// \t\t\t\treturn value.content;\n// \t\t\t}).filter((value: string) => {\n// \t\t\t\t// Filter the response to just matches\n// \t\t\t\tconst match = value.match(filter);\n// \t\t\t\treturn (match !== null) && (match.length > 0);\n// \t\t\t});\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Search for the specified value associated with a user.\n// \t * @param user  Username to search associated with.\n// \t * @param key   Name of the value to retrieve.\n// \t * @returns     Promise that resolves to the value.\n// \t */\n// \tpublic fetchValue(user: string, key: string): Promise<string> {\n// \t\t// Retrieve a particular regex from the 1-1 message history of the user\n// \t\tconst findKey = new RegExp(`My ${key} is (\\\\S+)`, 'i');\n// \t\treturn this.fetchPrivateMessages(user, findKey).then((valueArray) => {\n// \t\t\tconst value = valueArray[valueArray.length - 1].match(findKey);\n// \t\t\tif (value) {\n// \t\t\t\treturn value[1];\n// \t\t\t}\n// \t\t\tthrow new Error(`Could not find value $key for $user`);\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Activate this service as a listener.\n// \t */\n// \tprotected activateMessageListener = (): void => {\n// \t\t// Get a list of known flows from the session\n// \t\tthis.session.flows((error: any, flows: any) => {\n// \t\t\tif (error) {\n// \t\t\t\tthrow error;\n// \t\t\t}\n// \t\t\t// Store the names and stream retrieved flows\n// \t\t\tconst flowIdToFlowName: {[key: string]: string} = {};\n// \t\t\tfor (const flow of flows) {\n// \t\t\t\tflowIdToFlowName[flow.id] = flow.parameterized_name;\n// \t\t\t}\n// \t\t\tconst stream = this.session.stream(Object.keys(flowIdToFlowName));\n// \t\t\t// Listen to messages and check they are messages\n// \t\t\tstream.on('message', (message: any) => {\n// \t\t\t\tif (message.event === 'message') {\n// \t\t\t\t\t// Enqueue new message events\n// \t\t\t\t\tthis.queueEvent({\n// \t\t\t\t\t\tdata: {\n// \t\t\t\t\t\t\tcookedEvent: {\n// \t\t\t\t\t\t\t\tcontext: message.thread_id,\n// \t\t\t\t\t\t\t\tflow: flowIdToFlowName[message.flow],\n// \t\t\t\t\t\t\t\ttype: message.event,\n// \t\t\t\t\t\t\t},\n// \t\t\t\t\t\t\trawEvent: message,\n// \t\t\t\t\t\t\tsource: FlowdockService._serviceName,\n// \t\t\t\t\t\t},\n// \t\t\t\t\t\tworkerMethod: this.handleEvent,\n// \t\t\t\t\t});\n// \t\t\t\t}\n// \t\t\t});\n// \t\t});\n// \t\t// Create a keep-alive endpoint for contexts that sleep between web requests\n// \t\tMessenger.app.get(`/${FlowdockService._serviceName}/`, (_formData, response) => {\n// \t\t\tresponse.sendStatus(200);\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Deliver the payload to the service. Sourcing the relevant context has already been performed.\n// \t * @param data  The object to be delivered to the service.\n// \t * @returns     Response from the service endpoint.\n// \t */\n// \tprotected sendPayload = (data: FlowdockEmitContext): Promise<MessengerEmitResponse> => {\n// \t\t// Extract a couple of details from the environment\n// \t\tconst token = new Buffer(data.endpoint.token).toString('base64');\n// \t\t// Post to the API\n// \t\tconst requestOpts = {\n// \t\t\tbody: data.payload,\n// \t\t\theaders: {\n// \t\t\t\t'Authorization': `Basic ${token}`,\n// \t\t\t\t'X-flowdock-wait-for-message': true,\n// \t\t\t},\n// \t\t\tjson: true,\n// \t\t\turl: data.endpoint.url,\n// \t\t};\n// \t\treturn request.post(requestOpts).then((resData: any) => {\n// \t\t\t// Massage the response into a suitable form for the framework\n// \t\t\tconst thread = resData.thread_id;\n// \t\t\tconst org = data.meta ? data.meta.org : '';\n// \t\t\tconst flow = data.meta ? data.meta.flow : '';\n// \t\t\tconst url = data.meta ? `https://www.flowdock.com/app/${org}/${flow}/threads/${thread}` : undefined;\n// \t\t\treturn {\n// \t\t\t\tresponse: {\n// \t\t\t\t\tmessage: resData.id,\n// \t\t\t\t\tthread: resData.thread_id,\n// \t\t\t\t\turl,\n// \t\t\t\t},\n// \t\t\t\tsource: FlowdockService._serviceName,\n// \t\t\t};\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Search for recent private messages with our account that match on username and regex.\n// \t * @param username  Scope of the private messages to search.\n// \t * @param filter    Narrow our search to just matches.\n// \t * @returns         Promise that resolves to the message strings.\n// \t */\n// \tprivate fetchPrivateMessages(username: string, filter: RegExp): Promise<string[]> {\n// \t\t// Fetch the id then 1-1 history associated with the username\n// \t\treturn this.fetchUserId(username)\n// \t\t.then((userId) => {\n// \t\t\treturn this.fetchFromSession(`/private/${userId}/messages`)\n// \t\t\t.then((fetchedMessages) => {\n// \t\t\t\t// Prune and clean the message history to text of interest\n// \t\t\t\treturn _.filter(fetchedMessages, (message: FlowdockMessage) => {\n// \t\t\t\t\treturn filter.test(message.content);\n// \t\t\t\t}).map((message: FlowdockMessage) => {\n// \t\t\t\t\treturn message.content;\n// \t\t\t\t});\n// \t\t\t});\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Fetch a user's id from their username.\n// \t * @param username  Username to search for.\n// \t * @returns         id of the user.\n// \t */\n// \tprivate fetchUserId = (username: string): Promise<string | undefined> => {\n// \t\t// Get all the users of the service\n// \t\treturn this.fetchFromSession(`/organizations/${this.data.organization}/users`)\n// \t\t.then((foundUsers) => {\n// \t\t\t// Generate an array of user objects with matching username\n// \t\t\tconst matchingUsers = _.filter(foundUsers, (eachUser: any) => {\n// \t\t\t\treturn eachUser.nick === username;\n// \t\t\t});\n// \t\t\t// Return id if we've exactly one user for a particular username\n// \t\t\tif (matchingUsers.length === 1) {\n// \t\t\t\treturn(matchingUsers[0].id);\n// \t\t\t}\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Utility function to structure the flowdock session as a promise a little.\n// \t * @param path    Endpoint to retrieve.\n// \t * @param search  Optional, some words which may be used to shortlist the results.\n// \t * @returns       Response from the session.\n// \t */\n// \tprivate fetchFromSession = (path: string, search?: string): Promise<any> => {\n// \t\treturn new Promise<any>((resolve, reject) => {\n// \t\t\t// The flowdock service both emits and calls back the error.\n// \t\t\t// We're wrapping the emit in a promise reject and ignoring the call back\n// \t\t\tthis.session.on('error', reject);\n// \t\t\tthis.session.get(path, {search}, (_error?: Error, result?: any) => {\n// \t\t\t\tthis.session.removeListener('error', reject);\n// \t\t\t\tif (result) {\n// \t\t\t\t\tresolve(result);\n// \t\t\t\t}\n// \t\t\t});\n// \t\t});\n// \t}\n//\n// \t/**\n// \t * Get the service name, as required by the framework.\n// \t * @returns  The specific service name for Flowdock.\n// \t */\n// \tget serviceName(): string {\n// \t\treturn FlowdockService._serviceName;\n// \t}\n//\n// \t/**\n// \t * Retrieve the SDK API handle for Flowdock.\n// \t * @returns  The Flowdock SDK API handle.\n// \t */\n// \tget apiHandle(): FlowdockHandle {\n// \t\treturn {\n// \t\t\tflowdock: this.session\n// \t\t};\n// \t}\n// }\n//\n// /**\n//  * Build this class, typed and activated as a listener.\n//  * @returns  Service Listener object, awakened and ready to go.\n//  */\n// export function createServiceListener(data: FlowdockConstructor): ServiceListener {\n// \treturn new FlowdockService(data, true);\n// }\n//\n// /**\n//  * Build this class, typed as an emitter.\n//  * @returns  Service Emitter object, ready for your events.\n//  */\n// export function createServiceEmitter(data: FlowdockConstructor): ServiceEmitter {\n// \treturn new FlowdockService(data, false);\n// }\n//\n// /**\n//  * Build this class, typed as a message service.\n//  * @returns  Message Service object, ready to convert events.\n//  */\n// export function createMessageService(data: FlowdockConstructor): Messenger {\n// \treturn new FlowdockService(data, false);\n// }\n//\n// /**\n//  * Build this class, typed as a data hub.\n//  * @returns  Data Hub object, ready to retrieve user data.\n//  */\n// export function createDataHub(data: FlowdockConstructor): DataHub {\n// \treturn new FlowdockService(data, false);\n// }\n"],"sourceRoot":"../../lib"}