{"version":3,"sources":["bots/geckobot.ts"],"names":[],"mappings":"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","file":"geckobot.js","sourcesContent":["/*\nCopyright 2016 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// GECKOBOT listens for merges of a PR to the `master` branch and then\n// updates any packages for it.\nimport * as Promise from 'bluebird';\nimport * as _ from 'lodash';\nimport * as request from 'request-promise';\nimport * as GithubBotApiTypes from './githubapi-types';\nimport * as GithubBot from './githubbot';\nimport { GithubAction, GithubActionRegister } from './githubbot-types';\nimport * as ProcBot from './procbot';\nconst GeckoBoard = require('geckoboard');\n\ninterface GeckoBotError {\n    brief: string;\n    message: string;\n}\n\ninterface AvailableRepo {\n    name: string;\n    owner: {\n        login: string;\n    }\n}\n\ninterface RepoArray {\n    repositories: AvailableRepo[];\n}\n\ninterface OpenPREntry {\n    name: string;\n    openprs: number;\n    attime: string;\n}\n\ninterface RepoTracker {\n    name: string;\n    openprs: number;\n}\n\n// How this works:\n// * On startup, we retrieve the details of every single repo we have access to.\n//   We then ask how many open PRs each of those repos has.\n//   We build a dataset at that point for the datetime.\n//   We send it to Geckoboard\n// * Whenever a new open/close PR event comes in, we clone the previous data set and then\n//   look for the repo in it:\n//     - If we don't find it:\n//          * We create a new entry (on an open)\n//          * We ignore it on a close (shouldn't happen)\n//     - If we do find it:\n//          * We increment number of PRs on an open\n//          * We decrement number of PRs on a close (we do *not* delete, however, as this would\n//            ruin the dataset).\nexport class GeckoBot extends GithubBot.GithubBot {\n    private dataset: OpenPREntry[] = [];\n    private allRepos: RepoTracker[] = [];\n    private geckoBoard: any;\n\n    // Name ourself and register the events and labels we're interested in.\n    constructor(integration: number, name?: string) {\n        // This is the GECKOBOT.\n        super(integration, name);\n\n\n        // Set login for Geckoboard\n        this.geckoBoard = Promise.promisifyAll(GeckoBoard(process.env.GECKOBOT_GECKO_KEY).datasets);\n\n        // Get the initial set of repos and their PRs. We have to do this via an HTTPS request as\n        // currently there's no API call for it.\n                // Authenticate the Github API.\n        this.authenticate().then(() => {\n            // Scrub any previous data set entries.\n            return this.geckoBoard.deleteAsync('pullrequests');\n        }).then(() => {\n            const availableRepos: any = {\n                headers: {\n                    'Accept': 'application/vnd.github.machine-man-preview+json',\n                    'Authorization': `token ${this.authToken}`,\n                    'User-Agent': 'request'\n                },\n                json: true,\n                method: 'GET',\n                url: `https://api.github.com/installation/repositories?access_token=${this.authToken}`\n            };\n            return request.get(availableRepos);\n        }).then((repos: RepoArray) => {\n            return Promise.map(repos.repositories, (repo: AvailableRepo) => {\n                return this.getOpenPRsForRepo(repo.owner.login, repo.name);\n            })\n        }).then((openPRs: OpenPREntry[]) => {\n            // Push a new key for each repo we know about.\n            _.each(openPRs, (openPR) => {\n                this.allRepos.push({\n                    name: openPR.name,\n                    openprs: openPR.openprs\n                });\n            });\n            this.newEntriesFromRepos();\n\n            // We have all our data points and some keys, push the dataset to Geckoboard.\n            return this.postDataToGeckoboard();\n        }).then(() => {\n            // Now we register for events.\n            _.forEach([\n                {\n                    events: [ 'pull_request' ],\n                    name: 'DeterminePRState',\n                    workerMethod: this.updatePR\n                }\n            ], (reg: GithubActionRegister) => {\n                this.registerAction(reg);\n            });\n        });\n    }\n\n\n    protected updatePR = (action: GithubAction, data: GithubBotApiTypes.PullRequestEvent): Promise<void> => {\n        const head = data.pull_request.head;\n        const owner = head.repo.owner.login;\n        const name = head.repo.name;\n        let updateGeckoboard = false;\n        action = action;\n\n        // Try and find an entry for the repo.\n        let foundEntry;\n        for (let index = 0; index < this.allRepos.length; index += 1) {\n            const entry = this.allRepos[index];\n\n            if (entry.name === `${name}`) {\n                foundEntry = entry;\n                break;\n            }\n        }\n\n        // Depending on what type of action this is, we do several things:\n        switch (data.action) {\n            case 'opened':\n            case 'reopened':\n                // Did we find a previous entry?\n                if (foundEntry) {\n                    foundEntry.openprs += 1;\n                } else {\n                    foundEntry = {\n                        name: `${name}`,\n                        openprs: 1\n                    }\n                    this.allRepos.push(foundEntry);\n                }\n\n                this.newEntriesFromRepos();\n                updateGeckoboard = true;\n                this.log(ProcBot.LogLevel.INFO, `Incremented count for ${owner}/${name}@${new Date().toISOString()}`);\n                break;\n\n            case 'closed':\n                if (foundEntry) {\n                    foundEntry.openprs -= 1;\n\n                    // Create new data entry.\n                    this.newEntriesFromRepos();\n                    updateGeckoboard = true;\n                    this.log(ProcBot.LogLevel.INFO, `Decremented count for ${owner}/${name}@${new Date().toISOString()}`);\n                } else {\n                    // Else we just ignore it, we don't know where this came from.\n                    this.log(ProcBot.LogLevel.WARN, `Got a closed PR for repo ${owner}/${name} we didn't know about!`);\n                }\n                break;\n        }\n\n        if (updateGeckoboard) {\n            return this.postDataToGeckoboard()\n            .catch((err: Error) => {\n                // Call the GECKOBOT error specific method.\n                err = err;\n                this.reportError({\n                    brief: `${process.env.GECKOBOT_NAME} couldn't do geckoboard`,\n                    message: 'Whoops'\n                });\n            });\n        } else {\n            return Promise.resolve();\n        }\n    }\n\n    private getOpenPRsForRepo(owner: string, repo: string): Promise<OpenPREntry> {\n        // Get all open PRs for the repo.\n        const githubApi = this.githubApi;\n\n        return this.gitCall(githubApi.pullRequests.getAll, {\n            owner,\n            repo,\n            state: 'open'\n        }).then((results: GithubBotApiTypes.PullRequest[]) => {\n            return {\n                name: `${repo}`,\n                openprs: results.length,\n                attime: ''\n            };\n        });\n    }\n\n    private newEntriesFromRepos() {\n        // Go through all the known repos and create new data points.\n        const attime = new Date().toISOString();\n        _.each(this.allRepos, (repo) => {\n            this.dataset.push({\n                name: repo.name,\n                openprs: repo.openprs,\n                attime: attime\n            });\n        });\n    }\n\n    private postDataToGeckoboard(): Promise<void> {\n        // Create the dataset (or ensure it exists)\n        return this.geckoBoard.findOrCreateAsync({\n            id: 'pullrequests',\n            fields: {\n                name: {\n                    type: 'string',\n                    name: 'Repository'\n                },\n                openprs: {\n                    type: 'number',\n                    name: 'Open PRs'\n                },\n                attime: {\n                    type: 'datetime',\n                    name: 'Date'\n                }\n            }\n        }).then((dataset: any) => {\n            const dataSetPromise = Promise.promisifyAll(dataset);\n            return dataSetPromise.putAsync(this.dataset);\n        });\n    }\n\n    private reportError(error: GeckoBotError): void {\n        // We create several reports from this error:\n        //  * Flowdock team inbox post in the relevant room\n        //  * Comment on the PR affected\n        //  * Local console log\n        this.alert(ProcBot.AlertLevel.ERROR, error.message);\n    }\n}\n\n// Export the GECKOBOT to the app.\n// We register the Github events we're interested in here.\nexport function createBot(): GeckoBot {\n    if (!process.env.GECKOBOT_NAME) {\n        throw new Error(`'GeckoBot_NAME' environment variables need setting`);\n    }\n\n    return new GeckoBot(process.env.INTEGRATION_ID, process.env.GECKOBOT_NAME);\n}\n"],"sourceRoot":"../../lib"}