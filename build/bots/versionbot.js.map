{"version":3,"sources":["bots/versionbot.ts"],"names":[],"mappings":"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","file":"versionbot.js","sourcesContent":["/*\nCopyright 2016-2017 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// VersionBot listens for merges of a PR to the `master` branch and then\n// updates any packages for it.\nimport * as Promise from 'bluebird';\nimport * as FS from 'fs';\nimport * as GithubApi from 'github';\nimport * as _ from 'lodash';\nimport * as path from 'path';\nimport { cleanup, track } from 'temp';\nimport * as GithubApiTypes from '../apis/githubapi-types';\nimport { ProcBot } from '../framework/procbot';\nimport { ProcBotConfiguration } from '../framework/procbot-types';\nimport { GithubCookedData, GithubHandle, GithubRegistration } from '../services/github-types';\nimport { ServiceEmitter, ServiceEvent } from '../services/service-types';\nimport { BuildCommand, ExecuteCommand } from '../utils/environment';\nimport { AlertLevel, LogLevel } from '../utils/logger';\n\n// Exec technically has a binding because of it's Node typings, but promisify doesn't include\n// the optional object (we need for CWD). So we need to special case it.\nconst fsReadFile: (filename: string, options?: any) => Promise<Buffer | string> = Promise.promisify(FS.readFile);\nconst fsFileExists = Promise.promisify(FS.stat);\nconst tempMkdir = Promise.promisify(track().mkdir);\nconst tempCleanup = Promise.promisify(cleanup);\n\n/** Stores data for a file retrieved from Github. */\ninterface EncodedFile extends FileMapping {\n\t/** The git tree entry the file belongs in. */\n\ttreeEntry: GithubApiTypes.TreeEntry;\n\t/** The SHA for the blob that is the file. */\n\tblobSha: string;\n};\n\n/** Interface to store contents of a file extracted from a cloned git repo. */\ninterface FileMapping {\n\t/** The file contents. */\n\tfile: string;\n\t/** The current format of encoding ('utf-8', 'base64' etc.) */\n\tencoding: string;\n}\n\n/** Used to pass the the PR and commit message for merging. */\ninterface MergeData {\n\t/** Commit message (version) to use as the merge message. */\n\tcommitVersion: string;\n\t/** The PR that originated the merge. */\n\tpullRequest: GithubApiTypes.PullRequest;\n}\n\n/** Interface to pass relevant information into the blob creation method. */\ninterface RepoFileData {\n\t/** Owner of the repository to commit files to. */\n\towner: string;\n\t/** Repository to commit files to. */\n\trepo: string;\n\t/** Branch to commit files to. */\n\tbranchName: string;\n\t/** New version of the component to commit as. */\n\tversion: string;\n\t/** The files to commit. */\n\tfiles: FileMapping[];\n}\n\n/** The ReviewState enumerated type denotes an approved or blocked review. */\nenum ReviewState {\n\tApproved = 0,\n\tChangesRequired\n};\n\n/**\n * Interface used to store usernames of those who have reviewed, and the type of\n * review they gave. Note that commented reviews are ignored.\n */\ninterface ReviewerMap {\n\t/** Key is the username, value is the type of review. */\n\t[name: string]: ReviewState;\n};\n\n/** Interface to pass data required to run versionist on a repo. */\ninterface VersionistData {\n\t/** Auth token to use to clone the repository. */\n\tauthToken: string;\n\t/** Branchname of the repo to clone. */\n\tbranchName: string;\n\t/** Full path of the location where the repository should be cloned. */\n\tfullPath: string;\n\t/** Full name of the repository (owner/reponame). */\n\trepoFullName: string;\n\t/** Files that have been modified by running versionist. */\n\tfiles?: string[];\n\t/** The new version of the component. */\n\tversion?: string;\n}\n\n/** Interface for passing errors around. */\ninterface VersionBotError {\n\t/** Brief error message. */\n\tbrief: string;\n\t/** Detailed error message. */\n\tmessage: string;\n\t/** PR number the error occured in. */\n\tnumber: number;\n\t/** Owner of the repository. */\n\towner: string;\n\t/** Repository name. */\n\trepo: string;\n}\n\n/** Interface for reporting an error from Node's FS module. */\ninterface FSError {\n\t/** Error code. */\n\tcode: string;\n\t/** Error message. */\n\tmessage: string;\n}\n\n/** Relative (from root) filepath to the VersionBot configuration file in a repository. */\nconst RepositoryFilePath = 'repository.yml';\n/** Message sent to required reviewers should they not have been added on a review. */\nconst ReviewerAddMessage = 'Please add yourselves as reviewers for this PR.';\n\n/** Defines an interface for configuration-defined required tags. */\ninterface FooterTag {\n\t/** How many occurrences of the tag must be seen in a PR. */\n\toccurrence?: string;\n\t/** A RegExp defining the valid values for a tag. */\n\tvalues?: string;\n\t/** RegExp flags to use with the values property. */\n\tflags?: string;\n}\n\n/** Interface defining a set of FooterTag objects. */\ninterface FooterTags {\n\t[key: string]: FooterTag;\n}\n\n/** Interface for passing missing tags in a PR to a calling method. */\ninterface MissingTag {\n\t/** Name of the required tag missing. */\n\tname: string;\n\t/** Reason the tag failed. */\n\treason: string;\n}\n\n/** The VersionBot specific ProcBot Configuration structure. */\ninterface VersionBotConfiguration extends ProcBotConfiguration {\n\t/** Minimum number of review approvals required to satisfy a review. */\n\t'minimum-approvals'?: number;\n\t/** A list of approved reviewers who count towards the minimum number of approvals. */\n\treviewers?: string[];\n\t/** A list of approved maintainers (who also count as approved reviewers). */\n\tmaintainers?: string[];\n\t/** Required commit footer tags. */\n\t'required-tags'?: FooterTags;\n}\n\n/** Interface for storing the result of each status check required on a PR and it's state. */\ninterface StatusResult {\n\t/** Name of the status check. */\n\tname: string;\n\t/** State of the status check. */\n\tstate: StatusChecks;\n}\n\n/** State for the StatusResult interface. */\nenum StatusChecks {\n\t/** Status check has passed. */\n\tPassed,\n\t/** Status check is currently being carried out. */\n\tPending,\n\t/** Status check has failed. */\n\tFailed\n};\n\n/**\n * Allows the filtering of results from the `checkStatuses` method.\n * Depending on the `includeContexts` flag, results returned from the method:\n *   * Only include results from contexts listed in the `contexts` property (`includeContexts` is `true`)\n *   * Only include results from contexts not listed in the `contexts` property (`includeContexts` is `false`)\n */\ninterface StatusFilter {\n\t/** Whether this filter includes tags that should be included or excluded. */\n\tincludeContexts: boolean;\n\t/** The list of status contexts to include or exclude. */\n\tcontexts: string[];\n}\n\n/** Pull request type event. */\ntype GenericPullRequestEvent = GithubApiTypes.PullRequestEvent | GithubApiTypes.PullRequestReviewEvent;\n\n/** Label to be applied for triggering VersionBot to carry out a merge. */\nconst MergeLabel = 'procbots/versionbot/ready-to-merge';\n/** Label to be applied for VersionBot to ignore the PR. */\nconst IgnoreLabel = 'procbots/versionbot/no-checks';\n\n/** Status context for versionist. */\nconst StatusVersionist = {\n\t/** Context name. */\n\tContext: 'Versionist',\n\t/** Status context message for versionist success. */\n\tSuccess: 'Found all required commit footer tags',\n\t/** Status context message for versionist failure. */\n\tFailure: 'Missing or forbidden tags in commits, see `repository.yml`',\n\t/** Status context message for the `procbots/versionbot/no-checks` label. */\n\tNoVersioning: 'Versioning for this PR is disabled'\n};\n\n/** Status context for reviewers. */\nconst StatusReviewers = {\n\tContext: 'Reviewers'\n};\n\n/** Status context for automatic (non-manual) merging. */\nconst StatusAutoMerge = {\n\t/** Context name. */\n\tContext: 'AutoMerges',\n\t/** Status context message for automatic merging success. */\n\tSuccess: 'PR merging is in progress',\n\t/** Status context message for automatic merging failure. */\n\tPending: 'VersionBot should be used to merge PR',\n\t/** Status context message for the `procbots/versionbot/no-checks` label. */\n\tManualMerge: 'Manual merging is in effect for this PR'\n};\n\n/**\n * The VersionBot is built on top of the ProcBot class, which does all the heavy lifting and scheduling.\n * It is designed to check for valid `versionist` commit semantics and alter (or merge) a PR\n * accordingly.\n */\nexport class VersionBot extends ProcBot {\n\t/** Github ServiceListener name. */\n\tprivate githubListenerName: string;\n\t/** Github ServiceEmitter name. */\n\tprivate githubEmitterName: string;\n\t/** Github ServiceEmitter. */\n\tprivate githubEmitter: ServiceEmitter;\n\t/** Instance of Github SDK API in use. */\n\tprivate githubApi: GithubApi;\n\t/** Email address used for commiting as VersionBot. */\n\tprivate emailAddress: string;\n\n\t/**\n\t * Constructs a new VersionBot instance.\n\t * @param integration  Github App ID.\n\t * @param name         Name of the VersionBot.\n\t * @param pemString    PEM for Github events and App login.\n\t * @param webhook      Secret webhook for validating events.\n\t */\n\tconstructor(integration: number, name: string, email: string, pemString: string, webhook: string) {\n\t\t// This is the VersionBot.\n\t\tsuper(name);\n\t\tthis.emailAddress = email;\n\n\t\t// Create a new listener for Github with the right Integration ID.\n\t\tconst ghListener = this.addServiceListener('github', {\n\t\t\tclient: name,\n\t\t\tloginType: {\n\t\t\t\tintegrationId: integration,\n\t\t\t\tpem: pemString,\n\t\t\t\ttype: 'integration'\n\t\t\t},\n\t\t\tpath: '/webhooks',\n\t\t\tport: 4567,\n\t\t\ttype: 'listener',\n\t\t\twebhookSecret: webhook\n\t\t});\n\n\t\t// Create a new emitter with the right Integration ID.\n\t\tconst ghEmitter = this.addServiceEmitter('github', {\n\t\t\tloginType: {\n\t\t\t\tintegrationId: integration,\n\t\t\t\tpem: pemString,\n\t\t\t\ttype: 'integration'\n\t\t\t},\n\t\t\tpem: pemString,\n\t\t\ttype: 'emitter'\n\t\t});\n\n\t\t// Throw if we didn't get either of the services.\n\t\tif (!ghListener) {\n\t\t\tthrow new Error(\"Couldn't create a Github listener\");\n\t\t}\n\t\tif (!ghEmitter) {\n\t\t\tthrow new Error(\"Couldn't create a Github emitter\");\n\t\t}\n\t\tthis.githubListenerName = ghListener.serviceName;\n\t\tthis.githubEmitter = ghEmitter;\n\t\tthis.githubEmitterName = this.githubEmitter.serviceName;\n\n\t\t// Github API handle\n\t\tthis.githubApi = (<GithubHandle>this.githubEmitter.apiHandle).github;\n\t\tif (!this.githubApi) {\n\t\t\tthrow new Error('No Github API instance found');\n\t\t}\n\n\t\t// We have two different WorkerMethods here:\n\t\t// 1) Status checks on PR open and commits\n\t\t// 2) PR review and label checks for merge\n\t\t_.forEach([\n\t\t\t{\n\t\t\t\tname: 'CheckVersionistCommitStatus',\n\t\t\t\tevents: [ 'pull_request' ],\n\t\t\t\tlistenerMethod: this.checkFooterTags,\n\t\t\t\tsuppressionLabels: [ IgnoreLabel ],\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'CheckReviewerStatus',\n\t\t\t\tevents: [ 'pull_request', 'pull_request_review' ],\n\t\t\t\tlistenerMethod: this.checkReviewers,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'CheckForWaffleFlow',\n\t\t\t\tevents: [ 'pull_request' ],\n\t\t\t\tlistenerMethod: this.checkWaffleFlow,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'AddMissingReviewers',\n\t\t\t\tevents: [ 'pull_request' ],\n\t\t\t\tlistenerMethod: this.addReviewers,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'CheckForReadyMergeState',\n\t\t\t\tevents: [ 'pull_request', 'pull_request_review' ],\n\t\t\t\tlistenerMethod: this.mergePR,\n\t\t\t\tsuppressionLabels: [ IgnoreLabel ],\n\t\t\t\ttriggerLabels: [ MergeLabel ],\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'NoChecksPassthrough',\n\t\t\t\tevents: [ 'pull_request', 'pull_request_review' ],\n\t\t\t\tlistenerMethod: this.passWithNoChecks,\n\t\t\t\ttriggerLabels: [ IgnoreLabel ],\n\t\t\t\tsuppressionLabels: [ MergeLabel ],\n\t\t\t},\n\t\t\t// Should a status change occur (Jenkins, VersionBot, etc. all succeed)\n\t\t\t// then check versioning and potentially go to a merge to master.\n\t\t\t{\n\t\t\t\tname: 'StatusChangeState',\n\t\t\t\tevents: [ 'status' ],\n\t\t\t\tlistenerMethod: this.statusChange,\n\t\t\t}\n\t\t], (reg: GithubRegistration) => {\n\t\t\tghListener.registerEvent(reg);\n\t\t});\n\t}\n\n\t/**\n\t * Looks for status change events and creates relevant PR events for any PR whose codebase changes\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('status' event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected statusChange = (registration: GithubRegistration, event: ServiceEvent): Promise<void | void[]> => {\n\t\t// We now use the data from the StatusEvent to mock up a PullRequestEvent with enough\n\t\t// data to carry out the checks.\n\t\tconst splitRepo = event.cookedEvent.data.name.split('/');\n\t\tconst owner = splitRepo[0];\n\t\tconst repo = splitRepo[1];\n\t\tconst commitSha = event.cookedEvent.data.sha;\n\t\tconst branches = event.cookedEvent.data.branches;\n\t\tlet prEvents: ServiceEvent[] = [];\n\n\t\t// If we made the status change, we stop now!\n\t\tswitch (event.cookedEvent.data.context) {\n\t\t\tcase StatusVersionist.Context:\n\t\t\tcase StatusReviewers.Context:\n\t\t\tcase StatusAutoMerge.Context:\n\t\t\t\treturn Promise.resolve();\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Get all PRs for each named branch.\n\t\t// We *only* work on open states.\n\t\treturn Promise.map(branches, (branch: GithubApiTypes.StatusEventBranch) => {\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\thead: `${owner}:${branch.name}`,\n\t\t\t\t\towner,\n\t\t\t\t\trepo,\n\t\t\t\t\tstate: 'open'\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.pullRequests.getAll\n\t\t\t});\n\t\t}).then((foundPrs: GithubApiTypes.PullRequest[][]) => {\n\t\t\tconst prs = _.flatten(foundPrs);\n\n\t\t\t// For each PR, attempt to match the SHA to the head SHA. If we get a match\n\t\t\t// we create a new prInfo and then hand them all to another map.\n\t\t\t_.each(prs, (pullRequest) => {\n\t\t\t\tif (pullRequest.head.sha === commitSha) {\n\t\t\t\t\tprEvents.push({\n\t\t\t\t\t\tcookedEvent: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\taction: 'synchronize',\n\t\t\t\t\t\t\t\tpull_request: pullRequest,\n\t\t\t\t\t\t\t\tsender: {\n\t\t\t\t\t\t\t\t\tlogin: pullRequest.user.login\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgithubApi: event.cookedEvent.githubApi,\n\t\t\t\t\t\t\ttype: 'pull_request'\n\t\t\t\t\t\t},\n\t\t\t\t\t\trawEvent: {\n\t\t\t\t\t\t\tpull_request: pullRequest,\n\t\t\t\t\t\t\tsender: {\n\t\t\t\t\t\t\t\tlogin: pullRequest.user.login\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsource: process.env.VERSIONBOT_NAME\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// We've an event for each PR. However, we now have to check the labels on it and a status event\n\t\t\t// does not include a PR. As we have already retrieved the right PR here, we filter out any that\n\t\t\t// have the suppression label on them.\n\t\t\treturn Promise.delay(2000).then(() => {\n\t\t\t\treturn Promise.filter(prEvents, (prEvent) => {\n\t\t\t\t\tconst pr: GithubApiTypes.PullRequest = prEvent.cookedEvent.data.pull_request;\n\n\t\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\t\t\towner: pr.head.repo.owner.login,\n\t\t\t\t\t\t\trepo: pr.head.repo.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmethod: this.githubApi.issues.getIssueLabels\n\t\t\t\t\t}).then((labels: GithubApiTypes.IssueLabel[]) => {\n\t\t\t\t\t\tif (!_.every(labels, (label) => label.name !== IgnoreLabel)) {\n\t\t\t\t\t\t\tthis.logger.log(LogLevel.DEBUG,\n\t\t\t\t\t\t\t\t`Dropping '${registration.name}' as suppression labels are all present`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}).map((prEvent: ServiceEvent) => {\n\t\t\treturn this.checkFooterTags(registration, prEvent);\n\t\t});\n\t}\n\n\t/**\n\t * Always passes Versionist and AutoMerge status if a no-checks label has been applied.\n\t * This allows manual merging to correctly go ahead.\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('pull_request' event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected passWithNoChecks = (_registration: GithubRegistration, event: ServiceEvent): Promise<void> => {\n\t\tconst pr = event.cookedEvent.data.pull_request;\n\t\tconst head = event.cookedEvent.data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst repo = head.repo.name;\n\t\tconst prNumber = pr.number;\n\n\t\tthis.logger.log(LogLevel.INFO, `Skipping AutoMerge and Versionist checks for ${owner}/${repo}#${prNumber}`);\n\n\t\t// Always set the automerge and versionist status to passing.\n\t\treturn Promise.all([\n\t\t\tthis.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tcontext: StatusAutoMerge.Context,\n\t\t\t\t\tdescription: StatusAutoMerge.ManualMerge,\n\t\t\t\t\towner,\n\t\t\t\t\trepo,\n\t\t\t\t\tsha: head.sha,\n\t\t\t\t\tstate: 'success'\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.repos.createStatus,\n\t\t\t}),\n\t\t\tthis.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tcontext: StatusVersionist.Context,\n\t\t\t\t\tdescription: StatusVersionist.NoVersioning,\n\t\t\t\t\towner,\n\t\t\t\t\trepo,\n\t\t\t\t\tsha: head.sha,\n\t\t\t\t\tstate: 'success'\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.repos.createStatus,\n\t\t\t})\n\t\t]).return();\n\t}\n\n\t/**\n\t * Checks for tags which require extra functionality to allow Waffleboard to operate upon the PR.\n\t * Adds autogenerated text to the PR description for relevant tags.\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('pull_request' event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected checkWaffleFlow = (_registration: GithubRegistration, event: ServiceEvent): Promise<void> => {\n\t\tconst pr = event.cookedEvent.data.pull_request;\n\t\tconst head = event.cookedEvent.data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst repo = head.repo.name;\n\t\tconst prNumber = pr.number;\n\t\tconst issues: string[] = [];\n\t\tconst waffleString = '---- Autogenerated Waffleboard Connection: Connects to #';\n\t\tlet body = pr.body;\n\t\tconst generateWaffleReference = (text: string): void => {\n\t\t\tconst regExp = /connects-to:\\s+#([0-9]+)/gi;\n\t\t\tlet match = regExp.exec(text);\n\t\t\twhile (match) {\n\t\t\t\tconst issueNumber = match[1];\n\t\t\t\tif (issues.indexOf(issueNumber) === -1) {\n\t\t\t\t\tissues.push(issueNumber);\n\t\t\t\t}\n\t\t\t\tmatch = regExp.exec(text);\n\t\t\t}\n\t\t};\n\n\t\tthis.logger.log(LogLevel.INFO, `Checking ${owner}/${repo}#${prNumber} for potential Waffleboard connection ` +\n\t\t\t'comments');\n\n\t\t// Look at the PR body. Does it have a `Connects-To: #<number>` tag?\n\t\t// (We're only interested in local PRs and *not* cross-references).\n\t\tgenerateWaffleReference(pr.body);\n\n\t\t// Now look through all the commits in the PR. Do the same thing.\n\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\tnumber: prNumber,\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t},\n\t\t\tmethod: this.githubApi.pullRequests.getCommits\n\t\t}).then((commits: GithubApiTypes.Commit[]) => {\n\t\t\t// Go through all the commits. We're looking for, at a minimum, a 'change-type:' tag.\n\t\t\tfor (let commit of commits) {\n\t\t\t\tgenerateWaffleReference(commit.commit.message);\n\t\t\t}\n\n\t\t\t// Now search the body for an autogenerated Waffle line for each issue.\n\t\t\t// For any we don't find, add one, next to the others.\n\t\t\t// We need to add the autogenerated lines to the footer, so we just append\n\t\t\t// these to the very end of the PR description.\n\t\t\t_.each(issues, (issue) => {\n\t\t\t\tif (body.indexOf(`${waffleString}${issue}`) === -1) {\n\t\t\t\t\t// Get last character of the body. If not a newline, we add one.\n\t\t\t\t\tlet nlChar = '';\n\t\t\t\t\tif (body.charAt(body.length - 1) !== '\\n') {\n\t\t\t\t\t\tnlChar = '\\n';\n\t\t\t\t\t}\n\t\t\t\t\tbody += `${nlChar}${waffleString}${issue}`;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Now update the PR description if we have extra changes.\n\t\t\tif (body !== pr.body) {\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tbody,\n\t\t\t\t\t\tnumber: prNumber,\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.pullRequests.update\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks a freshly opened PR to see if there are any configured reviewers and maintainers.\n\t * Should any valid reviewers and maintainers not already be assigned as reviewers on the PR, then\n\t * a comment is posted on the PR directly asking those user logins to add themselves.\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('pull_request' event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected addReviewers = (_registration: GithubRegistration, event: ServiceEvent): Promise<void> => {\n\t\tconst pr = event.cookedEvent.data.pull_request;\n\t\tconst head = event.cookedEvent.data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst repo = head.repo.name;\n\t\tlet approvedMaintainers: string[];\n\t\tlet approvedReviewers: string[];\n\n\t\t// Only when opening a new PR.\n\t\tif (event.cookedEvent.data.action !== 'opened') {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tthis.logger.log(LogLevel.INFO, `Checking reviewers list for ${owner}/${repo}#${pr.number}`);\n\n\t\t// Get the reviewers for the PR.\n\t\treturn this.retrieveConfiguration({\n\t\t\temitter: this.githubEmitter,\n\t\t\tlocation: {\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tpath: RepositoryFilePath\n\t\t\t}\n\t\t}).then((config: VersionBotConfiguration) => {\n\t\t\tapprovedMaintainers = this.stripPRAuthor((config || {}).maintainers || null, pr) || [];\n\t\t\tapprovedReviewers = this.stripPRAuthor((config || {}).reviewers || null, pr) || [];\n\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.pullRequests.get\n\t\t\t});\n\t\t}).then((pullRequest: GithubApiTypes.PullRequest) => {\n\t\t\t// Look at the reviewers, create a list of configured reviewers that were not added\n\t\t\t// when the PR was opened.\n\t\t\tconst assignedReviewers = _.map(pullRequest.requested_reviewers, (reviewer) => reviewer.login);\n\t\t\tconst configuredReviewers = _.uniq(_.unionWith(approvedReviewers, approvedMaintainers));\n\t\t\tlet missingReviewers = _.filter(configuredReviewers, (reviewer) => {\n\t\t\t\treturn !(_.find(assignedReviewers, (assignedReviewer) => (assignedReviewer === reviewer)) ||\n\t\t\t\t\t(reviewer === pr.user.login));\n\t\t\t});\n\n\t\t\t// We don't assign the author as a reviewer, if they're in the list.\n\t\t\t// An App has no ability to create a review request. The best we can do is to create a new\n\t\t\t// comment pinging those missing in the list to add themselves.\n\t\t\tif (missingReviewers.length > 0) {\n\t\t\t\tlet reviewerMessage = '';\n\t\t\t\t_.each(missingReviewers, (reviewer) => {\n\t\t\t\t\treviewerMessage += `@${reviewer}, `;\n\t\t\t\t});\n\t\t\t\treviewerMessage += ReviewerAddMessage;\n\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo,\n\t\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\t\tbody: reviewerMessage\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.issues.createComment\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks to ensure that the minimum number of approvals for a PR occurs.\n\t * Should the conditions be satisfied then a successful status is set, otherwise a failed\n\t * state is set.\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('pull_request' event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected checkReviewers = (_registration: GithubRegistration, event: ServiceEvent): Promise<void> => {\n\t\tconst pr = event.cookedEvent.data.pull_request;\n\t\tconst head = event.cookedEvent.data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst repo = head.repo.name;\n\t\tlet botConfig: VersionBotConfiguration;\n\n\t\tthis.logger.log(LogLevel.INFO, `Checking reviewer conditions for ${owner}/${repo}#${pr.number}`);\n\n\t\t// Get the reviews for the PR.\n\t\treturn this.retrieveConfiguration({\n\t\t\temitter: this.githubEmitter,\n\t\t\tlocation: {\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tpath: RepositoryFilePath\n\t\t\t}\n\t\t}).then((config: VersionBotConfiguration) => {\n\t\t\tbotConfig = config;\n\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.pullRequests.getReviews\n\t\t\t});\n\t\t}).then((reviews: GithubApiTypes.Review[]) => {\n\t\t\t// Zero is a falsey value, so we'll automatically catch that here.\n\t\t\tconst approvalsNeeded = (botConfig || {})['minimum-approvals'] || 1;\n\t\t\tlet approvedCount = 0;\n\t\t\tlet reviewers: ReviewerMap = {};\n\t\t\tlet status = '';\n\t\t\tlet approvedPR = false;\n\t\t\tconst approvedMaintainers = this.stripPRAuthor((botConfig || {}).maintainers || null, pr);\n\t\t\tconst approvedReviewers = this.stripPRAuthor((botConfig || {}).reviewers || null, pr);\n\n\t\t\t// Sanity checks.\n\t\t\t// If less than one approval is needed, then there's probably a configuration error\n\t\t\t// we fail to review and report as an error.\n\t\t\tif (approvalsNeeded < 1) {\n\t\t\t\treturn this.reportError({\n\t\t\t\t\tbrief: 'Invalid number of approvals required',\n\t\t\t\t\tmessage: 'The number of approvals required to merge a PR is less than one. At least ' +\n\t\t\t\t\t\t`one approval is required. Please ask a maintainer to correct the \\`minimum-approvals\\` ` +\n\t\t\t\t\t\t`value in the config file (current value: ${approvalsNeeded})`,\n\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// If the length of the unique list of maintainers and reviewers is less than\n\t\t\t// the value of `approvalsNeeded`, then this is never going to work.\n\t\t\t// We only need to test if the `approvedReviewers` list is present\n\t\t\tif (approvedReviewers) {\n\t\t\t\tconst mergedReviewers = _.unionWith(approvedReviewers, approvedMaintainers || [], _.isEqual);\n\t\t\t\tif (mergedReviewers.length < approvalsNeeded) {\n\t\t\t\t\t// We can never reach the number of approvals required. Comment on PR.\n\t\t\t\t\treturn this.reportError({\n\t\t\t\t\t\tbrief: 'Not enough reviewers for PR approval',\n\t\t\t\t\t\tmessage: 'The number of approved reviewers for the repository is less than the ' +\n\t\t\t\t\t\t\t`number of approvals that are required for the PR to be merged (${approvalsNeeded}).`,\n\t\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cycle through reviews, ensure that any approved review occurred after any requiring changes.\n\t\t\t// Use a map for reviewers, as we'll need to know if they\n\t\t\treviews.forEach((review: GithubApiTypes.Review) => {\n\t\t\t\tconst reviewer = review.user.login;\n\t\t\t\tif (review.state === 'APPROVED') {\n\t\t\t\t\treviewers[reviewer] = ReviewState.Approved;\n\t\t\t\t} else if (review.state === 'CHANGES_REQUESTED') {\n\t\t\t\t\treviewers[reviewer] = ReviewState.ChangesRequired;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Filter any reviewers who are not in the approved reviewer list *or* in the maintainers\n\t\t\t// list.\n\t\t\tif (_.find(reviewers, (state) => state === ReviewState.ChangesRequired)) {\n\t\t\t\tstatus = 'Changes have been requested by at least one reviewer';\n\t\t\t} else {\n\t\t\t\tlet reviewersApproved: string[] = _.map(reviewers, (_val, key) => key);\n\t\t\t\tlet appendStatus = '';\n\n\t\t\t\tif (approvedReviewers || approvedMaintainers) {\n\t\t\t\t\tif (approvedReviewers) {\n\t\t\t\t\t\treviewersApproved = _.filter(reviewersApproved, (reviewer) => {\n\t\t\t\t\t\t\tif (approvedReviewers && _.find(approvedReviewers, (login) => login === reviewer) ||\n\t\t\t\t\t\t\t(approvedMaintainers && _.find(approvedMaintainers, (login) => login === reviewer))) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// The list of reviewers is now filtered to those who are allowed to review.\n\t\t\t\t// If there is a list of maintainers, *at least one* needs to be in the list.\n\t\t\t\t// Big caveat, if the PR author is a maintainer, then we are not bound by the\n\t\t\t\t// rules. But they will need minimum approvals, and if there are two or more\n\t\t\t\t// maintainers, then another maintainer must approve.\n\t\t\t\tapprovedCount = reviewersApproved.length;\n\t\t\t\tif (approvedMaintainers) {\n\t\t\t\t\tif (_.intersection(reviewersApproved, approvedMaintainers).length < 1) {\n\t\t\t\t\t\tapprovedCount = (approvedCount >= approvalsNeeded) ? (approvalsNeeded - 1) : approvedCount;\n\t\t\t\t\t\tappendStatus = ' - Maintainer approval required';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstatus = `${approvedCount}/${approvalsNeeded} review approvals met${appendStatus}`;\n\t\t\t\tapprovedPR = (approvedCount >= approvalsNeeded) ? true : false;\n\t\t\t}\n\n\t\t\t// Finally set the reviewer status. This is a count of how many *valid* approved reviews have\n\t\t\t// been seen against the number required.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tcontext: StatusReviewers.Context,\n\t\t\t\t\tdescription: status,\n\t\t\t\t\towner: pr.head.repo.owner.login,\n\t\t\t\t\trepo: pr.head.repo.name,\n\t\t\t\t\tsha: pr.head.sha,\n\t\t\t\t\tstate: approvedPR ? 'success' : 'failure'\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.repos.createStatus\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Checks the newly opened PR and its commits.\n\t * 1. Triggered by an 'opened', 'synchronize' or 'labeled' event.\n\t * 2. If the number of required tags and occurrences are present, we create a successful status,\n\t *    otherwise we create a failed one.\n\t * 3. If a version bump has occurred and everything is valid, merge the commit to `master`.\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('pull_request' event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected checkFooterTags = (_registration: GithubRegistration, event: ServiceEvent): Promise<void> => {\n\t\tconst prEvent: GithubApiTypes.PullRequestEvent = event.cookedEvent.data;\n\t\tconst pr = prEvent.pull_request;\n\t\tconst head = pr.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst name = head.repo.name;\n\t\tconst author = prEvent.sender.login;\n\t\tconst prAction = event.cookedEvent.data.action;\n\t\tconst prLabel: GithubApiTypes.Label = event.cookedEvent.data.label;\n\t\tlet committer = author;\n\t\tlet lastCommit: GithubApiTypes.Commit;\n\t\tlet botConfig: VersionBotConfiguration;\n\n\t\t// Only for opened, synced or labeling actions.\n\t\tif (!_.find(['opened', 'synchronize', 'labeled', 'unlabeled'], (action) => action === prAction)) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// If there's an unlabeling event, but it wasn't the IgnoreLabel being removed, then we\n\t\t// just return.\n\t\tif ((prAction === 'unlabeled') && (prLabel.name !== IgnoreLabel)) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// Always set the automerge status to failure.\n\t\tthis.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\tcontext: StatusAutoMerge.Context,\n\t\t\t\tdescription: StatusAutoMerge.Pending,\n\t\t\t\towner,\n\t\t\t\trepo: name,\n\t\t\t\tsha: head.sha,\n\t\t\t\tstate: 'pending'\n\t\t\t},\n\t\t\tmethod: this.githubApi.repos.createStatus,\n\t\t});\n\n\t\tthis.logger.log(LogLevel.INFO, `Checking footer tags for ${owner}/${name}#${pr.number}`);\n\n\t\t// Get the configuration, if it exists, for this repo.\n\t\treturn this.retrieveConfiguration({\n\t\t\temitter: this.githubEmitter,\n\t\t\tlocation: {\n\t\t\t\towner,\n\t\t\t\trepo: name,\n\t\t\t\tpath: RepositoryFilePath\n\t\t\t}\n\t\t}).then((config: VersionBotConfiguration) => {\n\t\t\tbotConfig = config;\n\n\t\t\t// Get all the commits on the repo.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\towner,\n\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\trepo: name,\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.pullRequests.getCommits\n\t\t\t});\n\t\t}).then((commits: GithubApiTypes.Commit[]) => {\n\t\t\t// For each tag we find, we adhere to some rules:\n\t\t\t//  * all - Every commit in the PR must contain the tag\n\t\t\t//  * once - At least one commit in the PR contains the tag\n\t\t\t//  * never - The tag must not occur in any commit in the PR\n\t\t\tconst missingTags = this.checkCommitFooterTags(commits, botConfig);\n\n\t\t\tif (commits.length > 0) {\n\t\t\t\tlastCommit = commits[commits.length - 1];\n\t\t\t\tif (lastCommit.committer) {\n\t\t\t\t\tcommitter = lastCommit.committer.login;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (missingTags.length === 0) {\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcontext: StatusVersionist.Context,\n\t\t\t\t\t\tdescription: StatusVersionist.Success,\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo: name,\n\t\t\t\t\t\tsha: head.sha,\n\t\t\t\t\t\tstate: 'success'\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.repos.createStatus\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Else we mark it as having failed and we inform the user directly in the PR.\n\t\t\tlet tagNames = '';\n\t\t\t_.each(missingTags, (tag) => {\n\t\t\t\ttagNames += `${tag.name}, `;\n\t\t\t});\n\t\t\tthis.logger.log(LogLevel.INFO, `Missing tags from accumulated commits: ${tagNames}` +\n\t\t\t\t`for ${owner}/${name}#${pr.number}`);\n\n\t\t\t// Go through the tags and compose a message.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tcontext: StatusVersionist.Context,\n\t\t\t\t\tdescription: StatusVersionist.Failure,\n\t\t\t\t\towner,\n\t\t\t\t\trepo: name,\n\t\t\t\t\tsha: head.sha,\n\t\t\t\t\tstate: 'failure'\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.repos.createStatus,\n\t\t\t});\n\t\t}).then(() => {\n\t\t\t// Check statuses (including Versionist) on the PR.\n\t\t\t// Discount the reviewers context (as it's obvious as part of the PR), and the\n\t\t\t// automerge context, as we control that ourselves.\n\t\t\treturn this.checkStatuses(pr, {\n\t\t\t\tincludeContexts: false,\n\t\t\t\tcontexts: [ StatusReviewers.Context, StatusAutoMerge.Context ]\n\t\t\t});\n\t\t}).then((checkStatus) => {\n\t\t\t// If any of them fail (*not* pending), then *if* we haven't already\n\t\t\t// commented (ie. we previously commented and there's been no commit\n\t\t\t// since), we ping the author of the PR and whinge at them.\n\t\t\tif (checkStatus === StatusChecks.Failed) {\n\t\t\t\t// Get the last commit. If there have been no comments *since* the\n\t\t\t\t// date of that commit, then we know that we can safely post a\n\t\t\t\t// comment telling the author of a failure. If there has, then\n\t\t\t\t// it's implicit that we made a comment.\n\t\t\t\tconst lastCommitTimestamp = Date.parse(lastCommit.commit.committer.date);\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\towner,\n\t\t\t\t\t\trepo: name,\n\t\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.issues.getComments\n\t\t\t\t}).then((comments: GithubApiTypes.Comment[]) => {\n\t\t\t\t\t// Check for any comments that come *after* the last commit\n\t\t\t\t\t// timestamp and is a Bot.\n\t\t\t\t\tif (_.some(comments, (comment: GithubApiTypes.Comment) => {\n\t\t\t\t\t\treturn ((comment.user.type === 'Bot') &&\n\t\t\t\t\t\t\t(lastCommitTimestamp < Date.parse(comment.created_at)) &&\n\t\t\t\t\t\t\t!_.endsWith(comment.body, ReviewerAddMessage));\n\t\t\t\t\t})) {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now we ping the author, telling them something went wrong.\n\t\t\t\t\tlet warningUsers = '';\n\t\t\t\t\twarningUsers = `@${author}, `;\n\t\t\t\t\tif (author !== committer) {\n\t\t\t\t\t\twarningUsers += `@${committer}, `;\n\t\t\t\t\t}\n\t\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tbody: `${warningUsers}status checks have failed for this PR. Please make appropriate `+\n\t\t\t\t\t\t\t\t'changes and recommit.',\n\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\t\t\trepo: name,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmethod: this.githubApi.issues.createComment,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}).then(() => {\n\t\t\t// Get the labels for the PR.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\towner,\n\t\t\t\t\trepo: name\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.issues.getIssueLabels\n\t\t\t});\n\t\t}).then((labels: GithubApiTypes.IssueLabel[]) => {\n\t\t\t// If we don't have a relevant label for merging, we don't proceed.\n\t\t\tif (_.some(labels, (label) => label.name === MergeLabel)) {\n\t\t\t\tif (pr.state === 'open') {\n\t\t\t\t\treturn this.finaliseMerge(event.cookedEvent.data, pr);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch((err: Error) => {\n\t\t\t// Call the VersionBot error specific method.\n\t\t\tthis.reportError({\n\t\t\t\tbrief: `${process.env.VERSIONBOT_NAME} check failed for ${owner}/${name}#${pr.number}`,\n\t\t\t\tmessage: `${process.env.VERSIONBOT_NAME} failed to carry out a status check for the above pull ` +\n\t\t\t\t\t`request here: ${pr.html_url}. The reason for this is:\\r\\n${err.message}\\r\\n` +\n\t\t\t\t\t'Please carry out relevant changes or alert an appropriate admin.',\n\t\t\t\tnumber: pr.number,\n\t\t\t\towner,\n\t\t\t\trepo: name\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Merges a PR.\n\t * 1. Triggered by a 'labeled' event ('procbots/versionbot/ready-to-merge') or a\n\t *\t'pull_request_review_comment'\n\t * 2. Checks all review comments to ensure that at least one approves the PR (and that no comment\n\t *\tthat may come after it includes a 'CHANGES_REQUESTED' state).\n\t * 3. Commit new version upped files to the branch, which will cause a 'synchronized' event,\n\t *\twhich will finalise the merge.\n\t *\n\t * It should be noted that this will, of course, result in a 'closed' event on a PR, which\n\t * in turn will feed into the 'generateVersion' method.\n\t *\n\t * @param _registration  GithubRegistration object used to register the method\n\t * @param event          ServiceEvent containing the event information ('pull_request' or 'pull_request_review'\n\t *                       event)\n\t * @returns              A void Promise once execution has finished.\n\t */\n\tprotected mergePR = (_registration: GithubRegistration, event: ServiceEvent): Promise<void> => {\n\t\t// States for review comments are:\n\t\t//  * COMMENT\n\t\t//  * CHANGES_REQUESTED\n\t\t//  * APPROVED\n\t\t//\n\t\t// We *only* go through with a merge should:\n\t\t//  * The 'procbots/versionbot/ready-to-merge' label appear on the PR issue\n\t\t//  * All required statuses have been successful.\n\t\t// The latter overrides the label should it exist, as it will be assumed it is in error.\n\t\tconst cookedData: GithubCookedData = event.cookedEvent;\n\t\tconst data: GenericPullRequestEvent = cookedData.data;\n\t\tconst pr = data.pull_request;\n\t\tconst head = data.pull_request.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst repo = head.repo.name;\n\t\tconst repoFullName = `${owner}/${repo}`;\n\t\tlet newVersion: string;\n\t\tlet fullPath: string;\n\t\tlet branchName = pr.head.ref;\n\t\tlet botConfig: VersionBotConfiguration;\n\n\t\t// Check the action on the event to see what we're dealing with.\n\t\tswitch (cookedData.data.action) {\n\t\t\t// Submission is a PR review\n\t\t\tcase 'submitted':\n\t\t\tcase 'labeled':\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// We have no idea what sparked this, but we're not doing anything!\n\t\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tthis.logger.log(LogLevel.INFO, `PR is ready to merge, attempting to carry out a ` +\n\t\t\t`version up for ${owner}/${repo}#${pr.number}`);\n\n\t\t// Get the reviews for the PR.\n\t\treturn this.retrieveConfiguration({\n\t\t\temitter: this.githubEmitter,\n\t\t\tlocation: {\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tpath: RepositoryFilePath\n\t\t\t}\n\t\t}).then((config: VersionBotConfiguration) => {\n\t\t\tbotConfig = config;\n\n\t\t\t// Actually generate a new version of a component:\n\t\t\t// 1. Clone the repo\n\t\t\t// 2. Checkout the appropriate branch given the PR number\n\t\t\t// 3. Run `versionist`\n\t\t\t// 4. Read the `CHANGELOG.md` (and any `package.json`, if present)\n\t\t\t// 5. Base64 encode them\n\t\t\t// 6. Call Github to update them, in serial, CHANGELOG last (important for merging expectations)\n\t\t\t// 7. Finish\n\n\t\t\t// Check to ensure that the PR is actually mergeable. If it isn't, we report this as an\n\t\t\t// error, passing the state.\n\t\t\tif (pr.mergeable !== true) {\n\t\t\t\tthrow new Error('The branch cannot currently be merged into master. It has a state of: ' +\n\t\t\t\t\t`\\`${pr.mergeable_state}\\``);\n\t\t\t}\n\n\t\t\t// Ensure that all the statuses required have passed (we ignore the automerge status).\n\t\t\t// If not, an error will be thrown and not proceed any further.\n\t\t\treturn this.checkStatuses(pr, {\n\t\t\t\tincludeContexts: false,\n\t\t\t\tcontexts: [ StatusAutoMerge.Context ]\n\t\t\t});\n\t\t}).then((checkStatus) => {\n\t\t\t// Finally we have an array of booleans. If any of them are false,\n\t\t\t// statuses aren't valid.\n\t\t\tif ((checkStatus === StatusChecks.Failed) || (checkStatus === StatusChecks.Pending)) {\n\t\t\t\tthrow new Error('checksPendingOrFailed');\n\t\t\t}\n\n\t\t\t// Ensure we've not already committed. If we have, we don't wish to do so again.\n\t\t\treturn this.getVersionBotCommits(pr);\n\t\t}).then((commitMessage: string | null) => {\n\t\t\tif (commitMessage) {\n\t\t\t\tthrow new Error(`alreadyCommitted`);\n\t\t\t}\n\n\t\t\t// If this was a labeling action and it's a pull_request event.\n\t\t\tif ((cookedData.data.action === 'labeled') && (cookedData.type === 'pull_request')) {\n\t\t\t\tthis.checkValidMaintainer(botConfig, cookedData.data);\n\t\t\t}\n\n\t\t\t// Create new work dir.\n\t\t\treturn tempMkdir(`${repo}-${pr.number}_`);\n\t\t}).then((tempDir: string) => {\n\t\t\tfullPath = `${tempDir}${path.sep}`;\n\n\t\t\treturn this.applyVersionist({\n\t\t\t\tauthToken: cookedData.githubAuthToken,\n\t\t\t\tbranchName,\n\t\t\t\tfullPath,\n\t\t\t\trepoFullName\n\t\t\t});\n\t\t}).then((versionData: VersionistData) => {\n\t\t\tif (!versionData.version || !versionData.files) {\n\t\t\t\tthrow new Error('Could not find new version!');\n\t\t\t}\n\t\t\tnewVersion = versionData.version;\n\n\t\t\t// Read each file and base64 encode it.\n\t\t\treturn Promise.map(versionData.files, (file: string) => {\n\t\t\t\treturn fsReadFile(`${fullPath}${file}`).call(`toString`, 'base64')\n\t\t\t\t.then((encoding: string) => {\n\t\t\t\t\tlet newFile: FileMapping = {\n\t\t\t\t\t\tfile,\n\t\t\t\t\t\tencoding,\n\t\t\t\t\t};\n\t\t\t\t\treturn newFile;\n\t\t\t\t});\n\t\t\t});\n\t\t}).then((files: FileMapping[]) => {\n\t\t\treturn this.createCommitBlobs({\n\t\t\t\tbranchName,\n\t\t\t\tfiles,\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tversion: newVersion\n\t\t\t});\n\t\t}).then(() => {\n\t\t\tthis.logger.log(LogLevel.INFO, `Upped version of ${repoFullName}#${pr.number} to ` +\n\t\t\t\t`${newVersion}; tagged and pushed.`);\n\t\t}).catch((err: Error) => {\n\t\t\t// Call the VersionBot error specific method if this wasn't the short circuit for\n\t\t\t// committed code.\n\t\t\tif ((err.message !== 'alreadyCommitted') && (err.message !== 'checksPendingOrFailed')) {\n\t\t\t\tthis.reportError({\n\t\t\t\t\tbrief: `${process.env.VERSIONBOT_NAME} failed to merge ${repoFullName}#${pr.number}`,\n\t\t\t\t\tmessage: `${process.env.VERSIONBOT_NAME} failed to commit a new version to prepare a merge for ` +\n\t\t\t\t\t\t`the above pull request here: ${pr.html_url}. The reason for this is:\\r\\n${err.message}\\r\\n` +\n\t\t\t\t\t\t'Please carry out relevant changes or alert an appropriate admin.',\n\t\t\t\t\tnumber: pr.number,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t});\n\t\t\t}\n\t\t}).finally(tempCleanup);\n\t}\n\n\t/**\n\t * Clones a repository and runs `versionist` upon it, creating new change files.\n\t *\n\t * @param versionData  Information on the repository and version.\n\t * @returns            Promise with added information on the repo.\n\t */\n\tprivate applyVersionist(versionData: VersionistData): Promise<VersionistData> {\n\t\t// Clone the repository inside the directory using the commit name and the run versionist.\n\t\t// We only care about output from the git status.\n\t\t//\n\t\t// IMPORTANT NOTE: Currently, Versionist will fail if it doesn't find a\n\t\t//  `package.json` file. This means components that don't have one need a custom\n\t\t//  `versionist.conf.js` in their root dir. And we need to test to run against it.\n\t\t//  It's possible to get round this using a custom `versionist.conf.js`, which we now support.\n\n\t\t// We retry the clone up to three times, as we've seen issues in the past where GH doesn't\n\t\t// authenticate correctly. If it clones, then checkout should only fail if the branch isn't valid.\n\t\treturn Promise.mapSeries([\n\t\t\tBuildCommand('git', ['clone', `https://${versionData.authToken}:${versionData.authToken}@github.com/` +\n\t\t\t\t`${versionData.repoFullName}`, `${versionData.fullPath}`],\n\t\t\t\t{ cwd: `${versionData.fullPath}`, retries: 3 }),\n\t\t\tBuildCommand('git', ['checkout', `${versionData.branchName}`], { cwd: `${versionData.fullPath}` })\n\t\t], ExecuteCommand).then(() => {\n\t\t\t// Test the repo, we want to see if there's a local `versionist.conf.js`.\n\t\t\t// If so, we use that rather than the built-in default.\n\t\t\treturn fsFileExists(`${versionData.fullPath}/versionist.conf.js`)\n\t\t\t.return(true)\n\t\t\t.catch((err: FSError) => {\n\t\t\t\tif (err.code !== 'ENOENT') {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}).catch(() => {\n\t\t\t// Sanitise the error so we send something cleaner up.\n\t\t\tthrow new Error(`Cloning of branch ${versionData.branchName} in ${versionData.repoFullName} failed`);\n\t\t}).then((exists: boolean) => {\n\t\t\tlet versionistCommand: string;\n\t\t\tlet versionistArgs: string[] = [];\n\n\t\t\treturn this.getNodeBinPath().then((nodePath: string) => {\n\t\t\t\tversionistCommand = path.join(nodePath, 'versionist');\n\t\t\t\tif (exists) {\n\t\t\t\t\tversionistArgs = ['-c', 'versionist.conf.js'];\n\t\t\t\t\tthis.logger.log(LogLevel.INFO, 'Found an overriding versionist config ' +\n\t\t\t\t\t\t`for ${versionData.repoFullName}, using that`);\n\t\t\t\t}\n\t\t\t}).then(() => {\n\t\t\t\treturn Promise.mapSeries([\n\t\t\t\t\tBuildCommand(versionistCommand, versionistArgs, { cwd: `${versionData.fullPath}` }),\n\t\t\t\t\tBuildCommand('git', ['status', '-s'], { cwd: `${versionData.fullPath}` })\n\t\t\t\t], ExecuteCommand);\n\t\t\t});\n\t\t}).get(1).then((status: string) => {\n\t\t\tconst moddedFiles: string[] = [];\n\t\t\tlet changeLines = status.split('\\n');\n\t\t\tlet changeLogFound = false;\n\n\t\t\tif (changeLines.length === 0) {\n\t\t\t\tthrow new Error(`Couldn't find any status changes after running 'versionist', exiting`);\n\t\t\t}\n\t\t\tchangeLines = _.slice(changeLines, 0, changeLines.length - 1);\n\t\t\t// For each change, get the name of the change. We shouldn't see *anything* that isn't\n\t\t\t// expected, and we should only see modifications. Log anything else as an issue\n\t\t\t// (but not an error).\n\t\t\tchangeLines.forEach((line) => {\n\t\t\t\t// If we get anything other than an 'M', flag this.\n\t\t\t\tconst match = line.match(/^\\sM\\s(.+)$/);\n\t\t\t\tif (!match) {\n\t\t\t\t\tthrow new Error(`Found a spurious git status entry: ${line.trim()}, abandoning version up`);\n\t\t\t\t} else {\n\t\t\t\t\t// Remove the status so we just get a filename.\n\t\t\t\t\tif (match[1] !== 'CHANGELOG.md') {\n\t\t\t\t\t\tmoddedFiles.push(match[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchangeLogFound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Ensure that the CHANGELOG.md file is always the last and that it exists!\n\t\t\tif (!changeLogFound) {\n\t\t\t\tthrow new Error(`Couldn't find the CHANGELOG.md file, abandoning version up`);\n\t\t\t}\n\t\t\tmoddedFiles.push(`CHANGELOG.md`);\n\n\t\t\t// Now we get the new version from the CHANGELOG (*not* the package.json, it may not exist).\n\t\t\treturn fsReadFile(`${versionData.fullPath}${_.last(moddedFiles)}`, { encoding: 'utf8' })\n\t\t\t.then((contents: string) => {\n\t\t\t\t// Only interested in the first match for '## v...'\n\t\t\t\tconst match = contents.match(/^## (v[0-9]+\\.[0-9]+\\.[0-9]+).+$/m);\n\n\t\t\t\tif (!match) {\n\t\t\t\t\tthrow new Error('Cannot find new version for ${repoFullName}-#${pr.number}');\n\t\t\t\t}\n\n\t\t\t\tversionData.version = match[1];\n\t\t\t\tversionData.files = moddedFiles;\n\t\t\t}).return(versionData);\n\t\t});\n\t}\n\n\t/**\n\t * Updates all relevant repo files with altered version data.\n\t *\n\t * @param repoData  Repository and updated file information.\n\t * @returns         Promise that resolves when git data has been updated.\n\t */\n\tprivate createCommitBlobs(repoData: RepoFileData): Promise<void> {\n\t\t// We use the Github API to now update every file in our list, ending with the CHANGELOG.md\n\t\t// We need this to be the final file updated, as it'll kick off our actual merge.\n\t\t//\n\t\t// Turn all this into a single method, cleaner.\n\t\t// CommitEncodedFile, or something.\n\t\tlet newTreeSha: string;\n\n\t\t// Get the top level hierarchy for the branch. It includes the files we need.\n\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\towner: repoData.owner,\n\t\t\t\trepo: repoData.repo,\n\t\t\t\tsha: repoData.branchName\n\t\t\t},\n\t\t\tmethod: this.githubApi.gitdata.getTree\n\t\t}).then((treeData: GithubApiTypes.Tree) => {\n\t\t\t// We need to save the tree data, we'll be modifying it for updates in a moment.\n\n\t\t\t// Create a new blob for our files.\n\t\t\t// Implicit cast.\n\t\t\treturn Promise.map(repoData.files, (file: EncodedFile) => {\n\t\t\t\t// Find the relevant entry in the tree.\n\t\t\t\tconst treeEntry = _.find(treeData.tree, (entry: GithubApiTypes.TreeEntry) => {\n\t\t\t\t\treturn entry.path === file.file;\n\t\t\t\t});\n\n\t\t\t\tif (!treeEntry) {\n\t\t\t\t\tthrow new Error(`Couldn't find a git tree entry for the file ${file.file}`);\n\t\t\t\t}\n\n\t\t\t\tfile.treeEntry = treeEntry;\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcontent: file.encoding,\n\t\t\t\t\t\tencoding: 'base64',\n\t\t\t\t\t\towner: repoData.owner,\n\t\t\t\t\t\trepo: repoData.repo\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.gitdata.createBlob\n\t\t\t\t}).then((blob: GithubApiTypes.Blob) => {\n\t\t\t\t\tif (file.treeEntry) {\n\t\t\t\t\t\tfile.treeEntry.sha = blob.sha;\n\t\t\t\t\t}\n\t\t\t\t}).return(file);\n\t\t\t}).then((blobFiles: EncodedFile[]) => {\n\t\t\t\t// We now have a load of update tree path entries. We write the\n\t\t\t\t// data back to Github to get a new SHA for it.\n\t\t\t\tconst newTree: GithubApiTypes.TreeEntry[] = [];\n\n\t\t\t\tblobFiles.forEach((file: EncodedFile) => {\n\t\t\t\t\tnewTree.push({\n\t\t\t\t\t\tmode: file.treeEntry.mode,\n\t\t\t\t\t\tpath: file.treeEntry.path,\n\t\t\t\t\t\tsha: file.treeEntry.sha,\n\t\t\t\t\t\ttype: 'blob'\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// Now write this new tree and get back an SHA for it.\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tbase_tree: treeData.sha,\n\t\t\t\t\t\towner: repoData.owner,\n\t\t\t\t\t\trepo: repoData.repo,\n\t\t\t\t\t\ttree: newTree\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.gitdata.createTree\n\t\t\t\t});\n\t\t\t}).then((newTree: GithubApiTypes.Tree) => {\n\t\t\t\tnewTreeSha = newTree.sha;\n\n\t\t\t\t// Get the last commit for the branch.\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\towner: repoData.owner,\n\t\t\t\t\t\trepo: repoData.repo,\n\t\t\t\t\t\tsha: `${repoData.branchName}`\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.repos.getCommit\n\t\t\t\t});\n\t\t\t}).then((lastCommit: GithubApiTypes.Commit) => {\n\t\t\t\t// We have new tree object, we now want to create a new commit referencing it.\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcommitter: {\n\t\t\t\t\t\t\temail: this.emailAddress,\n\t\t\t\t\t\t\tname: this._botname\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmessage: `${repoData.version}`,\n\t\t\t\t\t\towner: repoData.owner,\n\t\t\t\t\t\tparents: [ lastCommit.sha ],\n\t\t\t\t\t\trepo: repoData.repo,\n\t\t\t\t\t\ttree: newTreeSha\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.gitdata.createCommit\n\t\t\t\t});\n\t\t\t}).then((commit: GithubApiTypes.Commit) => {\n\t\t\t\t// Finally, we now update the reference to the branch that's changed.\n\t\t\t\t// This should kick off the change for status.\n\t\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tforce: false, // Not that I'm paranoid...\n\t\t\t\t\t\towner: repoData.owner,\n\t\t\t\t\t\tref: `heads/${repoData.branchName}`,\n\t\t\t\t\t\trepo: repoData.repo,\n\t\t\t\t\t\tsha: commit.sha\n\t\t\t\t\t},\n\t\t\t\t\tmethod: this.githubApi.gitdata.updateReference\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Carries out the merge to `master`, updating relevant references from prior commits.\n\t * Deletes the old branch after merge has occured.\n\t *\n\t * @param data  Repo and commit data to be referenced.\n\t * @returns     Promise that resolves when reference updates and merging has finalised.\n\t */\n\tprivate mergeToMaster(data: MergeData): Promise<void> {\n\t\tconst pr = data.pullRequest;\n\t\tconst owner = pr.head.repo.owner.login;\n\t\tconst repo = pr.head.repo.name;\n\t\tconst prNumber = pr.number;\n\n\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\tcommit_title: `Auto-merge for PR #${prNumber} via ${process.env.VERSIONBOT_NAME}`,\n\t\t\t\tnumber: prNumber,\n\t\t\t\towner,\n\t\t\t\trepo\n\t\t\t},\n\t\t\tmethod: this.githubApi.pullRequests.merge\n\t\t}).then((mergedData: GithubApiTypes.Merge) => {\n\t\t\t// We get an SHA back when the merge occurs, and we use this for a tag.\n\t\t\t// Note date gets filed in automatically by API.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tmessage: data.commitVersion,\n\t\t\t\t\tobject: mergedData.sha,\n\t\t\t\t\towner,\n\t\t\t\t\trepo,\n\t\t\t\t\ttag: data.commitVersion,\n\t\t\t\t\ttagger: {\n\t\t\t\t\t\temail: this.emailAddress,\n\t\t\t\t\t\tname: this._botname\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'commit'\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.gitdata.createTag\n\t\t\t});\n\t\t}).then((newTag: GithubApiTypes.Tag) => {\n\t\t\t// We now have a SHA back that contains the tag object.\n\t\t\t// Create a new reference based on it.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\towner,\n\t\t\t\t\tref: `refs/tags/${data.commitVersion}`,\n\t\t\t\t\trepo,\n\t\t\t\t\tsha: newTag.sha\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.gitdata.createReference\n\t\t\t});\n\t\t}).then(() => {\n\t\t\t// Delete the merge label. This will ensure future updates to the PR are\n\t\t\t// ignored by us.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tname: MergeLabel,\n\t\t\t\t\tnumber: prNumber,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.issues.removeLabel\n\t\t\t});\n\t\t}).then(() => {\n\t\t\t// Finally delete this branch.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\towner,\n\t\t\t\t\tref: `heads/${pr.head.ref}`,\n\t\t\t\t\trepo\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.gitdata.deleteReference\n\t\t\t});\n\t\t}).catch((err: Error) => {\n\t\t\t// Sometimes a state can occur where a label attach occurs at the same time as a final status\n\t\t\t// check finishes. This actually causes two merge events to occur.\n\t\t\t// We supress the error in this event, as all previous checks have passed.\n\t\t\t// Any other issue will show up as a problem in the UI.\n\t\t\tif (err.message !== 'Pull Request is not mergeable') {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\t// Confidence check. We should see any issue that causes a PR to not be\n\t\t\t// mergeable show up as some sort of status in the UI. However, just in case,\n\t\t\t// here's a check to ensure the PR is still open. If it is, raise a\n\t\t\t// flag regardless of why.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tnumber: prNumber,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.pullRequests.get\n\t\t\t}).then((mergePr: GithubApiTypes.PullRequest) => {\n\t\t\t\tif (mergePr.state === 'open') {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieve all protected branch status requirements, and determine the state for each.\n\t * Status checks can be filtered to include or exclude the results of given contexts, if required.\n\t *\n\t * @param prInfo  The PR on which to check the current statuses.\n\t * @param filter  An optional StatusFilter interface, allowing status contexts to be included/excluded\n\t * \tfrom results.\n\t * @returns       Promise containing a StatusChecks object determining the state of each status.\n\t */\n\tprivate checkStatuses(prInfo: GithubApiTypes.PullRequest, filter?: StatusFilter): Promise<StatusChecks> {\n\t\t// We need to check the branch protection for this repo.\n\t\t// Get all the statuses that need to have been satisfied.\n\t\tconst owner = prInfo.head.repo.owner.login;\n\t\tconst repo = prInfo.head.repo.name;\n\t\tconst branch = prInfo.head.ref;\n\t\tlet protectedContexts: string[] = [];\n\t\tconst statusLUT: { [key: string]: StatusChecks; } = {\n\t\t\tfailure: StatusChecks.Failed,\n\t\t\tpending: StatusChecks.Pending,\n\t\t\tsuccess: StatusChecks.Passed,\n\t\t};\n\n\t\t// Now get all of the statuses required for the master branch.\n\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\tbranch: 'master',\n\t\t\t\towner,\n\t\t\t\trepo\n\t\t\t},\n\t\t\tmethod: this.githubApi.repos.getProtectedBranchRequiredStatusChecks\n\t\t}).then((statusContexts: GithubApiTypes.RequiredStatusChecks) => {\n\t\t\tprotectedContexts = statusContexts.contexts;\n\n\t\t\t// Get the statuses combined for this PR branch.\n\t\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\tdata: {\n\t\t\t\t\tref: branch,\n\t\t\t\t\towner,\n\t\t\t\t\trepo\n\t\t\t\t},\n\t\t\t\tmethod: this.githubApi.repos.getCombinedStatus\n\t\t\t});\n\t\t}).then((statuses: GithubApiTypes.CombinedStatus) => {\n\t\t\t// Contexts need to be checked specifically.\n\t\t\t// Branch protection can include contexts that use prefixes which are then\n\t\t\t// suffixed to create more statuses.\n\t\t\t// For example, 'continuous-integration/travis-ci' contexts can end up as:\n\t\t\t//  * continuous-integration/travis-ci/push\n\t\t\t//  * continuous-integration/travis-ci/pr\n\t\t\t// statuses, which mean there are actually two checks per context and not one.\n\t\t\t//\n\t\t\t// The simplest way to check the contexts are therefore to get a list of\n\t\t\t// required status contexts (which we do anyway), then go through each\n\t\t\t// actual status check from the combined, and try and match the prefix of a context\n\t\t\t// with each status. If we get a hit, and the status is a failure, then we\n\t\t\t// have failed. If we match and the status is a pass, we've passed.\n\t\t\t// We can therefore assume that a pass has occurred if:\n\t\t\t//  * We have seen one of every context in the protected status list at least once\n\t\t\t//  AND\n\t\t\t//  * Each of those seen has passed\n\t\t\t// Should any protected context not be seen in the current status checks, then\n\t\t\t// we have failed.\n\t\t\tconst statusResults: StatusResult[] = [];\n\t\t\t_.each(protectedContexts, (proContext) => {\n\t\t\t\t// We go through every status and see if the context prefixes the context\n\t\t\t\t// of the status.\n\t\t\t\t_.each(statuses.statuses, (status) => {\n\t\t\t\t\tif (_.startsWith(status.context, proContext)) {\n\t\t\t\t\t\tlet includeContext = true;\n\t\t\t\t\t\t// If there's a filter, determine if the result should be included or excluded.\n\t\t\t\t\t\tif (filter) {\n\t\t\t\t\t\t\tconst foundContext = _.find(filter.contexts, (context) => context === status.context);\n\t\t\t\t\t\t\tincludeContext = filter.includeContexts ? foundContext !== undefined : !foundContext;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (includeContext) {\n\t\t\t\t\t\t\tstatusResults.push({\n\t\t\t\t\t\t\t\tname: status.context,\n\t\t\t\t\t\t\t\tstate: statusLUT[status.state]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// If any of the checks are pending, we wait.\n\t\t\tif (_.some(statusResults, [ 'state', StatusChecks.Pending ])) {\n\t\t\t\treturn StatusChecks.Pending;\n\t\t\t}\n\n\t\t\t// If any of the checks didn't pass, we fail.\n\t\t\tif (_.some(statusResults, [ 'state', StatusChecks.Failed ])) {\n\t\t\t\tthis.logger.log(LogLevel.WARN, `Status checks failed: ${JSON.stringify(statusResults)}`);\n\t\t\t\treturn StatusChecks.Failed;\n\t\t\t}\n\n\t\t\t// Else everything passed.\n\t\t\treturn StatusChecks.Passed;\n\t\t});\n\t}\n\n\t/**\n\t * Determines if VersionBot has already made commits to the PR branch for a version bump.\n\t *\n\t * @param prInfo    The PR to check.\n\t * @returns         A Promise containing 'null' should VersionBot have not already committed, else the commit\n\t *                  message itself.\n\t */\n\tprivate getVersionBotCommits(prInfo: GithubApiTypes.PullRequest): Promise<string | null> {\n\t\tconst owner = prInfo.head.repo.owner.login;\n\t\tconst repo = prInfo.head.repo.name;\n\n\t\t// Get the list of commits for the PR, then get the very last commit SHA.\n\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tsha: prInfo.head.sha\n\t\t\t},\n\t\t\tmethod: this.githubApi.repos.getCommit\n\t\t}).then((headCommit: GithubApiTypes.Commit) => {\n\t\t\tconst commit = headCommit.commit;\n\t\t\tconst files = headCommit.files;\n\n\t\t\tif ((commit.committer.name === process.env.VERSIONBOT_NAME) &&\n\t\t\t_.find(files, (file: GithubApiTypes.CommitFile) => {\n\t\t\t\treturn file.filename === 'CHANGELOG.md';\n\t\t\t})) {\n\t\t\t\treturn commit.message;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t/**\n\t * Finalises a merge should all checks have passed.\n\t *\n\t * @params data    A 'pull_request' event.\n\t * @params prInfo  A pull request.\n\t * @returns        Promise fulfilled when merging has finished.\n\t */\n\tprivate finaliseMerge = (data: GithubApiTypes.PullRequestEvent,\n\tprInfo: GithubApiTypes.PullRequest): Promise<void> => {\n\t\t// We will go ahead and perform a merge if we see VersionBot has:\n\t\t// 1. All of the status checks have passed on the repo\n\t\t// 2. VersionBot has committed something with 'CHANGELOG.md' in it\n\t\tconst head = prInfo.head;\n\t\tconst owner = head.repo.owner.login;\n\t\tconst repo = head.repo.name;\n\n\t\t// We need to exclude the automerge status, as versionbot itself is doing the merge.\n\t\treturn this.checkStatuses(prInfo, {\n\t\t\tincludeContexts: false,\n\t\t\tcontexts: [ StatusAutoMerge.Context ]\n\t\t}).then((checkStatus) => {\n\t\t\tif (checkStatus === StatusChecks.Passed) {\n\t\t\t\t// Get the list of commits for the PR, then get the very last commit SHA.\n\t\t\t\treturn this.getVersionBotCommits(prInfo).then((commitMessage: string | null) => {\n\t\t\t\t\tif (commitMessage) {\n\t\t\t\t\t\t// Ensure that the labeler was authorised. We do this here, else we could\n\t\t\t\t\t\t// end up spamming the PR with errors.\n\t\t\t\t\t\treturn this.retrieveConfiguration({\n\t\t\t\t\t\t\temitter: this.githubEmitter,\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\trepo,\n\t\t\t\t\t\t\t\tpath: RepositoryFilePath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).then((config: VersionBotConfiguration) => {\n\t\t\t\t\t\t\t// If this was a labeling action and there's a config, check to see if there's a maintainers\n\t\t\t\t\t\t\t// list and ensure the labeler was on it.\n\t\t\t\t\t\t\t// This throws an error if not.\n\t\t\t\t\t\t\tif (data.action === 'labeled') {\n\t\t\t\t\t\t\t\tthis.checkValidMaintainer(config, data);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Now we set the automerge context so that we can actually proceed with\n\t\t\t\t\t\t\t// the merge.\n\t\t\t\t\t\t\treturn \tthis.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\tcontext: StatusAutoMerge.Context,\n\t\t\t\t\t\t\t\t\t\tdescription: StatusAutoMerge.Success,\n\t\t\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\t\t\trepo,\n\t\t\t\t\t\t\t\t\t\tsha: head.sha,\n\t\t\t\t\t\t\t\t\t\tstate: 'success'\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmethod: this.githubApi.repos.createStatus,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t// We go ahead and merge.\n\t\t\t\t\t\t\treturn this.mergeToMaster({\n\t\t\t\t\t\t\t\tcommitVersion: commitMessage,\n\t\t\t\t\t\t\t\tpullRequest: prInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t// Report to console that we've merged.\n\t\t\t\t\t\t\tthis.logger.log(LogLevel.INFO, `MergePR: Merged ${owner}/${repo}#${prInfo.number}`);\n\t\t\t\t\t\t}).catch((err: Error) => {\n\t\t\t\t\t\t\t// It's possible in some cases that we have to wait for a service that doesn't actually\n\t\t\t\t\t\t\t// present itself with status info until it's started. Jenkins is an example of this\n\t\t\t\t\t\t\t// which, when queried only responds 'pending' when the build's started.\n\t\t\t\t\t\t\t// In these cases, the compulsory status list won't include the particular service,\n\t\t\t\t\t\t\t// but the merge will notice that not every status on the branch protection has occurred.\n\t\t\t\t\t\t\t// We really don't want to a load of extra calls here, so we instead believe Github and\n\t\t\t\t\t\t\t// check for the standard return message and silently ignore it if present.\n\t\t\t\t\t\t\tif (!_.startsWith(err.message, 'Required status check')) {\n\t\t\t\t\t\t\t\t// We need to set the automerge status back to failure again, so that nobody\n\t\t\t\t\t\t\t\t// tries to merge this by mistake.\n\t\t\t\t\t\t\t\tthis.dispatchToEmitter(this.githubEmitterName, {\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\tcontext: StatusAutoMerge.Context,\n\t\t\t\t\t\t\t\t\t\tdescription: StatusAutoMerge.Pending,\n\t\t\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\t\t\trepo,\n\t\t\t\t\t\t\t\t\t\tsha: head.sha,\n\t\t\t\t\t\t\t\t\t\tstate: 'pending'\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmethod: this.githubApi.repos.createStatus,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t// Finally throw the error.\n\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Strip the PR author from a list of user login string.\n\t *\n\t * @param list         The array of user logins.\n\t * @param pullRequest  The pull request to use as a base.\n\t * @returns            An array containing stripped user logins, or null should there be no valid users.\n\t */\n\tprivate stripPRAuthor(list: string[] | null, pullRequest: GithubApiTypes.PullRequest): string[] | null {\n\t\tconst filteredList = list ? _.filter(list, (reviewer) => reviewer !== pullRequest.user.login) : null;\n\t\treturn (filteredList && (filteredList.length === 0)) ? null : filteredList;\n\t}\n\n\t/**\n\t * Ensures that the merge label was added by a valid maintainer, should a list exist in the repo configuration.\n\t *\n\t * @param config\tThe VersionBot configuration object.\n\t * @param event\t The PR event that triggered this check.\n\t * @throws\t\t  Exception should the maintainer not be valid.\n\t */\n\tprivate checkValidMaintainer(config: VersionBotConfiguration, event: GithubApiTypes.PullRequestEvent): void {\n\t\t// If we have a list of valid maintainers, then we need to ensure that if the `ready-to-merge` label\n\t\t// was added, that it was by one of these maintainers *or* the author of the PR.\n\t\tconst maintainers = (config || {}).maintainers;\n\t\tif (maintainers) {\n\t\t\t// A user is a 'special' maintainer, if all reviews have been approved.\n\t\t\t// Essentially this provides a mechanism for ensuring responsibility.\n\t\t\tmaintainers.push(event.pull_request.user.login);\n\n\t\t\t// Get the user who added the label.\n\t\t\tif (!_.includes(maintainers, event.sender.login)) {\n\t\t\t\tlet errorMessage = `The \\`${MergeLabel}\\` label was not added by an authorised ` +\n\t\t\t\t\t`maintainer or by the PR author. The ${maintainers.length} authorised mergers are:\\n`;\n\t\t\t\t_.each(maintainers, (maintainer) => errorMessage = errorMessage.concat(`* @${maintainer}\\n`));\n\t\t\t\tthrow new Error(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Loops through all of the commits for a PR, ensuring that any required tags are present the\n\t * specified number of times for a PR.\n\t *\n\t * @param allCommits  All of the commits for the PR.\n\t * @param config      The config (if any) for the repository the PR belongs to.\n\t * @returns           An array of MissingTag objects, denoting required tags not on the PR.\n\t */\n\tprivate checkCommitFooterTags(allCommits: GithubApiTypes.Commit[], config: VersionBotConfiguration): MissingTag[] {\n\t\tconst tagDefinitions = (config || {})['required-tags'] || {};\n\t\tconst changeType = 'change-type';\n\t\t// Enumerated strings exist in 2.4, we'll move to those once the framework has.\n\t\tconst tagOccurrences = [ 'all', 'once', 'never' ];\n\t\tconst tagValueFlags = ['i', 'u', 'y', 'g', 'm']; // Last two ignored\n\t\tlet sanitisedDefs: FooterTags = {};\n\t\tlet tagCounts: { [key: string]: number } = {};\n\n\t\t// Filter the list of commits to those not made by VB.\n\t\tconst commits = _.filter(allCommits, (commit) => commit.commit.committer.name !== process.env.VERSIONBOT_NAME);\n\t\t// Get and validate tag configs.\n\t\t_.each(_.mapKeys(tagDefinitions, (_value, key) => key.toLowerCase()), (tag: FooterTag, tagName) => {\n\t\t\tif (tagCounts[tagName]) {\n\t\t\t\tthrow new Error(`More than one occurrence of a required footer tag (${tagName}) found ` +\n\t\t\t\t\t'in configuration');\n\t\t\t}\n\t\t\tif (tag.occurrence) {\n\t\t\t\tif ((typeof tag.occurrence !== 'string') ||\n\t\t\t\t!_.find(tagOccurrences, (occurrence) => tag.occurrence === occurrence)) {\n\t\t\t\t\tthrow new Error(`Invalid occurrence value found for ${tagName} definition`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag.values && tag.flags) {\n\t\t\t\t// Go through each character in the string, ensure that it's in the valid\n\t\t\t\t// flags definition.\n\t\t\t\t_.each(tag.flags, (char) => {\n\t\t\t\t\tif (!_.find(tagValueFlags, (flag) => flag !== char)) {\n\t\t\t\t\t\tthrow new Error(`Invalid RegExp flags specific for ${tagName} definition`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Always use a lowered version of the tag.\n\t\t\ttagCounts[tagName] = 0;\n\n\t\t\t// Add to our sanitised definitions\n\t\t\tsanitisedDefs[tagName] = {\n\t\t\t\toccurrence: tag.occurrence,\n\t\t\t\tvalues: tag.values,\n\t\t\t\tflags: tag.flags\n\t\t\t};\n\t\t});\n\n\t\t// Always add the 'change-type' tag.\n\t\tsanitisedDefs[changeType] = sanitisedDefs[changeType] || {\n\t\t\t\tvalues: '\\s*(patch|minor|major)\\s*',\n\t\t\t\tflags: 'i'\n\t\t};\n\t\ttagCounts[changeType] = tagCounts[changeType] || 0;\n\n\t\t// Go through each commit. For each tag, we determine if it's present or not\n\t\t// and if it matches required values.\n\t\tfor (let commit of commits) {\n\t\t\tconst commitMessage: string = commit.commit.message;\n\n\t\t\t// Split the commits up into lines, and find the last line with any whitespace in.\n\t\t\t// Whilst we tend to ask for:\n\t\t\t//  <header>\n\t\t\t//\n\t\t\t//  <body>\n\t\t\t//\n\t\t\t//  <footer>\n\t\t\t// This code will actually let you get away with:\n\t\t\t//  <header>\n\t\t\t//\n\t\t\t//  <footer>\n\t\t\t// As sometimes a development patch may be self-explanatory in the header alone.\n\t\t\tconst lines = commitMessage.split('\\n');\n\t\t\tconst lastLine = _.findLastIndex(lines, (line) => line.match(/^\\s*$/) );\n\n\t\t\t// If there's no match, then at the very least there's no footer, and the commit\n\t\t\t// is in the wrong format (as there's no text to use in the logs).\n\t\t\tif (lastLine > 0) {\n\t\t\t\t// We should have a line index to join from, now.\n\t\t\t\tlines.splice(0, lastLine);\n\t\t\t\tconst footer = lines.join('\\n');\n\n\t\t\t\t// For each tag, interrogate the footer and determine if the tag is\n\t\t\t\t// present.\n\t\t\t\t// We check for a valid instance of a tag. If there are duplicates,\n\t\t\t\t// potentially with invalid values, we don't flag it. This is primarily\n\t\t\t\t// as we don't know how scripts requiring these tags deal with them\n\t\t\t\t// and have to assume they'll pick a valid tag out.\n\t\t\t\t_.each(sanitisedDefs, (tag, name) => {\n\t\t\t\t\t// RE for the key. We want to capture the entire line\n\t\t\t\t\tconst keyRE = new RegExp(`^${name}:(.*)$`, 'gmi');\n\n\t\t\t\t\t// We need to compile the RE for the value, if it doesn't already exist.\n\t\t\t\t\t// Strip the RE into a body and flags.\n\t\t\t\t\tlet valueRE: RegExp = /.*/;\n\t\t\t\t\tif (tag.values) {\n\t\t\t\t\t\t// Get flag values, we ignore everything apart from 'i'.\n\t\t\t\t\t\t// Ensure we tack the end of input condition on.\n\t\t\t\t\t\tvalueRE = new RegExp(`${tag.values}$`, tag.flags);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Try and match the key.\n\t\t\t\t\t// We want all matches.\n\t\t\t\t\tlet valueMatches = [];\n\t\t\t\t\tlet match = keyRE.exec(footer);\n\t\t\t\t\twhile (match) {\n\t\t\t\t\t\tvalueMatches.push(match[1]);\n\t\t\t\t\t\tmatch = keyRE.exec(footer);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Match the value.\n\t\t\t\t\tfor (let valueMatch of valueMatches) {\n\t\t\t\t\t\t// Try and match the value returned, if any.\n\t\t\t\t\t\tconst valueFound = valueMatch.match(valueRE);\n\t\t\t\t\t\tif (valueFound) {\n\t\t\t\t\t\t\ttagCounts[name]++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// For each of the tags, now determine if the threshold occurrence has occurred.\n\t\tlet tagResults: MissingTag[] = [];\n\t\t_.each(sanitisedDefs, (tag, name) => {\n\t\t\t// Lookup the tag in the tag map\n\t\t\tconst tagCount = tagCounts[name] || 0;\n\t\t\tlet tagsRequired = 0;\n\n\t\t\t// Convert all/never to numbers, appropriately. As we pre-validated\n\t\t\t// tags, we don't need to check for 'never' as that's the only\n\t\t\t// number left.\n\t\t\tif (tag.occurrence !== 'never') {\n\t\t\t\t// No tag occurrence or 'once'.\n\t\t\t\ttagsRequired = 1;\n\n\t\t\t\tif (tag.occurrence === 'all') {\n\t\t\t\t\ttagsRequired = commits.length;\n\t\t\t\t}\n\n\t\t\t\tif (tagCount < tagsRequired) {\n\t\t\t\t\ttagResults.push({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\treason: `Not enough occurrences of ${name} tag found in PR commits`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tagCount > 0) {\n\t\t\t\t\ttagResults.push({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\treason: `The ${name} tag was found when it should not be present in a PR commit`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\treturn tagResults;\n\t}\n\n\t/**\n\t * Reports an error to the console and as a Github comment..\n\t *\n\t * @param error The error to report.\n\t */\n\tprivate reportError(error: VersionBotError): Promise<void> {\n\t\t// Log to console.\n\t\tthis.logger.alert(AlertLevel.ERROR, error.message);\n\n\t\t// Post a comment to the relevant PR, also detailing the issue.\n\t\treturn this.dispatchToEmitter(this.githubEmitterName, {\n\t\t\tdata: {\n\t\t\t\tbody: error.message,\n\t\t\t\tnumber: error.number,\n\t\t\t\towner: error.owner,\n\t\t\t\trepo: error.repo\n\t\t\t},\n\t\t\tmethod: this.githubApi.issues.createComment\n\t\t});\n\t}\n}\n\n/**\n * Creates a new instance of the VersionBot client.\n */\nexport function createBot(): VersionBot {\n\tif (!(process.env.VERSIONBOT_NAME && process.env.VERSIONBOT_EMAIL && process.env.VERSIONBOT_INTEGRATION_ID &&\n\tprocess.env.VERSIONBOT_PEM && process.env.VERSIONBOT_WEBHOOK_SECRET)) {\n\t\tthrow new Error(`'VERSIONBOT_NAME', 'VERSIONBOT_EMAIL', 'VERSIONBOT_INTEGRATION_ID', 'VERSIONBOT_PEM' and ` +\n\t\t\t`'VERSIONBOT_WEBHOOK_SECRET environment variables need setting`);\n\t}\n\n\treturn new VersionBot(process.env.VERSIONBOT_INTEGRATION_ID, process.env.VERSIONBOT_NAME,\n\tprocess.env.VERSIONBOT_EMAIL, process.env.VERSIONBOT_PEM, process.env.VERSIONBOT_WEBHOOK_SECRET);\n}\n"],"sourceRoot":"../../lib"}