{"version":3,"sources":["bots/syncbot.ts"],"names":[],"mappings":";;AAgBA,oCAAoC;AACpC,4BAA4B;AAC5B,kDAE8B;AAS9B,4CAEyB;AACzB,oEAMqC;AAiBrC,aAAqB,SAAQ,iBAAO;IAMhC,YAAY,IAAI,GAAG,SAAS;QACxB,KAAK,CAAC,IAAI,CAAC,CAAC;QANR,eAAU,GAAG,IAAI,GAAG,EAA0B,CAAC;QAC/C,UAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;QAC7D,oBAAe,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAC;QAC1E,mBAAc,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAC;QAI7E,GAAG,CAAC,CAAC,MAAM,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC;YACxE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QACrD,CAAC;IACL,CAAC;IAQO,QAAQ,CAAC,IAAY,EAAE,EAAU,EAAE,IAAwB;QAE/D,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAC9B,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACxC,IAAI,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;QAC3B,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YAEX,QAAQ,CAAC,aAAa,CAAC;gBACnB,MAAM,EAAE,CAAC,qCAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBACtC,cAAc,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,CAAC;gBAC3C,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,IAAI,IAAI,EAAE;aAChC,CAAC,CAAC;QACP,CAAC;IACL,CAAC;IAOO,YAAY,CAAC,IAAY,EAAE,EAAU;QACzC,MAAM,CAAC,CAAC,aAAkC,EAAE,IAAkB;YAE1D,MAAM,OAAO,GAAG,gCAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAExC,EAAE,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;gBAEjF,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC;oBAC5B,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,4CAAuB,CAAC,OAA+B,EAAE,EAAE,CAAC,CAAC,CAAC;gBAC3F,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;oBACpC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,6CAAwB,CAAC,OAAgC,EAAE,EAAE,CAAC,CAAC,CAAC;gBAC9F,CAAC;gBAED,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC,CAAC;YAClE,CAAC;YAED,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7B,CAAC,CAAC;IACN,CAAC;IAMO,YAAY,CAAC,KAA0B;QAE3C,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC;aACjC,IAAI,CAAC,MAAM,IAAI,CAAC,8BAA8B,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;aAC9D,IAAI,CAAC,MAAM,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aAEvD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAA8B,EAAE,QAAQ,CAAC,CAAC;aACjE,IAAI,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;aAElD,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;aAClC,KAAK,CAAC,CAAC,KAAY,KAAK,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IACjE,CAAC;IAMO,aAAa,CAAC,KAA2B;QAE7C,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,QAAQ,CAAC;aACrC,IAAI,CAAC;YACF,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC;iBAC9B,IAAI,CAAC,MAAM,IAAI,CAAC,8BAA8B,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBAC9D,IAAI,CAAC,MAAM,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;iBAEvD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAA+B,EAAE,SAAS,CAAC,CAAC;iBAEnE,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;iBAClC,KAAK,CAAC,CAAC,KAAY,KAAK,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;QAC7D,CAAC,CAAC;aAED,KAAK,CAAC,QAAa,CAAC,CAAC,CAAC;IAC/B,CAAC;IAOO,WAAW,CAAC,KAAY,EAAE,KAAoB;QAElD,MAAM,SAAS,GAAyB;YACpC,MAAM,EAAE,QAAQ;YAChB,OAAO,EAAE,QAAQ;YACjB,OAAO,EAAE,IAAI;YACb,MAAM,EAAE,QAAQ;YAChB,SAAS,EAAE;gBACP,OAAO,EAAE,EAAE;gBACX,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,EAAE;gBACV,IAAI,EAAE,EAAE;aACX;YACD,IAAI,EAAE,KAAK,CAAC,OAAO;YACnB,EAAE,EAAE,KAAK,CAAC,MAAM;YAChB,KAAK,EAAE;gBACH,IAAI,EAAE,KAAK,CAAC,SAAS,CAAC,IAAI;gBAC1B,MAAM,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM;aACjC;YACD,IAAI,EAAE,SAAS;SAClB,CAAC;QAEF,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,MAAM,CAAC;aACnC,IAAI,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aAEjD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,SAAmC,EAAE,SAAS,CAAC,CAAC;aACvE,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;aACtC,KAAK,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;IACvD,CAAC;IAOO,iBAAiB,CAAC,GAAW,EAAE,IAAU;QAE7C,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC3C,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QAED,MAAM,OAAO,GAAG,OAAO,CAAC,eAAe,GAAG,EAAE,CAAC,CAAC;QAC9C,MAAM,OAAO,GAAG,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QACnD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAClC,MAAM,CAAC,OAAO,CAAC;IACnB,CAAC;IAOO,gBAAgB,CAAC,KAAoB,EAAE,IAAc;QAEzD,MAAM,QAAQ,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACvC,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC/B,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,kBAAkB,IAAI,aAAa,CAAC,CAAC,CAAC;QAC1E,CAAC;QAED,MAAM,OAAO,GAAyB;YAClC,MAAM,EAAE,QAAQ;YAChB,OAAO,EAAE,QAAQ;YACjB,OAAO,EAAE,IAAI;YACb,MAAM,EAAE,QAAQ;YAChB,SAAS,EAAE;gBACP,OAAO,EAAE,EAAE;gBACX,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,EAAE;gBACV,IAAI,EAAE,EAAE;aACX;YACD,IAAI,EAAE,eAAe,KAAK,CAAC,MAAM,IAAI,IAAI,IAAI,QAAQ,EAAE;YACvD,EAAE,EAAE,KAAK,CAAC,EAAE;YACZ,KAAK,EAAE;gBACH,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI;gBACtB,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,MAAM;aAC7B;YACD,IAAI,EAAE,SAAS;SAClB,CAAC;QAEF,MAAM,SAAS,GAAyB;YACpC,MAAM,EAAE,QAAQ;YAChB,OAAO,EAAE,QAAQ;YACjB,OAAO,EAAE,IAAI;YACb,MAAM,EAAE,QAAQ;YAChB,SAAS,EAAE;gBACP,OAAO,EAAE,EAAE;gBACX,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,EAAE;gBACV,IAAI,EAAE,EAAE;aACX;YACD,IAAI,EAAE,eAAe,KAAK,CAAC,EAAE,IAAI,IAAI,IAAI,IAAI,EAAE;YAC/C,EAAE,EAAE,KAAK,CAAC,MAAM;YAChB,KAAK,EAAE;gBACH,IAAI,EAAE,KAAK,CAAC,SAAS,CAAC,IAAI;gBAC1B,MAAM,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM;aACjC;YACD,IAAI,EAAE,SAAS;SAClB,CAAC;QAEF,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC;YACf,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,MAAM,CAAC;iBACnC,IAAI,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;iBACjD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,SAAmC,EAAE,SAAS,CAAC,CAAC;YAExE,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,CAAC;iBACjC,IAAI,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;iBAC/C,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,OAAiC,EAAE,SAAS,CAAC,CAAC;SACzE,CAAC,CAAC,MAAM,CAAC,QAAa,CAAC,CAAC,CAAC;IAC9B,CAAC;IAOO,MAAM,CAAC,KAAsB,EAAE,IAA0B;QAE7D,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,EAAE;YACpC,QAAQ,EAAE;gBAEN,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,iCAAY,CAAC,KAAK,CAAC;aAClC;YACD,MAAM,EAAE,KAAK,CAAC,MAAM;SACvB,CAAC;aACD,IAAI,CAAC,CAAC,MAAM;YAET,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC9C,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACP,CAAC;IAMO,UAAU,CAAC,KAAqB;QACpC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,iBAAQ,CAAC,IAAI,EAAE,UAAU,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;IAC5E,CAAC;IAOO,QAAQ,CAAC,KAAqB,EAAE,OAAgB;QACpD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,iBAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;QACtD,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACV,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,iBAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC5C,CAAC;IACL,CAAC;IAOO,8BAA8B,CAAC,KAAoB,EAAE,IAAY;QACrE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC;aACrC,KAAK,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aAC7C,KAAK,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aAC5C,UAAU,CAAC,IAAI,KAAK,CAAC,+CAA+C,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAClG,CAAC;IAOO,sBAAsB,CAAC,KAAoB,EAAE,IAAsB;QACvE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC;aACrC,KAAK,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aAC5C,UAAU,CAAC,IAAI,KAAK,CAAC,qCAAqC,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACxF,CAAC;IAOO,WAAW,CAAC,KAAoB,EAAE,IAAY;QAClD,MAAM,CAAC,IAAI,OAAO,CAAS,CAAC,OAAO;YAE/B,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC;YAC1B,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC;YACpB,MAAM,EAAE,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAEjC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBACrB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;gBACrB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACxB,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;YACrE,CAAC;YAED,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;YAC7C,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACP,CAAC;IAOO,cAAc,CAAC,KAAoB,EAAE,IAAY;QACrD,MAAM,CAAC,IAAI,OAAO,CAAS,CAAC,OAAO;YAE/B,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACzB,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;YACvE,CAAC;YACD,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAC1C,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACP,CAAC;IAOO,aAAa,CAAC,KAAoB,EAAE,IAAsB;QAC9D,MAAM,CAAC,IAAI,OAAO,CAAS,CAAC,OAAO;YAE/B,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC;YACpB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC;gBAC7B,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC9B,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;YACtE,CAAC;YACD,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;YACnD,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5C,CAAC,CAAC,CAAC;IACP,CAAC;IAOO,YAAY,CAAC,KAAoB,EAAE,IAAsB;QAC7D,MAAM,CAAC,IAAI,OAAO,CAAS,CAAC,OAAO;YAE/B,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC;YACpB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC;gBAC5B,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC7B,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;YACrE,CAAC;YACD,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;YAClD,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;IACP,CAAC;IAQO,aAAa,CAAC,KAAoB,EAAE,IAAc,EAAE,eAAuB,CAAC;QAEhF,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,eAAe,KAAK,CAAC,EAAE,IAAI,IAAI,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAEpF,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAC5D,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,KAAuB,EAAE,MAAM,CAAC;aACjE,IAAI,CAAC,CAAC,MAAM;YAET,MAAM,GAAG,GAAG,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACnE,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACxB,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAElB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,YAAY,GAAC,CAAC,CAAC,CAAC;YAC3D,CAAC;YACD,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;QACtE,CAAC,CAAC,CAAC;IACP,CAAC;IAOO,aAAa,CAAC,KAAoB,EAAE,IAAsB;QAE9D,MAAM,SAAS,GAAG,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,IAAI,IAAI,uBAAuB,EAAE,GAAG,CAAC,CAAC;QAEjF,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAC5D,MAAM,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAuB,EAAE,SAAS,CAAC;aAC7E,IAAI,CAAC,CAAC,MAAM;YAET,MAAM,GAAG,GAAG,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YACpF,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACxB,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;YACD,MAAM,IAAI,KAAK,CAAC,kCAAkC,IAAI,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;QAC9E,CAAC,CAAC,CAAC;IACP,CAAC;CACJ;AAhZD,0BAgZC;AAED;IACI,MAAM,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AACjD,CAAC;AAFD,8BAEC","file":"syncbot.js","sourcesContent":["/*\nCopyright 2016-2017 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as Promise from 'bluebird';\nimport * as _ from 'lodash';\nimport {\n    ProcBot\n} from '../framework/procbot';\nimport {\n    MessageService,\n} from '../services/message-service';\nimport {\n    ServiceEvent,\n    ServiceListenerMethod,\n    ServiceRegistration,\n} from '../services/service-types';\nimport {\n    LogLevel,\n} from '../utils/logger';\nimport {\n    initMessageHandleContext,\n    initThreadHandleContext,\n    makeGeneric,\n    makeSpecific,\n    translateTrigger,\n} from '../utils/message-converters';\nimport {\n    HandleContext,\n    MessageContext,\n    MessageHandleContext,\n    MessageReceiptContext,\n    MessageTransmitContext,\n    ReceiptContext,\n    ThreadHandleContext,\n    ThreadReceiptContext,\n    ThreadTransmitContext,\n    TransmitContext,\n} from '../utils/message-types';\n\n/**\n * This is a ProcBot for the synchronisation of communication between services\n */\nexport class SyncBot extends ProcBot {\n    private messengers = new Map<string, MessageService>();\n    private rooms = JSON.parse(process.env.SYNCBOT_ROOMS_TO_SYNCHRONISE);\n    private genericAccounts = JSON.parse(process.env.SYNCBOT_GENERIC_AUTHOR_ACCOUNTS);\n    private systemAccounts = JSON.parse(process.env.SYNCBOT_SYSTEM_MESSAGE_ACCOUNTS);\n\n    constructor(name = 'SyncBot') {\n        super(name);\n        for (const event of JSON.parse(process.env.SYNCBOT_EVENTS_TO_SYNCHRONISE)) {\n            this.register(event.from, event.to, event.event);\n        }\n    }\n\n    /**\n     * This registers an event of interest, ensuring we have relevant structures running\n     * @param from adapter to listen to\n     * @param to adapter to emit to\n     * @param type event type to register\n     */\n    private register(from: string, to: string, type: 'message'|'thread') {\n        // Ensure that the adapters are running\n        this.addServiceListener(from);\n        const listener = this.getListener(from);\n        this.addServiceEmitter(to);\n        if (listener) {\n            // Listen to and handle events\n            listener.registerEvent({\n                events: [translateTrigger(type, from)],\n                listenerMethod: this.createRouter(from, to),\n                name: `${from}_${to}_${type}`,\n            });\n        }\n    }\n\n    /**\n     * Return a function that Promises to route provided events\n     * @param from the name of the listener that generates the events\n     * @param to the name of the emitter that the events are passed through to\n     */\n    private createRouter(from: string, to: string): ServiceListenerMethod {\n        return (_registration: ServiceRegistration, data: ServiceEvent): Promise<void> => {\n            // Convert the raw payload from the listener into a more generic message object\n            const generic = makeGeneric(from, data);\n            // Prevent loops and system messages\n            if (_.intersection([generic.source, generic.genesis], ['system', to]).length === 0) {\n                // Pass handling to more specific methods\n                if (generic.type === 'thread') {\n                    return this.handleThread(initThreadHandleContext(generic as ThreadReceiptContext, to));\n                } else if (generic.type === 'message') {\n                    return this.handleMessage(initMessageHandleContext(generic as MessageReceiptContext, to));\n                }\n                // We do not understand how to handle this message type\n                return Promise.reject(new Error('Event type not understood'));\n            }\n            // We have performed all appropriate routing, ie none\n            return Promise.resolve();\n        };\n    }\n\n    /**\n     * Handle a new thread event, creating and connecting appropriately\n     * @param event details of the thread being synchronised\n     */\n    private handleThread(event: ThreadHandleContext): Promise<void> {\n        // Find details that are required for synchronisation\n        return this.searchPairs(event, 'room')\n            .then(() => this.searchPrivateExistingOrGeneric(event, 'user'))\n            .then(() => this.searchPrivateOrGeneric(event, 'token'))\n            // Create thread and connection entities\n            .then(() => this.create(event as ThreadTransmitContext, 'thread'))\n            .then(() => this.createConnection(event, 'thread'))\n            // Log the event\n            .then(() => this.logSuccess(event))\n            .catch((error: Error) => this.handleError(error, event));\n    }\n\n    /**\n     * Handle a new message event, creating appropriately\n     * @param event details of the message being synchornised\n     */\n    private handleMessage(event: MessageHandleContext): Promise<void> {\n        // Find details that are required for synchronisation\n        return this.searchHistory(event, 'thread')\n            .then(() => {\n                this.searchPairs(event, 'room')\n                .then(() => this.searchPrivateExistingOrGeneric(event, 'user'))\n                .then(() => this.searchPrivateOrGeneric(event, 'token'))\n                // Create the message\n                .then(() => this.create(event as MessageTransmitContext, 'message'))\n                // Log the event\n                .then(() => this.logSuccess(event))\n                .catch((error: Error) => this.handleError(error, event));\n            })\n            // Ignore errors when scrutinising threads without links\n            .catch(() => { /**/ });\n    }\n\n    /**\n     * Report in-app an error with the processing of an event\n     * @param error Error object to be reported on\n     * @param event Event to be reported on\n     */\n    private handleError(error: Error, event: HandleContext): void {\n        // Create a message event to echo with the details\n        const fromEvent: MessageHandleContext = {\n            action: 'create',\n            genesis: 'system',\n            private: true,\n            source: 'system',\n            sourceIds: {\n                message: '',\n                room: '',\n                thread: '',\n                user: '',\n            },\n            text: error.message,\n            to: event.source,\n            toIds: {\n                room: event.sourceIds.room,\n                thread: event.sourceIds.thread,\n            },\n            type: 'message',\n        };\n        // Find the system account details\n        this.searchSystem(fromEvent, 'user')\n        .then(() => this.searchSystem(fromEvent, 'token'))\n        // Report the error\n        .then(() => this.create(fromEvent as MessageTransmitContext, 'message'))\n        .then(() => this.logSuccess(fromEvent))\n        .catch((err) => this.logError(event, err.message));\n    }\n\n    /**\n     * Typeguard and singleton the retrieval of a MessageService\n     * @param key name of the service to retrieve\n     * @param data instantiation data for the service, if required\n     */\n    private getMessageService(key: string, data?: any): MessageService {\n        // Attempt to retrieve and return the existing messenger\n        const retrieved = this.messengers.get(key);\n        if (retrieved) {\n            return retrieved;\n        }\n        // Create, stash and return a new messenger\n        const service = require(`../services/${key}`);\n        const created = service.createMessageService(data);\n        this.messengers.set(key, created);\n        return created;\n    }\n\n    /**\n     * Put a whisper on both threads indicating the connection\n     * @param event details of the connection to form\n     * @param type entities to link, must be thread\n     */\n    private createConnection(event: HandleContext, type: 'thread'): Promise<void> {\n        // Find details of the threads to pair\n        const sourceId = event.sourceIds[type];\n        const toId = event.toIds[type];\n        if (!sourceId || !toId) {\n            return Promise.reject(new Error(`Could not form ${type} connection`));\n        }\n        // Build event for target object to reference source\n        const toEvent: MessageHandleContext = {\n            action: 'create',\n            genesis: 'system',\n            private: true,\n            source: 'system',\n            sourceIds: {\n                message: '',\n                room: '',\n                thread: '',\n                user: '',\n            },\n            text: `Connects to ${event.source} ${type} ${sourceId}`,\n            to: event.to,\n            toIds: {\n                room: event.toIds.room,\n                thread: event.toIds.thread,\n            },\n            type: 'message',\n        };\n        // Build event for source object to reference target\n        const fromEvent: MessageHandleContext = {\n            action: 'create',\n            genesis: 'system',\n            private: true,\n            source: 'system',\n            sourceIds: {\n                message: '',\n                room: '',\n                thread: '',\n                user: '',\n            },\n            text: `Connects to ${event.to} ${type} ${toId}`,\n            to: event.source,\n            toIds: {\n                room: event.sourceIds.room,\n                thread: event.sourceIds.thread,\n            },\n            type: 'message',\n        };\n        // Dispatch these events, simplifying the resolutions\n        return Promise.all([\n            this.searchSystem(fromEvent, 'user')\n            .then(() => this.searchSystem(fromEvent, 'token'))\n            .then(() => this.create(fromEvent as MessageTransmitContext, 'message'))\n            ,\n            this.searchSystem(toEvent, 'user')\n            .then(() => this.searchSystem(toEvent, 'token'))\n            .then(() => this.create(toEvent as MessageTransmitContext, 'message'))\n        ]).reduce(() => { /**/ });\n    }\n\n    /**\n     * Dispatch the creation of an entity to the emitter\n     * @param event Details of the event to be handled\n     * @param type Type of entity to create\n     */\n    private create(event: TransmitContext, type: 'message' | 'thread'): Promise<string> {\n        // Pass the event to the emitter\n        return this.dispatchToEmitter(event.to, {\n            contexts: {\n                // Translating the message event into the specific form for the emitter\n                [event.to]: makeSpecific(event)\n            },\n            source: event.source\n        })\n        .then((retVal) => {\n            // Store and return the created id\n            event.toIds[type] = retVal.response.ids[type];\n            return retVal.response.ids[type];\n        });\n    }\n\n    /**\n     * Put the event onto the console\n     * @param event event to log\n     */\n    private logSuccess(event: MessageContext): void {\n        this.logger.log(LogLevel.INFO, `synced ${event.source}: ${event.text}`);\n    }\n\n    /**\n     * Put the event and optional message onto the console, highlighted\n     * @param event event to log\n     * @param message message, if any, to accompany this\n     */\n    private logError(event: MessageContext, message?: string): void {\n        this.logger.log(LogLevel.WARN, JSON.stringify(event));\n        if (message) {\n            this.logger.log(LogLevel.WARN, message);\n        }\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from private messages, source details or generic\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchPrivateExistingOrGeneric(event: HandleContext, type: 'user'): Promise<string> {\n        return this.searchPrivate(event, type)\n        .catch(() => this.searchExisting(event, type))\n        .catch(() => this.searchGeneric(event, type))\n        .catchThrow(new Error(`Could not find private, existing or generic ${type} for ${event.to}`));\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from private messages or generic\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchPrivateOrGeneric(event: HandleContext, type: 'token' | 'user'): Promise<string> {\n        return this.searchPrivate(event, type)\n        .catch(() => this.searchGeneric(event, type))\n        .catchThrow(new Error(`Could not find private or generic ${type} for ${event.to}`));\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from configured pairs\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchPairs(event: HandleContext, type: 'room'): Promise<string> {\n        return new Promise<string>((resolve) => {\n            // Extract some indexes\n            const from = event.source;\n            const to = event.to;\n            const id = event.sourceIds[type];\n            // Try to find the value specified\n            if (!this.rooms[from] ||\n            !this.rooms[from][id] ||\n            !this.rooms[from][id][to]) {\n                throw new Error(`Could not find paired ${type} for ${event.to}`);\n            }\n            // Mutate using and resolve to the found value\n            event.toIds[type] = this.rooms[from][id][to];\n            resolve(this.rooms[from][id][to]);\n        });\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from the existing\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchExisting(event: HandleContext, type: 'user'): Promise<string> {\n        return new Promise<string>((resolve) => {\n            // Look in the existing object\n            if (!event.sourceIds[type]) {\n                throw new Error(`Could not find existing ${type} for ${event.to}`);\n            }\n            event.toIds[type] = event.sourceIds[type];\n            resolve(event.toIds[type]);\n        });\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from configured generics\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchGeneric(event: HandleContext, type: 'user' | 'token'): Promise<string> {\n        return new Promise<string>((resolve) => {\n            // Try to find the value specified\n            const to = event.to;\n            if (!this.genericAccounts[to] ||\n            !this.genericAccounts[to][type]) {\n                throw new Error(`Could not find generic ${type} for ${event.to}`);\n            }\n            event.toIds[type] = this.genericAccounts[to][type];\n            resolve(this.genericAccounts[to][type]);\n        });\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from the configured system details\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchSystem(event: HandleContext, type: 'user' | 'token'): Promise<string> {\n        return new Promise<string>((resolve) => {\n            // Try to find the value specified\n            const to = event.to;\n            if (!this.systemAccounts[to] ||\n            !this.systemAccounts[to][type]) {\n                throw new Error(`Could not find system ${type} for ${event.to}`);\n            }\n            event.toIds[type] = this.systemAccounts[to][type];\n            resolve(this.systemAccounts[to][type]);\n        });\n    }\n\n    /**\n     * Populate and resolve to the specified search term, from the event history\n     * @param event source of existing details\n     * @param type entity required\n     * @param attemptLeft how many more times to seek the information\n     */\n    private searchHistory(event: HandleContext, type: 'thread', attemptsLeft: number = 3): Promise<string> {\n        // Check the pretext; then capture the id text (roughly speaking include base64, exclude html tag)\n        const findId = new RegExp(`Connects to ${event.to} ${type} ([\\\\w\\\\d-+\\\\/=]+)`, 'i');\n        // Retrieve from the message service search a filtered thread history\n        const messageService = this.getMessageService(event.source);\n        return messageService.fetchThread(event as ReceiptContext, findId)\n        .then((result) => {\n            // If we found any comments from the messageService, reduce them to the first id\n            const ids = result && result.length > 0 && result[0].match(findId);\n            if (ids && ids.length > 0) {\n                event.toIds[type] = ids[1];\n                return ids[1];\n            // Give it more attempts or reject\n            } else if (attemptsLeft > 0) {\n                return this.searchHistory(event, type, attemptsLeft-1);\n            }\n            throw new Error(`Could not find history ${type} for ${event.to}`);\n        });\n    }\n\n    /**\n     * Populate are resolve to the specified search term, from the private message history\n     * @param event source of existing details\n     * @param type entity required\n     */\n    private searchPrivate(event: HandleContext, type: 'token' | 'user'): Promise<string> {\n        // Check the pretext; then capture the id text (roughly speaking include base64, exclude html tag)\n        const findValue = new RegExp(`My ${event.to} ${type} is ([\\\\w\\\\d-+\\\\/=]+)`, 'i');\n        // Retrieve from the message service a filtered private message history\n        const messageService = this.getMessageService(event.source);\n        return messageService.fetchPrivateMessages(event as ReceiptContext, findValue)\n        .then((result) => {\n            // If we found any comments from the messageService, reduce them to the first id\n            const ids = result && result.length > 0 && result[result.length-1].match(findValue);\n            if (ids && ids.length > 1) {\n                event.toIds[type] = ids[1];\n                return ids[1];\n            }\n            throw new Error(`Could not find private message ${type} for ${event.to}`);\n        });\n    }\n}\n\nexport function createBot(): SyncBot {\n    return new SyncBot(process.env.SYNCBOT_NAME);\n}\n"],"sourceRoot":"../../lib"}