{"version":3,"sources":["bots/syncbot.ts"],"names":[],"mappings":";;AAgBA,kDAA+C;AAG/C,aAAqB,SAAQ,iBAAO;IACnC,YAAY,IAAI,GAAG,SAAS;QAC3B,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC,CAAC;QAEnH,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;YACtB,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;QACvD,CAAC;QAED,eAAe,CAAC,aAAa,CAAC;YAC7B,MAAM,EAAE,CAAC,SAAS,CAAC;YACnB,cAAc,EAAE,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;YACzC,IAAI,EAAE,YAAY;SAClB,CAAC,CAAC;IACJ,CAAC;CACD;AAfD,0BAeC;AAED;IACC,MAAM,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAC9C,CAAC;AAFD,8BAEC","file":"syncbot.js","sourcesContent":["/*\nCopyright 2016-2017 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ProcBot } from '../framework/procbot';\n\n// TODO: Implement this whole thing\nexport class SyncBot extends ProcBot {\n\tconstructor(name = 'SyncBot') {\n\t\tsuper(name);\n\t\tconst messageListener = this.addServiceListener('messenger', JSON.parse(process.env.SYNCBOT_LISTENER_CREDENTIALS));\n\n\t\tif (!messageListener) {\n\t\t\tthrow new Error('Could not create Message Listener.');\n\t\t}\n\n\t\tmessageListener.registerEvent({\n\t\t\tevents: ['message'],\n\t\t\tlistenerMethod: console.log.bind(console),\n\t\t\tname: 'consoleLog',\n\t\t});\n\t}\n}\n\nexport function createBot(): SyncBot {\n\treturn new SyncBot(process.env.SYNCBOT_NAME);\n}\n\n/**\n * Just a dump of orphaned code\n */\n\n// /**\n//  * Returns an array of the tokens in a provided context\n//  * @param event  Context to data mine for tokens\n//  */\n// private static extractTokens(event: InterimContext) {\n// \tconst secrets = [];\n// \tif (event.toIds.token) {\n// \t\tsecrets.push(event.toIds.token);\n// \t}\n// \tif (event.sourceIds.token) {\n// \t\tsecrets.push(event.sourceIds.token);\n// \t}\n// \treturn secrets;\n// }\n//\n// // These objects store built objects, typed and indexed, to help minimise object rebuilding\n// private messengers = new Map<string, MessengerService>();\n// private hub: DataHub;\n//\n// /**\n//  * Creates a SyncBot using SYNCBOT_MAPPINGS and SYNCBOT_HUB_SERVICE from the environment.\n//  * @param name  identifier for this bot, defaults to SyncBot.\n//  */\n// constructor(name = 'SyncBot') {\n// \tsuper(name);\n// \t// Register each edge in the mappings array bidirectionally\n// \tconst mappings: FlowDefinition[][] = JSON.parse(process.env.SYNCBOT_MAPPINGS);\n// \tfor(const mapping of mappings) {\n// \t\tlet priorFlow = null;\n// \t\tfor(const focusFlow of mapping) {\n// \t\t\tif(priorFlow) {\n// \t\t\t\tthis.register(priorFlow, focusFlow);\n// \t\t\t\tthis.register(focusFlow, priorFlow);\n// \t\t\t}\n// \t\t\tpriorFlow = focusFlow;\n// \t\t}\n// \t}\n// }\n//\n// /**\n//  * Awaken services and register the event processors.\n//  * @param from  Definition of a flow to listen to.\n//  * @param to    Definition of a flow to emit to.\n//  */\n// private register(from: FlowDefinition, to: FlowDefinition) {\n// \ttry {\n// \t\t// Ensure that the adapters are running\n// \t\tconst fromConstructor = JSON.parse(process.env[`SYNCBOT_${from.service.toUpperCase()}_CONSTRUCTOR_OBJECT`]);\n// \t\tconst toConstructor = JSON.parse(process.env[`SYNCBOT_${to.service.toUpperCase()}_CONSTRUCTOR_OBJECT`]);\n// \t\tthis.addServiceListener(from.service, fromConstructor);\n// \t\tthis.addServiceEmitter(from.service, fromConstructor);\n// \t\tconst listener = this.getListener(from.service);\n// \t\tthis.addServiceEmitter(to.service, toConstructor);\n// \t\tif (listener) {\n// \t\t\t// Listen to and handle events\n// \t\t\tlistener.registerEvent({\n// \t\t\t\tevents: [this.getMessageService(from.service, fromConstructor).translateEventName('message')],\n// \t\t\t\tlistenerMethod: this.createRouter(from, to),\n// \t\t\t\tname: `${from.service}:${from.flow}=>${to.service}:${to.flow}`,\n// \t\t\t});\n// \t\t}\n// \t} catch (error) {\n// \t\tthis.logger.log(\n// \t\t\tLogLevel.WARN,\n// \t\t\t`Problem creating link from ${from.service} to ${to.service}: ${error.message}`,\n// \t\t);\n// \t}\n// }\n//\n// /**\n//  * Create a function that will route a data payload to the specified room.\n//  * @param from  Definition of a flow to listen to.\n//  * @param to    Definition of a flow to emit to.\n//  * @returns function that routes the payload.\n//  */\n// private createRouter(from: FlowDefinition, to: FlowDefinition): ServiceListenerMethod {\n// \t// This function returns a function, watch out!\n// \treturn (_registration: ServiceRegistration, data: ServiceEvent): Promise<void> => {\n// \t\t// Convert the raw payload from the listener into a more generic message object\n// \t\treturn this.getMessageService(from.service).makeGeneric(data).then((generic) => {\n// \t\t\t// Check that the payload is in a flow we care about and not destined for somewhere it already is\n// \t\t\tif (generic.sourceIds.flow === from.flow\n// \t\t\t\t&& _.intersection([generic.source, generic.genesis], ['system', to.service]).length === 0\n// \t\t\t) {\n// \t\t\t\t// Transmute the receipt object into an intermediary form, providing flow id to initialise\n// \t\t\t\tconst event = Messenger.initInterimContext(generic, to.service, {flow: to.flow});\n// \t\t\t\t// Attempt to find a connected thread\n// \t\t\t\treturn this.useConnected(event, 'thread')\n// \t\t\t\t\t.then(() => {\n// \t\t\t\t\t\t// Attempt to find account details for the user\n// \t\t\t\t\t\tthis.useConfiguredOrProvided(event, 'user')\n// \t\t\t\t\t\t\t.then(() => this.useHubOrGeneric(event, 'token'))\n// \t\t\t\t\t\t\t// Attempt to emit the event, massaging it first into a final form\n// \t\t\t\t\t\t\t.then(() => this.create(event as TransmitContext))\n// \t\t\t\t\t\t\t// Emit the status of the synchronise, console and in-app\n// \t\t\t\t\t\t\t.then(() => this.logSuccess(event as TransmitContext))\n// \t\t\t\t\t\t\t.catch((error: Error) => this.handleError(error, event));\n// \t\t\t\t\t})\n// \t\t\t\t\t.catch(() => {\n// \t\t\t\t\t\t// Attempt to find account details for the user\n// \t\t\t\t\t\tthis.useConfiguredOrProvided(event, 'user')\n// \t\t\t\t\t\t\t.then(() => this.useHubOrGeneric(event, 'token'))\n// \t\t\t\t\t\t\t// Attempt to emit the event and record the connection\n// \t\t\t\t\t\t\t.then(() => this.create(event as TransmitContext))\n// \t\t\t\t\t\t\t.then(() => this.createConnection(event, 'thread'))\n// \t\t\t\t\t\t\t// Emit the status of the synchronise, console and in-app\n// \t\t\t\t\t\t\t.then(() => this.logSuccess(event as TransmitContext))\n// \t\t\t\t\t\t\t.catch((error: Error) => this.handleError(error, event));\n// \t\t\t\t\t});\n// \t\t\t}\n// \t\t\t// We have performed all appropriate routing, ie none\n// \t\t\treturn Promise.resolve();\n// \t\t});\n// \t};\n// }\n//\n// /**\n//  * Report an error back to the source of the event.\n//  * @param error  error to report.\n//  * @param event  source event that should be reflected into target context.\n//  */\n// private handleError(error: Error, event: InterimContext): void {\n// \t// Put this on the log service\n// \tthis.logger.log(LogLevel.WARN, error.message);\n// this.logger.log(LogLevel.WARN, JSON.stringify(event), SyncBot.extractTokens(event));\n// // Create a message event to echo with the details\n// const fromEvent: InterimContext = {\n// \taction: MessageAction.Create,\n// \tfirst: false,\n// \tgenesis: 'system',\n// \thidden: true,\n// \tsource: 'system',\n// \tsourceIds: {\n// \t\tflow: '',\n// \t\tmessage: '',\n// \t\tthread: '',\n// \t\tuser: '',\n// \t},\n// \t// Format the report for slight user-friendliness\n// \ttext: `${event.to} reports \\`${error.message}\\``,\n// \t// Reflect the source as the to\n// \tto: event.source,\n// \ttoIds: {\n// \t\tflow: event.sourceIds.flow,\n// \t\tthread: event.sourceIds.thread,\n// \t},\n// };\n// // Find the system account details\n// this.useSystem(fromEvent, 'user')\n// \t.then(() => this.useSystem(fromEvent, 'token'))\n// \t// Report the error\n// \t.then(() => this.create(fromEvent as TransmitContext))\n// \t.then(() => this.logSuccess(fromEvent as TransmitContext))\n// \t.catch((err) => this.logError(err, event));\n// }\n//\n// /**\n//  * Retrieve or create a service that can understand the generic message format.\n//  * @param key   Name of the service to seek.\n//  * @param data  Instantiation data for the service.\n//  * @returns     Object which implements the generic message abstract.\n//  */\n// private getMessageService(key: string, data?: any): Messenger {\n// \t// Attempt to retrieve and return the existing messenger\n// \tconst retrieved = this.messengers.get(key);\n// \tif (retrieved) {\n// \t\treturn retrieved;\n// \t}\n// \t// Create, stash and return a new messenger\n// \tconst service = require(`../services/${key}`);\n// \tconst created = service.createMessageService(data);\n// \tthis.messengers.set(key, created);\n// \treturn created;\n// }\n//\n// /**\n//  * Retrieve or create a data hub that can retrieve a user's data.\n//  * @param key   Name of the hub to seek.\n//  * @param data  Instantiation data for the hub.\n//  * @returns     Object which implements the data hub abstract.\n//  */\n// private getDataHub(key: string, data?: any): DataHub {\n// \tif (!this.hub) {\n// \t\tconst service = require(`../services/${key}`);\n// \t\tthis.hub = service.createDataHub(data);\n// \t}\n// \treturn this.hub;\n// }\n//\n// /**\n//  * Connect two threads with comments about each other.\n//  * @param event  Event with the two threads specified.\n//  * @param type   What to connect, must be thread.\n//  * @returns      Resolves when connection is stored.\n//  */\n// private createConnection(event: InterimContext, type: 'thread'): Promise<void> {\n// \t// Find details of the threads to pair\n// \tconst sourceId = event.sourceIds.thread;\n// const toId = event.toIds.thread;\n// if (!sourceId || !toId) {\n// \treturn Promise.reject(new Error(`Could not form ${type} connection`));\n// }\n// // Create a mutual common object for later tweaks\n// const genericEvent: InterimContext = {\n// \taction: MessageAction.Create,\n// \tfirst: false,\n// \tgenesis: 'system',\n// \thidden: true,\n// \tsource: 'system',\n// \t// System message, so not relevant\n// \tsourceIds: {\n// \t\tflow: '',\n// \t\tmessage: '',\n// \t\tthread: '',\n// \t\tuser: '',\n// \t},\n// \t// These get adjusted before use\n// \ttext: 'duff',\n// \tto: 'duff',\n// \ttoIds: {},\n// };\n// // Clone and tweak to form requests for two services\n// const toEvent = _.cloneDeep(genericEvent);\n// toEvent.text = `[Connects to ${event.source} ${type} ${sourceId}](${event.sourceIds.url})`;\n// toEvent.to = event.to;\n// toEvent.toIds = event.toIds;\n// const fromEvent = _.cloneDeep(genericEvent);\n// fromEvent.text = `[Connects to ${event.to} ${type} ${toId}](${event.toIds.url})`;\n// fromEvent.to = event.source;\n// fromEvent.toIds = event.sourceIds;\n// // Dispatch these events, simplifying the resolutions\n// return Promise.all([\n// \tthis.useSystem(fromEvent, 'user')\n// \t\t.then(() => this.useSystem(fromEvent, 'token'))\n// \t\t.then(() => this.create(fromEvent as TransmitContext))\n// \t\t.then(() => this.logSuccess(fromEvent as TransmitContext))\n// \t,\n// \tthis.useSystem(toEvent, 'user')\n// \t\t.then(() => this.useSystem(toEvent, 'token'))\n// \t\t.then(() => this.create(toEvent as TransmitContext))\n// \t\t.then(() => this.logSuccess(toEvent as TransmitContext))\n// ]).reduce(() => { /**/ });\n// }\n//\n// /**\n//  * Pass a transmission context to the emitter.\n//  * @param event  Standardised transmission context to emit.\n//  * @returns      Promise that will resolve to the id of the created message.\n//  */\n// private create(event: TransmitContext): Promise<string> {\n// \t// Pass the event to the emitter\n// \treturn this.getMessageService(event.to).makeSpecific(event).then((specific) => {\n// \t\treturn this.dispatchToEmitter(event.to, specific)\n// \t\t\t.then((retVal) => {\n// \t\t\t\t// Store and return the created id\n// \t\t\t\tevent.toIds.message = retVal.message;\n// \t\t\t\tevent.toIds.thread = retVal.thread;\n// \t\t\t\tevent.toIds.url = retVal.url;\n// \t\t\t\treturn retVal.message;\n// \t\t\t});\n// \t});\n// }\n//\n// /**\n//  * Record to the console some details from the event.\n//  * @param event  Event to record, will only pass on safe information.\n//  */\n// private logSuccess(event: TransmitContext): void {\n// \tconst output = {source: event.source, title: event.title, text: event.text, target: event.to};\n// this.logger.log(LogLevel.INFO, `Synced: ${JSON.stringify(output)}`);\n// }\n//\n// /**\n//  * This should be called when something really goes wrong, and in-app reports fail.\n//  * @param error  Error to report.\n//  * @param event  Event that caused the error.\n//  */\n// private logError(error: Error, event: InterimContext): void {\n// \t// Do what we can to make this event obvious in the logs\n// \tthis.logger.log(LogLevel.WARN, 'v!!!v');\n// this.logger.log(LogLevel.WARN, error.message);\n// this.logger.log(LogLevel.WARN, JSON.stringify(event), SyncBot.extractTokens(event));\n// this.logger.log(LogLevel.WARN, '^!!!^');\n// }\n//\n// private useHubOrGeneric(event: InterimContext, type: 'token'): Promise<string> {\n// \treturn this.useHub(event, type)\n// \t\t.catch(() => this.useGeneric(event, type))\n// \t\t.catchThrow(new Error(`Could not find hub or generic ${type} for ${event.to}`));\n// }\n//\n// /**\n//  * Use the configuration or the source data to provide the detail requested.\n//  * @param event  Event to scrutinise and mutate.\n//  * @param type   Property to search for, must be 'user'.\n//  * @returns      Resolves to the found property.\n//  */\n// private useConfiguredOrProvided(event: InterimContext, type: 'user'): Promise<string> {\n// \treturn this.useConfigured(event, type)\n// \t\t.catch(() => this.useProvided(event, type))\n// \t\t.catchThrow(new Error(`Could not find configured or provided ${type} for ${event.to}`));\n// }\n//\n// /**\n//  * Use the configuration to provide the detail requested.\n//  * @param event  Event to scrutinise and mutate.\n//  * @param type   Property to search for, must be 'user'.\n//  * @returns      Resolves to the found property.\n//  */\n// private useConfigured(event: InterimContext, type: 'user'): Promise<string> {\n// \ttry {\n// \t\tconst configuredUsernames = JSON.parse(process.env.SYNCBOT_ACCOUNTS_WITH_DIFFERING_USERNAMES);\n// const equivalence = _.find(configuredUsernames, (userDetails: {[key: string]: string}) => {\n// \treturn userDetails[event.source] === event.sourceIds.user;\n// });\n// if (equivalence && equivalence[event.to]) {\n// \tevent.toIds.user = equivalence[event.to];\n// \treturn Promise.resolve(equivalence[event.to]);\n// }\n// return Promise.reject(new Error(`Could not find configured ${type} for ${event.to}`));\n// } catch (error) {\n// \treturn Promise.reject(error);\n// }\n// }\n//\n// /**\n//  * Use the source to provide the detail requested.\n//  * @param event  Event to scrutinise and mutate.\n//  * @param type   Property to search for, must be 'user'.\n//  * @returns      Resolves to the found property.\n//  */\n// private useProvided(event: InterimContext, type: 'user'): Promise<string> {\n// \treturn new Promise<string>((resolve) => {\n// \t\t// Look in the existing object\n// \t\tif (!event.sourceIds[type]) {\n// \t\t\tthrow new Error(`Could not find provided ${type} for ${event.to}`);\n// \t\t}\n// \t\tevent.toIds[type] = event.sourceIds[type];\n// \t\tresolve(event.toIds[type]);\n// \t});\n// }\n//\n// private useGeneric(event: InterimContext, type: 'user'|'token'): Promise<string> {\n// \treturn new Promise<string>((resolve) => {\n// \t\t// Try to find the value specified\n// \t\tconst to = event.to;\n// \t\tconst genericAccounts = JSON.parse(process.env.SYNCBOT_GENERIC_AUTHOR_ACCOUNTS);\n// \t\tif (!genericAccounts[to] || !genericAccounts[to][type]) {\n// \t\t\tthrow new Error(`Could not find generic ${type} for ${event.to}`);\n// \t\t}\n// \t\tevent.toIds[type] = genericAccounts[to][type];\n// \t\tresolve(genericAccounts[to][type]);\n// \t});\n// }\n//\n// /**\n//  * Use the environment SYNCBOT_SYSTEM_MESSAGE_ACCOUNTS to provide the detail requested.\n//  * @param event  Event to scrutinise and mutate.\n//  * @param type   Property to search for, must be 'user' or 'token'.\n//  * @returns      Resolves to the found property.\n//  */\n// private useSystem(event: InterimContext, type: 'user'|'token'): Promise<string> {\n// \treturn new Promise<string>((resolve) => {\n// \t\t// Try to find the value specified\n// \t\tconst to = event.to;\n// \t\tconst systemAccounts = JSON.parse(process.env.SYNCBOT_SYSTEM_MESSAGE_ACCOUNTS);\n// \t\tif (!systemAccounts[to] || !systemAccounts[to][type]) {\n// \t\t\tthrow new Error(`Could not find system ${type} for ${event.to}`);\n// \t\t}\n// \t\tevent.toIds[type] = systemAccounts[to][type];\n// \t\tresolve(systemAccounts[to][type]);\n// \t});\n// }\n//\n// /**\n//  * Use the thread history to provide the detail requested.\n//  * @param event  Event to scrutinise and mutate.\n//  * @param type   Property to search for, must be 'thread'.\n//  * @returns      Resolves to the found property.\n//  */\n// private useConnected(event: InterimContext, type: 'thread'): Promise<string> {\n// \t// Check the pretext; then capture the id text (roughly speaking include base64, exclude html tag)\n// \tconst findBase = `Connects to ${event.to} ${type}`;\n// const findId = new RegExp(`${findBase} ([\\\\w\\\\d-+\\\\/=]+)`, 'i');\n// // Retrieve from the message service search a filtered thread history\n// const messageService = this.getMessageService(event.source);\n// return messageService.fetchNotes(event.sourceIds.thread, event.sourceIds.flow, findId, findBase)\n// \t.then((result) => {\n// \t\t// If we found any comments from the messageService, reduce them to the first id\n// \t\tconst ids = result && result.length > 0 && result[0].match(findId);\n// \t\tif (ids && ids.length > 0) {\n// \t\t\tevent.toIds.thread = ids[1];\n// \t\t\treturn ids[1];\n// \t\t}\n// \t\tthrow new Error(`Could not find connected ${type} for ${event.to}`);\n// \t});\n// }\n//\n// /**\n//  * Use the hub service to provide the detail requested.\n//  * @param event  Event to scrutinise and mutate.\n//  * @param type   Property to search for, must be 'token'.\n//  * @returns      Resolves to the found property.\n//  */\n// private useHub(event: InterimContext, type: 'token'): Promise<string> {\n// \tlet user: string | undefined = undefined;\n// if (event.source === process.env.SYNCBOT_HUB_SERVICE) {\n// \tuser = event.sourceIds.user;\n// } else if (event.to === process.env.SYNCBOT_HUB_SERVICE) {\n// \tuser = event.toIds.user;\n// }\n// if (user) {\n// \ttry {\n// \t\tconst hubName = process.env.SYNCBOT_HUB_SERVICE;\n// \t\tconst hubConstructor = JSON.parse(process.env[`SYNCBOT_${hubName.toUpperCase()}_CONSTRUCTOR_OBJECT`]);\n// \t\treturn this.getDataHub(hubName, hubConstructor).fetchValue(user, `${event.to} ${type}`)\n// \t\t\t.then((value) => {\n// \t\t\t\tevent.toIds[type] = value;\n// \t\t\t\treturn value;\n// \t\t\t})\n// \t\t\t.catch(() => {\n// \t\t\t\tthrow new Error(`Could not find hub ${type} for ${event.to}`);\n// \t\t\t});\n// \t} catch (error) {\n// \t\treturn Promise.reject(error);\n// \t}\n// } else {\n// \treturn Promise.reject(new Error(`Could not find hub ${type} for ${event.to}`));\n// }\n// }\n\n// From Front\n// /**\n//  * Promise to find the comment history of a particular thread.\n//  * @param thread  id of the thread to search.\n//  * @param _room   id of the room in which the thread resides.\n//  * @param filter  Criteria to match.\n//  */\n// public fetchNotes = (thread: string, _room: string, filter: RegExp): Promise<string[]> => {\n// \treturn this.session.conversation.listComments({conversation_id: thread})\n// \t\t.then((comments) => {\n// \t\t\treturn _.filter(comments._results, (value) => {\n// \t\t\t\treturn filter.test(value.body);\n// \t\t\t}).map((value) => {\n// \t\t\t\treturn value.body;\n// \t\t\t});\n// \t\t});\n// }\n// /**\n//  * Find the ID of a user specified by username.\n//  * @param username  Target username to search for.\n//  * @returns         Promise that resolves to the user id.\n//  */\n// private fetchUserId = (username: string): Promise<string|undefined> => {\n// \t// Request a list of all teammates\n// \tconst getTeammates = {\n// \t\theaders: {\n// \t\t\tauthorization: `Bearer ${this.data.token}`\n// \t\t},\n// \t\tjson: true,\n// \t\tmethod: 'GET',\n// \t\turi: 'https://api2.frontapp.com/teammates',\n// \t};\n// \treturn request(getTeammates).then((teammates: {_results: Array<{username: string, id: string}>}) => {\n// \t\t// Resolve to the ID of the first matching teammate\n// \t\tconst teammate = _.find(teammates._results, (eachTeammate) => {\n// \t\t\treturn eachTeammate.username === username;\n// \t\t});\n// \t\tif (teammate) {\n// \t\t\treturn teammate.id;\n// \t\t}\n// \t});\n// }\n// /**\n//  * Attempt to find a recent conversation ID from it's subject line.\n//  * Done by subject because the conversation_reference provided is sometimes junk.\n//  * @param subject       Target subject line to search for.\n//  * @param attemptsLeft  Since conversations take time to propagate this method may recurse.\n//  * @returns             Promise that resolves to the ID of the conversation.\n//  */\n// private findConversation = (subject: string, attemptsLeft: number = 10): Promise<string> => {\n// \t// Find all the recent conversations\n// \treturn this.session.conversation.list().then((response) => {\n// \t\t// Filter these down to matching conversations\n// \t\tconst conversationsMatched = _.filter(response._results, (conversation) => {\n// \t\t\treturn conversation.subject === subject;\n// \t\t});\n// \t\t// Return the most recent, if any\n// \t\tif (conversationsMatched.length > 0) {\n// \t\t\treturn conversationsMatched[0].id;\n// \t\t}\n// \t\t// Recurse up to the specified number of times\n// \t\tif (attemptsLeft > 1) {\n// \t\t\treturn this.findConversation(subject, attemptsLeft - 1);\n// \t\t}\n// \t\tthrow new Error('Could not find relevant conversation.');\n// \t});\n// }\n"],"sourceRoot":"../../lib"}