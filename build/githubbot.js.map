{"version":3,"sources":["githubbot.ts"],"names":[],"mappings":"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","file":"githubbot.js","sourcesContent":["/*\nCopyright 2016 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// The GithubBot is a generic class that any bot that wishes to execute\n// based on Github webhooks can be extended upon.\n// It deals with:\n//  * Handling the scheduling of bot workers for each unique repo\n//  * Adding and removing workers/events as they fire/finalise\n//  * Error/Information logging to known endpoints (TBD)\n//  * Dealing with order of precedence (TBD)\n//\n// The latter may be important for some updates back to Github,\n// so we ensure that if a bot needs to be run after another,\n// if that bot is also running, it's ensured that this occurs.\n\nimport * as Promise from 'bluebird';\nimport * as _ from 'lodash';\nimport * as fs from 'fs';\n\nconst GithubApi = require('github');\nconst hmac = require('crypto');\nconst githubHooks = require('github-webhook-handler');\nconst jwt = require('jsonwebtoken');\nconst request: any = Promise.promisifyAll(require('request'));\n\n// Standard worker method type that all other bots must implement.\nexport type RepoWorkerMethod = (event: string, data: any) => Promise<void>;\n\n// The RepoQueue is important. It's entirely possible we'll receive\n// payloads for the same repository in a space of time that makes\n// servicing them all before receiving the payload for the next\n// impossible. So, we queue them.\n// When fireEvent is called, it looks at the repository that\n// was acted upon and adds it to the relevant queue. It then\n// schedules the worker task to go through the queues until\n// they're exhausted.\n// A separate worker task exists for each repo queue and dies\n// upon exit.\n\n// An entry in a queue used to schedule the next worker and\n// the data to work upon, for a specific repo.\ninterface RepoQueueEntry {\n\tworker: RepoWorkerMethod;\n\tevent: string;\n\tdata: any;\n}\n\n// An event passed from an extended Bot, detailing the event it\n// wished to work due to, the data to work on and the method to use.\nexport interface RepoEvent {\n\tevent: string,\n\trepoData: any,\n\tworkerMethod: RepoWorkerMethod\n}\n\n// The worker class is created for each unique repo that is seen.\n// This ensures that multiple repos can be operated on in parallel,\n// but operations only occur in series for each unique repo.\nclass RepoWorker {\n\tprivate repositoryName: string;\n\tprivate parentList: RepoWorker[];\n\tprivate queue: RepoQueueEntry[] = [];\n\n\tconstructor(repoName: string, parentList: RepoWorker[]) {\n\t\tthis.repositoryName = repoName;\n\t\tthis.parentList = parentList;\n\t\tthis.parentList.push(this);\n\t}\n\n\tget repoName(): string {\n\t\treturn this.repositoryName;\n\t}\n\n\t// Add a new event and worker method to the queue for this repo.\n\taddEvent(event: string, data: string, worker: RepoWorkerMethod): void {\n\t\tthis.queue.push({ event, data, worker });\n\t\t// If this is a new worker, ensure it operates.\n\t\tif (this.queue.length === 1) {\n\t\t\tthis.runWorker();\n\t\t}\n\t}\n\n\t// Run as many workers as are queued. Do this atomically, in FIFO order.\n\tprivate runWorker(): void {\n\t\t// Get the next thing from the queue.\n\t\tconst entry = <RepoQueueEntry>this.queue.shift();\n\t\tconst self: this = this;\n\n\t\t// Run worker, proceed to next worker.\n\t\tentry.worker(entry.event, entry.data)\n\t\t.then(() => {\n\t\t\tif (this.queue.length > 0) {\n\t\t\t\tprocess.nextTick(this.runWorker);\n\t\t\t} else {\n\t\t\t\t// Unlink ourselves from our parent list.\n\t\t\t\tself.parentList.splice(_.findIndex(self.parentList, self));\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface GithubCall {\n\towner: string,\n\trepo: string\n};\n\nexport interface GithubPRCall extends GithubCall {\n\tnumber: number\n};\n\nclass GithubAccess {\n\tprivate integrationId: number;\n\tprivate jwt: string;\n\tprivate user: number;\n\tprivate token: string;\n\tprivate _githubApi: any;\n\n\tconstructor(integration: number) {\n\t\tthis.integrationId = integration;\n\n\t\t// The `github` module is a bit behind the preview API. We may have to override\n\t\t// some of the methods here (PR review comments for a start).\n\t\tthis._githubApi = new GithubApi({\n\t\t\t//debug: true,\n\t\t\tprotocol: 'https',\n\t\t\thost: 'api.github.com',\n\t\t\theaders: {\n\t\t\t\t'Accept': 'application/vnd.github.black-cat-preview+json'\n\t\t\t\t// We *hope* that the above overrides all previews. As otherwise we're going to\n\t\t\t\t// have to start interleaving header media types for different calls. :-/\n\t\t\t\t//'Accept': 'application/vnd.github.machine-man-preview+json'\n\t\t\t},\n\t\t\tPromise: Promise,\n\t\t\ttimeout: 5000\n\t\t});\n\t}\n\n\tpublic get githubApi() {\n\t\treturn this._githubApi;\n\t}\n\n\t// If user is passed, then the Integration is authenticating as a installation user\n\tpublic authenticate(user?: number): Promise<void> {\n\t\t// Initialise JWTs\n\t\t//const privatePem = fs.readFileSync(`${__dirname}/../procbots.pem`);\n\t\tconst privatePem = new Buffer(process.env.PROCBOTS_PEM, 'base64').toString();\n\n\t\tconst payload = {\n\t\t\tiat: Math.floor((Date.now() / 1000)),\n\t\t\texp: Math.floor((Date.now() / 1000)) + (10 * 60),\n\t\t\tiss: this.integrationId\n\t\t};\n\t\tconsole.log(payload);\n\t\tconst jwToken = jwt.sign(payload, privatePem, { algorithm: 'RS256' });\n\n\t\t//console.log(`curl -i -XGET -H \"Authorization: Bearer ${jwToken}\" -H \"Accept: application/vnd.github.machine-man-preview+json\" https://api.github.com/integration/installations`);\n\t\t//console.log(`curl -i -XPOST -H \"Authorization: Bearer ${jwToken}\" -H \"Accept: application/vnd.github.machine-man-preview+json\" https://api.github.com/installations/5806/access_tokens`);\n\n\t\tconst installationsOpts = {\n\t\t\turl: 'https://api.github.com/integration/installations',\n\t\t\theaders: {\n\t\t\t\t'Authorization': `Bearer ${jwToken}`,\n\t\t\t\t'Accept': 'application/vnd.github.machine-man-preview+json',\n\t\t\t\t'User-Agent': 'request'\n\t\t\t},\n\t\t\tjson: true\n\t\t};\n\n\t\tif (user) {\n\t\t\tthis.user = user;\n\t\t}\n\t\treturn request.getAsync(installationsOpts).then((res: any) => {\n\t\t\tconst installations: any[] = res.body;\n\t\t\t// Get the URL for the token.\n\t\t\tconst tokenUrl = installations[0].access_tokens_url;\n\n\t\t\t// Request new token.\n\t\t\t//\n\t\t\t// Whilst I don't think it does, because of the way the docs are written:\n\t\t\t// This may need to change when more than one repo can be used by the integration.\n\t\t\t// What needs to happen here is each separate repository needs its own version of the\n\t\t\t// 'github' API so that the token matches it correctly.\n\t\t\t// As we have a slot for every repo in the Repo, it means that for each RepoWorker\n\t\t\t// we need to Authenticate. So we move this from GithubBot to RepoWorker constructor.\n\t\t\t// Then, every time we see a new repo we authenticate to the correct one.\n\t\t\t// The docs are not very clear about this.\n\t\t\tconst tokenOpts: any = {\n\t\t\t\turl: tokenUrl,\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Authorization': `Bearer ${jwToken}`,\n\t\t\t\t\t'Accept': 'application/vnd.github.machine-man-preview+json',\n\t\t\t\t\t'User-Agent': 'request'\n\t\t\t\t},\n\t\t\t\tjson: true\n\t\t\t};\n\t\t\tif (user) {\n\t\t\t\ttokenOpts.body = { user_id: user };\n\t\t\t}\n\n\t\t\treturn request.postAsync(tokenOpts);\n\t\t}).then((res: any) => {\n\t\t\t// We also need to take into account the expiry date, which will require a new kickoff.\n\t\t\tconst tokenDetails = res.body;\n\n\t\t\tthis._githubApi.authenticate({\n\t\t\t\ttype: 'token',\n\t\t\t\ttoken: tokenDetails.token\n\t\t\t});\n\n\t\t\t// For debug.\n\t\t\tconsole.log(`token for manual fiddling is: ${tokenDetails.token}`);\n\t\t\tconsole.log('Base curl command:');\n\t\t\tconsole.log(`curl -XGET -H \"Authorisation: token ${tokenDetails.token}\" -H \"Accept: application/vnd.github.black-cat-preview+json\" https://api.github.com/`)\n\t\t});\n\t}\n\n\t// Make a 'github' API call. We explicitly wrap this so that any authentication error\n\t// can result in re-authentication before moving on.\n\tpublic makeCall = (method: any, options: any, retries: 6) =>{\n\t\tlet badCreds = false;\n\t\tlet retriesLeft: number = retries || 3;\n\n\t\t// We need a new Promise here, as we might need to do retries.\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst runApi = () => {\n\t\t\t\tretriesLeft -= 1;\n\n\t\t\t\t// Run the method.\n\t\t\t\treturn method(options).catch((err: Error) => {\n\t\t\t\t\t// We only try and reauthenticate once, else we throw.\n\t\t\t\t\tif ((err.message === 'Bad credentials') && !badCreds) {\n\t\t\t\t\t\tbadCreds = true;\n\t\t\t\t\t\t// Re-authenticate, then try again.\n\t\t\t\t\t\treturn runApi();\n\t\t\t\t\t} else if (retriesLeft === 0) {\n\t\t\t\t\t\t// No more retries, just reject.\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there's more retries, try again in 5 seconds.\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\trunApi();\n\t\t\t\t\t\t}, 5000);\n\t\t\t\t\t}\n\t\t\t\t}).then((data: any) => {\n\t\t\t\t\t// Hurrah, all data back safely.\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// Kick it off.\n\t\t\trunApi();\n\t\t});\n\t}\n}\n\n// Main GithubBot.\nexport class GithubBot {\n\tprotected _botname: string = 'GithubBot';\n\tprotected _runsAfter: string[] = [];\n\tprotected _github: any;\n\tprivate _webhooks: string[] = [];\n\tprivate repoWorkers: RepoWorker[] = [];\n\n\t// Takes a set of webhook types that the bot is interested in.\n\tconstructor(webhooks: string[], integration: any) {\n\t\tthis._webhooks = webhooks;\n\t\tthis._github = new GithubAccess(integration);\n\t}\n\n\t// Get the name of the bot.\n\tget botname(): string {\n\t\treturn this._botname;\n\t}\n\n\t// Get the hooks we're interested in.\n\tget webhooks(): string[] {\n\t\treturn this._webhooks;\n\t}\n\n\t// TBD.\n\tget runsAfter(): string[] {\n\t\treturn this._runsAfter;\n\t}\n\n\t// Queue a new event from an extended Bot.\n\tprotected queueEvent(event: RepoEvent): void {\n\t\tif (!event.workerMethod) {\n\t\t\tconsole.log(`WorkerMethod must be passed into the Githubbot.firedEvent() method`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Look at the repo. If there's no repo, we can't actually do anything with this.\n\t\tif (!event.repoData) {\n\t\t\tconsole.log('Could not find a payload or a repository for the event');\n\t\t\treturn;\n\t\t}\n\n\t\t// Look through all the RepoWorkers, is there one already that exists for\n\t\t// this repo?\n\t\t// If not, create a new worker.\n\t\tlet repoEntry = _.find(this.repoWorkers, (entry: RepoWorker) => {\n\t\t\tif (entry.repoName === event.repoData.full_name) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\n\t\t// If no entry found, create one.\n\t\tif (!repoEntry) {\n\t\t\trepoEntry = new RepoWorker(event.repoData.full_name, this.repoWorkers);\n\t\t}\n\n\t\t// Now add the event to the found/created repo worker.\n\t\trepoEntry.addEvent(event.event, event.repoData, event.workerMethod);\n\n\t\treturn;\n\t}\n\n\t// Not a pure virtual, but not callable directly from GithubBot.\n\tpublic firedEvent(event: string, repoEvent: any): void {\n\t\tconsole.log('This method should not be called directly.');\n\t}\n}\n\n// Create a new GithubBot.\nexport function createBot(): GithubBot {\n\treturn new GithubBot([], 0);\n}"],"sourceRoot":"../lib"}