{"version":3,"sources":["githubbot.ts"],"names":[],"mappings":"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","file":"githubbot.js","sourcesContent":["/*\nCopyright 2016 Resin.io\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport * as ProcBot from './procbot';\nimport * as Promise from 'bluebird';\nimport * as _ from 'lodash';\nimport * as fs from 'fs';\nimport * as jwt from 'jsonwebtoken';\nimport { AlertLevel } from './procbot';\n\n// The GithubAPI Promise implies built-in ES6 Promises. Therefore when assigning\n// the Promise to use as Bluebird, VS Code reports an error. Need a good\n// fix for this that doesn't require type declarations?\nconst GithubApi = require('github');\nconst request: any = Promise.promisifyAll(require('request'));\n\n// Github Events --------------------------------------------------------------\n// These provide the current bare minimum definitions for child Procbots working with them.\nexport interface PullRequestEvent {\n    action: string,\n    pull_request: {\n        number: number,\n        head: {\n            repo: {\n                name: string;\n                owner: {\n                    login: string;\n                }\n            },\n            sha: string\n        }\n    }\n};\n\nexport interface PullRequestReviewEvent {\n    action: string,\n    pull_request: {\n        number: number,\n        head: {\n            repo: {\n                name: string;\n                owner: {\n                    login: string;\n                }\n            },\n            sha: string\n        }\n    }\n};\n\n\n// Github API -----------------------------------------------------------------\n// These provide the current bare minimum definitions for child Procbots working with them.\nexport interface CommitFile {\n    filename: string,\n};\n\nexport interface Commit {\n    commit: {\n        committer: {\n            name: string\n        }\n        message: string\n    },\n    files: CommitFile[],\n    sha: string\n};\n\nexport interface Review {\n    state: string\n};\n\nexport interface Merge {\n    sha: string\n};\n\nexport interface Tag {\n    sha: string\n};\n\nexport interface PullRequest {\n    head: {\n        ref: string\n    }\n};\n\nexport interface Blob {\n    sha: string\n};\n\nexport interface TreeEntry {\n    path: string,\n    mode: string,\n    type: string,\n    sha: string,\n    url?: string,\n    size?: number\n};\n\nexport interface Tree {\n    sha: string,\n    url: string,\n    tree: TreeEntry[]\n};\n\n// GithubBot ------------------------------------------------------------------\n\n// The GithubAction  defines an action, which is passed to a WorkerMethod should all of\n// the given pre-requisites be applicable.\n// At least one event. For each additional event, this is considered an 'OR' comparator.\n// eg. 'pull_request' OR 'pull_request_review' event\n// Labels, on the other hand, are ANDed together.\n// eg. 'flow/ready-to-merge' AND 'flow/in-review' (trigger or suppression)\n//\n// In the future, some sort of comparator language might be useful, eg:\n// and: [\n//  {\n//      or: [\n//          {\n//              name: <eventType>\n//              value: 'pull_request',\n//              op: eq | neq;\n//          },\n//          ...\n//      }]\n//  ,\n//  ...\n//  }\n// ]\nexport interface GithubAction {\n    name: string,\n    events: string[],\n    triggerLabels?: string[],\n    suppressionLabels?: string[]\n}\n\n// The Register interface is passed to the GithubBot.register method to register\n// for callback when the appropriate events and labels are received.\nexport interface GithubActionRegister extends GithubAction {\n    workerMethod: GithubActionMethod\n}\n\n// A GithubActionMethod is the method that will be used to process an event.\nexport type GithubActionMethod = <T>(action: GithubAction, data: T) => Promise<void>;\n\n// Main GithubBot.\nexport class GithubBot extends ProcBot.ProcBot<string> {\n    private integrationId: number;\n    private user: number;\n    private eventTriggers: GithubActionRegister[] = [];\n    protected githubApi: any;\n\n    // Takes a set of webhook types that the bot is interested in.\n    // Registrations can be passed in on bot creation, or registered/deregistered later.\n    // However, 'baked in' registrations are not available for deregistration.\n    constructor(integration: number) {\n        super();\n        this._botname = 'GithubBot';\n        this.integrationId = integration;\n\n        // The getWorker method is an overload for generic context types.\n        // In the case of the GithubBot, it's the name of the repo (a string).\n        this.getWorker = (event: ProcBot.WorkerEvent): ProcBot.Worker<string> => {\n            const context = event.data.repository.full_name;\n            let worker: ProcBot.Worker<string> | undefined = this.workers.get(context);\n\n            // If we already have a worker for this context (the repo name), return it.\n            if (worker) {\n                return worker;\n            }\n\n            // Create new Worker using the repo name as context.\n            worker = new ProcBot.Worker(context, this.workers);\n\n            // Note that workers are self-regualting; that is, they will remove themselves\n            // from the Map once there are no more queued tasks.\n            this.workers.set(context, worker);\n\n            return worker;\n        };\n\n        // The `github` module is a bit behind the preview API. We may have to override\n        // some of the methods here (PR review comments for a start).\n        this.githubApi = new GithubApi({\n            //debug: true,\n            protocol: 'https',\n            host: 'api.github.com',\n            headers: {\n                // This is the current voodoo to allow all API calls to succeed.\n                'Accept': 'application/vnd.github.black-cat-preview+json'\n            },\n            Promise: Promise,\n            timeout: 5000\n        });\n    }\n\n    // Create a new event triggered action for the list. We don't check signatures, so someone\n    // could potentially register twice. If they do that, they get called twice.\n    // Currently we do not allow deregistering. Potentially there may be a need in the future,\n    // but any created bot has to have actions 'baked in' atm.\n    protected registerAction(action: GithubActionRegister) {\n        this.eventTriggers.push(action);\n    }\n\n    // FiredEvent needs to be called for any derived child bot (and usually it doesn't need\n    // to be implemented by them if all that's required is direct Github action handling).\n    // Override if any sort of check or state is required in the child (state not advised!).\n    public firedEvent(event: string, repoEvent: any) {\n        // Push this directly onto the queue.\n        this.queueEvent({\n            event: event,\n            data: repoEvent,\n            workerMethod: this.handleGithubEvent\n        });\n    }\n\n    // Handles all Github events to trigger actions, should the parameters meet those\n    // registered.\n    protected handleGithubEvent = (event: string, data: any) => {\n        // Determine the head to use based on the event.\n        const labelHead = () => {\n            // Note that a label event itself is not in itself a labelled type,\n            // so we don't check for it.\n            switch (event) {\n                case 'issue_comment':\n                case 'issues':\n                    return {\n                        repo: data.repository,\n                        number: data.issue.number\n                    };\n\n                case 'pull_request':\n                case 'pull_request_review':\n                case 'pull_request_review_comment':\n                    return {\n                        repo: data.repository,\n                        number: data.pull_request.number\n                    };\n\n                default:\n                    return;\n            }\n        };\n\n        _.forEach(this.eventTriggers, (action: GithubActionRegister) => {\n            // Is the event one of the type that triggers the action?\n            if (_.includes(action.events, event)) {\n                let labelEvent: any | void = labelHead();\n                let labelPromise = Promise.resolve();\n\n                // Are there any labels (trigger or suppression) set on the action?\n                if ((action.triggerLabels || action.suppressionLabels) && labelEvent) {\n                    // OK, so we've got a label event, so we now have to get all the labels\n                    // for the appropriate issue.\n                    labelPromise = this.gitCall(this.githubApi.issues.getIssueLabels, {\n                        owner: labelEvent.repo.owner.login,\n                        repo: labelEvent.repo.name,\n                        number: labelEvent.number\n                    })\n\n                }\n                labelPromise.then((labels: any[] | void) => {\n                    // If there are some labels, then we process them.\n                    if (labels) {\n                        const foundLabels: string[] = labels.map((label: any) => {\n                            return label.name;\n                        })\n\n                        // First, are all the suppression labels present?\n                        if (action.suppressionLabels &&\n                            (_.intersection(action.suppressionLabels, foundLabels).length === action.suppressionLabels.length)) {\n                            this.log(ProcBot.LogLevel.INFO, `Dropping '${action.name}' as suppression labels are all present`)\n                            return;\n                        }\n                        // Secondly, are all the trigger labels present?\n                        if (action.triggerLabels &&\n                            (_.intersection(action.triggerLabels, foundLabels).length !== action.triggerLabels.length)) {\n                            this.log(ProcBot.LogLevel.INFO, `Dropping '${action.name}' as not all trigger labels are present`)\n                            return;\n                        }\n                    }\n\n                    return action.workerMethod(<GithubAction>action, data).catch((err: Error) => {\n                        // We log the error, so that it's saved and matches up with any Alert.\n                        this.alert(ProcBot.AlertLevel.ERROR, `Error thrown: ${err.message}`);\n                    });\n                });\n            }\n        });\n\n        return Promise.resolve();\n    }\n\n    // Authenticates against the Github API and Installation environment (for Integrations).\n    protected authenticate(): Promise<void> {\n        // Initialise JWTs\n        const privatePem = new Buffer(process.env.PROCBOTS_PEM, 'base64').toString();\n        const payload = {\n            iat: Math.floor((Date.now() / 1000)),\n            exp: Math.floor((Date.now() / 1000)) + (10 * 60),\n            iss: this.integrationId\n        };\n        const jwToken = jwt.sign(payload, privatePem, { algorithm: 'RS256' });\n        const installationsOpts = {\n            url: 'https://api.github.com/integration/installations',\n            headers: {\n                'Authorization': `Bearer ${jwToken}`,\n                'Accept': 'application/vnd.github.machine-man-preview+json',\n                'User-Agent': 'request'\n            },\n            json: true\n        };\n\n        return request.getAsync(installationsOpts).then((res: any) => {\n            // Get the URL for the token.\n            const installations: any[] = res.body;\n            const tokenUrl = installations[0].access_tokens_url;\n\n            // Request new token.\n            const tokenOpts: any = {\n                url: tokenUrl,\n                method: 'POST',\n                headers: {\n                    'Authorization': `Bearer ${jwToken}`,\n                    'Accept': 'application/vnd.github.machine-man-preview+json',\n                    'User-Agent': 'request'\n                },\n                json: true\n            };\n\n            return request.postAsync(tokenOpts);\n        }).then((res: any) => {\n            // We also need to take into account the expiry date, which will require a new kickoff.\n            const tokenDetails = res.body;\n\n            this.githubApi.authenticate({\n                type: 'token',\n                token: tokenDetails.token\n            });\n\n            // For debug.\n            this.log(ProcBot.LogLevel.DEBUG, `token for manual fiddling is: ${tokenDetails.token}`);\n            this.log(ProcBot.LogLevel.DEBUG, 'Base curl command:');\n            this.log(ProcBot.LogLevel.DEBUG, `curl -XGET -H \"Authorisation: token ${tokenDetails.token}\" -H \"Accept: application/vnd.github.black-cat-preview+json\" https://api.github.com/`)\n        });\n    }\n\n    // Make a 'github' API call. We explicitly wrap this so that any authentication error\n    // can result in re-authentication before moving on.\n    protected gitCall = (method: any, options: any, retries?: number): Promise<any> => {\n        let badCreds = false;\n        let retriesLeft: number = retries || 3;\n\n        // We need a new Promise here, as we might need to do retries.\n        return new Promise((resolve, reject) => {\n            const runApi = () => {\n                retriesLeft -= 1;\n\n                // Run the method.\n                return method(options).catch((err: Error) => {\n                    // We only try and reauthenticate once, else we throw.\n                    if ((err.message === 'Bad credentials') && !badCreds) {\n                        badCreds = true;\n                        // Re-authenticate, then try again.\n                        return this.authenticate().then(() => {\n                            return runApi();\n                        });\n                    } else if (retriesLeft === 0) {\n                        // No more retries, just reject.\n                        reject(err);\n                    } else {\n                        // If there's more retries, try again in 5 seconds.\n                        setTimeout(() => {\n                            runApi();\n                        }, 5000);\n                    }\n                }).then((data: any) => {\n                    resolve(data);\n                });\n            };\n\n            // Kick it off.\n            runApi();\n        });\n    }\n}\n\n// Create a new GithubBot. Or rather, don't.\nexport function createBot(): GithubBot {\n    throw new Error('GithubBot is not a valid instantiation of a ProcBot');\n}"],"sourceRoot":"../lib"}