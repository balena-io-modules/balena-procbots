{"version":3,"sources":["RASP/services/service-listener-generator.ts"],"names":[],"mappings":";;AAGA;IAMW,MAAM,CAAC,gBAAgB,CAAC,GAAuB,EAAE,YAAwB;QAE5E,EAAE,CAAC,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,CAAC;YAC9B,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC,CAAC;QACtF,CAAC;QACD,MAAM,YAAY,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC;QACjC,YAAY,CAAC,cAAc,GAAG;YAC1B,IAAI,GAAsB;YAC1B,IAAI,EAAE,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,IAAI,GAAG,wBAAwB;SACtE,CAAC;IACN,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,IAAwB,EAAE,YAAwB;QAG5E,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,CAAC;YAC/B,YAAY,CAAC,cAAc,GAAG,EAAE,CAAC;QACrC,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;YAC1B,YAAY,CAAC,SAAS,GAAG,EAAE,CAAC;QAChC,CAAC;QACD,EAAE,CAAC,CAAC,YAAY,CAAC,cAAc,IAAI,YAAY,CAAC,cAAc,CAAC,IAAI,MAAyB,CAAC,CAAC,CAAC;YAC3F,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC;gBAC7B,IAAI,EAAE,YAAY,CAAC,cAAc,CAAC,IAAI;gBACtC,IAAI,GAA2B;aAClC,CAAC,CAAC;YACH,YAAY,CAAC,SAAS,CAAC,IAAI,CAA4B,YAAY,CAAC,cAAc,CAAC,CAAC;QACxF,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,gBAAgB,CAAC,GAAuB,EAAE,YAAwB;QAC5E,MAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;QACtB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACR,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;QAC1D,CAAC;QACD,EAAE,CAAC,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,CAAC;YAC9B,YAAY,CAAC,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC;QAC5C,CAAC;IACL,CAAC;CACJ;AA7CD,4DA6CC","file":"service-listener-generator.js","sourcesContent":["import { AddListenerContext, ServiceNameContext } from '../Antlr/RASPParser';\nimport { BotDetails, ClassType, ServiceListenerDefinition, ServiceType } from '../parser-types';\n\nexport class ServiceListenerGenerator {\n    // RASP listener methods.\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterAddListener(ctx: AddListenerContext, botStructure: BotDetails): void {\n        // New ServiceDefinition\n        if (botStructure.currentService) {\n            throw new Error('There is already a service definition being constructed, error');\n        }\n        const assignedName = ctx.ALPHA();\n        botStructure.currentService = {\n            type: ServiceType.Listener,\n            name: (assignedName) ? assignedName.text : 'defaultServiceListener',\n        };\n    }\n\n    public static exitAddListener(_ctx: AddListenerContext, botStructure: BotDetails): void {\n        // Verify we have enough information, if required, then push this service listener onto\n        // the list of listeners and create a new variable name.\n        if (!botStructure.classVariables) {\n            botStructure.classVariables = [];\n        }\n        if (!botStructure.listeners) {\n            botStructure.listeners = [];\n        }\n        if (botStructure.currentService && botStructure.currentService.type === ServiceType.Listener) {\n            botStructure.classVariables.push({\n                name: botStructure.currentService.name,\n                type: ClassType.ServiceListener\n            });\n            botStructure.listeners.push(<ServiceListenerDefinition>botStructure.currentService);\n        }\n    }\n\n    public static enterServiceName(ctx: ServiceNameContext, botStructure: BotDetails): void {\n        const name = ctx.text;\n        if (!name) {\n            throw new Error('Correct service name was not found');\n        }\n        if (botStructure.currentService) {\n            botStructure.currentService.name = name;\n        }\n    }\n}\n"],"sourceRoot":"../../../lib"}