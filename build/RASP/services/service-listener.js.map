{"version":3,"sources":["RASP/services/service-listener.ts"],"names":[],"mappings":";;AAGA;IAMW,MAAM,CAAC,gBAAgB,CAAC,GAAuB,EAAE,GAAe;QAEnE,EAAE,CAAC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC,CAAC;QACtF,CAAC;QACD,MAAM,YAAY,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC;QACjC,GAAG,CAAC,cAAc,GAAG;YACjB,IAAI,GAAsB;YAC1B,IAAI,EAAE,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,IAAI,GAAG,wBAAwB;SACtE,CAAC;IACN,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,IAAwB,EAAE,GAAe;QAGnE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;YACtB,GAAG,CAAC,cAAc,GAAG,EAAE,CAAC;QAC5B,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;YACjB,GAAG,CAAC,SAAS,GAAG,EAAE,CAAC;QACvB,CAAC;QACD,EAAE,CAAC,CAAC,GAAG,CAAC,cAAc,IAAI,GAAG,CAAC,cAAc,CAAC,IAAI,MAAyB,CAAC,CAAC,CAAC;YACzE,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC;gBACpB,IAAI,EAAE,GAAG,CAAC,cAAc,CAAC,IAAI;gBAC7B,IAAI,GAA2B;aAClC,CAAC,CAAC;YACH,GAAG,CAAC,SAAS,CAAC,IAAI,CAA4B,GAAG,CAAC,cAAc,CAAC,CAAC;YAClE,GAAG,CAAC,cAAc,GAAG,SAAS,CAAC;QACnC,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,gBAAgB,CAAC,GAAuB,EAAE,GAAe;QACnE,MAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;QACtB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACR,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;QAC1D,CAAC;QACD,EAAE,CAAC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;YACrB,GAAG,CAAC,cAAc,CAAC,WAAW,GAAG,IAAI,CAAC;QAC1C,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,+BAA+B,CAAC,GAAsC,EAAE,GAAe;QAGjG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,cAAc,IAAI,CAAC,CAAC,GAAG,CAAC,mBAAmB,CAAC,IAAI,MAAyB,CAAC,CAAC,CAAC,CAAC;YAClF,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;QAC7D,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,8BAA8B,CAAC,GAAsC,EAAE,GAAe;IAGpG,CAAC;CAEJ;AA5DD,4DA4DC","file":"service-listener.js","sourcesContent":["import { AddListenerContext, ServiceListenerConstructorContext, ServiceNameContext } from '../Antlr/RASPParser';\nimport { BotDetails, ClassType, ServiceDefinition, ServiceListenerDefinition, ServiceType } from '../parser-types';\n\nexport class ServiceListenerGenerator {\n    // RASP listener methods.\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterAddListener(ctx: AddListenerContext, bot: BotDetails): void {\n        // New ServiceDefinition\n        if (bot.currentService) {\n            throw new Error('There is already a service definition being constructed, error');\n        }\n        const assignedName = ctx.ALPHA();\n        bot.currentService = {\n            type: ServiceType.Listener,\n            name: (assignedName) ? assignedName.text : 'defaultServiceListener',\n        };\n    }\n\n    public static exitAddListener(_ctx: AddListenerContext, bot: BotDetails): void {\n        // Verify we have enough information, if required, then push this service listener onto\n        // the list of listeners and create a new variable name.\n        if (!bot.classVariables) {\n            bot.classVariables = [];\n        }\n        if (!bot.listeners) {\n            bot.listeners = [];\n        }\n        if (bot.currentService && bot.currentService.type === ServiceType.Listener) {\n            bot.classVariables.push({\n                name: bot.currentService.name,\n                type: ClassType.ServiceListener\n            });\n            bot.listeners.push(<ServiceListenerDefinition>bot.currentService);\n            bot.currentService = undefined;            \n        }\n    }\n\n    public static enterServiceName(ctx: ServiceNameContext, bot: BotDetails): void {\n        const name = ctx.text;\n        if (!name) {\n            throw new Error('Correct service name was not found');\n        }\n        if (bot.currentService) {\n            bot.currentService.serviceName = name;\n        }\n    }\n\n    public static enterServiceListenerConstructor(ctx: ServiceListenerConstructorContext, bot: BotDetails): void {\n        // We look at the name of the service here, and then expect the following constructor to match.\n        // If it does not, then # there may be trouble ahead...\n        if (!bot.currentService || !(bot.currentRegistration.type === ServiceType.Listener)) {\n            throw new Error('Service should be Listener but is not');\n        }\n    }\n\n    public static exitServiceListenerConstructor(ctx: ServiceListenerConstructorContext, bot: BotDetails): void {\n        // Verify all of our parameters, and ensure it's valid.\n\n    }\n\n}\n"],"sourceRoot":"../../../lib"}