{"version":3,"sources":["RASP/services/service.ts"],"names":[],"mappings":"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","file":"service.js","sourcesContent":["import * as _ from 'lodash';\nimport { AddEmitterContext, AddListenerContext, SetServiceAsContext, ServiceNameContext } from '../Antlr/RASPParser';\nimport { BotDetails, ClassType, ServiceDefinition, ServiceType } from '../parser-types';\nimport { ExtRASPListener } from '../parser';\n\nexport class ServiceGenerator {\n    public static currentServiceConstructor: any;\n    public static constructorKey: string;\n\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterAddService(ctx: AddListenerContext | AddEmitterContext, bot: BotDetails): void {\n        const type = (ctx instanceof AddListenerContext) ? ServiceType.Listener : ServiceType.Emitter;\n        const defaultName = (type === ServiceType.Listener) ? 'defaultServiceListener' : 'defaultServiceEmitter';\n        // New ServiceDefinition\n        if (bot.currentService) {\n            throw new Error('There is already a service definition being constructed, error');\n        }\n        let assignedName = '';\n        const serviceAsContext = ctx.setServiceAs();\n        if (serviceAsContext) {\n            assignedName = serviceAsContext.ID().text;\n        }\n        bot.currentService = {\n            type,\n            name: assignedName ? assignedName : defaultName\n        };\n    }\n\n    public static exitAddService(_ctx: AddListenerContext | AddEmitterContext, bot: BotDetails): void {\n        // Verify we have enough information, if required, then push this service listener onto\n        // the list of listeners and create a new variable name.\n        if (!bot.currentService) {\n            return;\n        }\n\n        const type = bot.currentService.type;\n        let list: ServiceDefinition[] | undefined;\n        if (!bot.classVariables) {\n            bot.classVariables = [];\n        }\n\n        // Add the service to the right list.\n        if (type === ServiceType.Listener) {\n            if (!bot.listeners) {\n                bot.listeners = [];\n            }\n            list = bot.listeners;\n        } else if (type === ServiceType.Emitter) {\n            if (!bot.emitters) {\n                bot.emitters = [];\n            }\n            list = bot.emitters;\n        }\n        if (!list) {\n            throw new Error('Incorrect service type!');\n        }\n\n        // Push service on.\n        list.push(bot.currentService);\n\n        // Ensure we have a new class variable with the right name.\n        bot.classVariables.push({\n            name: bot.currentService.name,\n            type: ClassType.ServiceListener\n        });\n\n        // Reset the current service.\n        bot.currentService = undefined;\n    }\n\n    public static enterServiceName(ctx: ServiceNameContext, bot: BotDetails): void {\n        const name = ctx.text;\n        if (!name) {\n            throw new Error('Correct service name was not found');\n        }\n        if (bot.currentService) {\n            bot.currentService.serviceName = name;\n        }\n    }\n\n/*\n    public static enterServiceConstructor(_ctx: ServiceConstructorContext, bot: BotDetails): void {\n        // Create new constructor object.\n        const newConstructor = {};\n\n        // If we have no stack (empty array), then we push this on.\n        if (bot.currentService && !bot.currentService.constructDetails) {\n            bot.currentService.constructDetails = newConstructor;\n        } else {\n            // Use the previous keyname to create a new nested constructor.\n            ServiceGenerator.currentServiceConstructor[ServiceGenerator.constructorKey] = newConstructor;\n        }\n        ServiceGenerator.currentServiceConstructor = newConstructor;\n    }\n\n    // All of the types are unique, so we actually have to ensure that only one per constructor is present\n    public static enterServiceConstructorPair(ctx: ServiceConstructorPairContext, bot: BotDetails): void {\n        const conObj = ServiceGenerator.currentServiceConstructor;\n        const text = ctx.text.split(':');\n        const key = text[0];\n        const value = text[1];\n        ServiceGenerator.constructorKey = key;\n\n        // If this is a nested child, we return here as we'll be caught further down.\n        if (!_.startsWith(value, '{')) {\n            // Else just assign.\n            conObj[key] = value;\n        }\n    }\n*/\n}\n\nexport function addListenerMethods(listener: ExtRASPListener, definition: BotDetails): void {\n    listener['enterAddListener'] = _.partial(ServiceGenerator.enterAddService, _, definition);\n    listener['exitAddListener'] = _.partial(ServiceGenerator.exitAddService, _, definition);\n\n    listener['enterAddEmitter'] = _.partial(ServiceGenerator.enterAddService, _, definition);\n    listener['exitAddEmitter'] = _.partial(ServiceGenerator.exitAddService, _, definition);\n    listener['enterServiceName'] = _.partial(ServiceGenerator.enterServiceName, _, definition);    \n}\n"],"sourceRoot":"../../../lib"}