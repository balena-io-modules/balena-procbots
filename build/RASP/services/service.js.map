{"version":3,"sources":["RASP/services/service.ts"],"names":[],"mappings":";;AAKA;CAuGC;AAvGD,4CAuGC","file":"service.js","sourcesContent":["import { AddEmitterContext, AddListenerContext, ServiceNameContext } from '../Antlr/RASPParser';\nimport { BotDetails, ClassType, ServiceDefinition, ServiceType } from '../parser-types';\nimport { GetSingletonFromRulePotentials } from '../helpers';\nimport * as _ from 'lodash';\n\nexport class ServiceGenerator {\n    public static currentServiceConstructor: any;\n    public static constructorKey: string;\n\n/*\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterAddService(ctx: AddListenerContext | AddEmitterContext, bot: BotDetails): void {\n        const type = (ctx instanceof AddListenerContext) ? ServiceType.Listener : ServiceType.Emitter;\n        const defaultName = (type === ServiceType.Listener) ? 'defaultServiceListener' : 'defaultServiceEmitter';\n        // New ServiceDefinition\n        if (bot.currentService) {\n            throw new Error('There is already a service definition being constructed, error');\n        }\n        const assignedName = ctx.ALPHA();\n        bot.currentService = {\n            type,\n            name: assignedName ? assignedName.text : defaultName\n    }\n\n    public static exitAddService(_ctx: AddListenerContext | AddEmitterContext, bot: BotDetails): void {\n        // Verify we have enough information, if required, then push this service listener onto\n        // the list of listeners and create a new variable name.\n        if (!bot.currentService) {\n            return;\n        }\n\n        const type = bot.currentService.type;\n        let list: ServiceDefinition[] | undefined;\n        if (!bot.classVariables) {\n            bot.classVariables = [];\n        }\n\n        // Add the service to the right list.\n        if (type === ServiceType.Listener) {\n            if (!bot.listeners) {\n                bot.listeners = [];\n            }\n            list = bot.listeners;\n        } else if (type === ServiceType.Emitter) {\n            if (!bot.emitters) {\n                bot.emitters = [];\n            }\n            list = bot.emitters;\n        }\n        if (!list) {\n            throw new Error('Incorrect service type!');\n        }\n\n        // Push service on.\n        list.push(bot.currentService);\n\n        // Ensure we have a new class variable with the right name.\n        bot.classVariables.push({\n            name: bot.currentService.name,\n            type: ClassType.ServiceListener\n        });\n\n        // Reset the current service.\n        bot.currentService = undefined;\n    }\n\n    public static enterServiceName(ctx: ServiceNameContext, bot: BotDetails): void {\n        const name = ctx.text;\n        if (!name) {\n            throw new Error('Correct service name was not found');\n        }\n        if (bot.currentService) {\n            bot.currentService.serviceName = name;\n        }\n    }\n\n    public static enterServiceConstructor(_ctx: ServiceConstructorContext, bot: BotDetails): void {\n        // Create new constructor object.\n        const newConstructor = {};\n\n        // If we have no stack (empty array), then we push this on.\n        if (bot.currentService && !bot.currentService.constructDetails) {\n            bot.currentService.constructDetails = newConstructor;\n        } else {\n            // Use the previous keyname to create a new nested constructor.\n            ServiceGenerator.currentServiceConstructor[ServiceGenerator.constructorKey] = newConstructor;\n        }\n        ServiceGenerator.currentServiceConstructor = newConstructor;\n    }\n\n    // All of the types are unique, so we actually have to ensure that only one per constructor is present\n    public static enterServiceConstructorPair(ctx: ServiceConstructorPairContext, bot: BotDetails): void {\n        const conObj = ServiceGenerator.currentServiceConstructor;\n        const text = ctx.text.split(':');\n        const key = text[0];\n        const value = text[1];\n        ServiceGenerator.constructorKey = key;\n\n        // If this is a nested child, we return here as we'll be caught further down.\n        if (!_.startsWith(value, '{')) {\n            // Else just assign.\n            conObj[key] = value;\n        }\n    }\n*/\n}\n"],"sourceRoot":"../../../lib"}