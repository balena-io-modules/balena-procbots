{"version":3,"sources":["RASP/services/service.ts"],"names":[],"mappings":"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","file":"service.js","sourcesContent":["import { AddEmitterContext, AddListenerContext, ServiceConstructorContext, ServiceConstructorPairContext, ServiceNameContext } from '../Antlr/RASPParser';\nimport { BotDetails, ClassType, ServiceDefinition, ServiceType } from '../parser-types';\nimport { GetSingletonFromRulePotentials } from '../helpers';\nimport * as _ from 'lodash';\n\nexport class ServiceGenerator {\n    public static currentServiceConstructor: any;\n    public static constructorKey: string;\n\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterAddService(ctx: AddListenerContext | AddEmitterContext, bot: BotDetails): void {\n        const type = (ctx instanceof AddListenerContext) ? ServiceType.Listener : ServiceType.Emitter;\n        const defaultName = (type === ServiceType.Listener) ? 'defaultServiceListener' : 'defaultServiceEmitter';\n        // New ServiceDefinition\n        if (bot.currentService) {\n            throw new Error('There is already a service definition being constructed, error');\n        }\n        const assignedName = ctx.ALPHA();\n        bot.currentService = {\n            type,\n            name: assignedName ? assignedName.text : defaultName\n        };\n    }\n\n    public static exitAddService(_ctx: AddListenerContext | AddEmitterContext, bot: BotDetails): void {\n        // Verify we have enough information, if required, then push this service listener onto\n        // the list of listeners and create a new variable name.\n        if (!bot.currentService) {\n            return;\n        }\n\n        const type = bot.currentService.type;\n        let list: ServiceDefinition[] | undefined;\n        if (!bot.classVariables) {\n            bot.classVariables = [];\n        }\n\n        // Add the service to the right list.\n        if (type === ServiceType.Listener) {\n            if (!bot.listeners) {\n                bot.listeners = [];\n            }\n            list = bot.listeners;\n        } else if (type === ServiceType.Emitter) {\n            if (!bot.emitters) {\n                bot.emitters = [];\n            }\n            list = bot.emitters;\n        }\n        if (!list) {\n            throw new Error('Incorrect service type!');\n        }\n\n        // Push service on.\n        list.push(bot.currentService);\n\n        // Ensure we have a new class variable with the right name.\n        bot.classVariables.push({\n            name: bot.currentService.name,\n            type: ClassType.ServiceListener\n        });\n\n        // Reset the current service.\n        bot.currentService = undefined;\n    }\n\n    public static enterServiceName(ctx: ServiceNameContext, bot: BotDetails): void {\n        const name = ctx.text;\n        if (!name) {\n            throw new Error('Correct service name was not found');\n        }\n        if (bot.currentService) {\n            bot.currentService.serviceName = name;\n        }\n    }\n\n    public static enterServiceConstructor(_ctx: ServiceConstructorContext, bot: BotDetails): void {\n        // Create new constructor object.\n        const newConstructor = {};\n\n        // If we have no stack (empty array), then we push this on.\n        if (bot.currentService && !bot.currentService.constructDetails) {\n            bot.currentService.constructDetails = newConstructor;\n        } else {\n            // Use the previous keyname to create a new nested constructor.\n            ServiceGenerator.currentServiceConstructor[ServiceGenerator.constructorKey] = newConstructor;\n        }\n        ServiceGenerator.currentServiceConstructor = newConstructor;\n    }\n\n    // All of the types are unique, so we actually have to ensure that only one per constructor is present\n    public static enterServiceConstructorPair(ctx: ServiceConstructorPairContext, bot: BotDetails): void {\n        const conObj = ServiceGenerator.currentServiceConstructor;\n        const text = ctx.text.split(':');\n        const key = text[0];\n        const value = text[1];\n        ServiceGenerator.constructorKey = key;\n\n        // If this is a nested child, we return here as we'll be caught further down.\n        if (!_.startsWith(value, '{')) {\n            // Else just assign.\n            conObj[key] = value;\n        }\n    }\n}\n"],"sourceRoot":"../../../lib"}