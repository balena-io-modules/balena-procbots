{"version":3,"sources":["RASP/services/github.ts"],"names":[],"mappings":";;AAEA,wCAAkD;AAIlD;IAQW,MAAM,CAAC,8BAA8B,CAAC,IAAsC,EAAE,IAAgB;QAEjG,0BAA0B,CAAC,kBAAkB,GAAG,EAAE,CAAC;IACvD,CAAC;IAEM,MAAM,CAAC,6BAA6B,CAAC,GAAqC,EAAE,GAAe;QAC9F,EAAE,CAAC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;YACrB,GAAG,CAAC,cAAc,CAAC,WAAW,GAAG,0BAA0B,CAAC,kBAAkB,CAAC;YAC/E,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QACpC,CAAC;IACL,CAAC;IAGM,MAAM,CAAC,iCAAiC,CAAC,GAAyC,EAAE,GAAe;QACtG,8BAAoB,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,EAAE,0BAA0B,CAAC,kBAAkB,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;QACjG,8BAAoB,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,EAAE,0BAA0B,CAAC,kBAAkB,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;IACtG,CAAC;IAEM,MAAM,CAAC,gBAAgB,CAAC,GAAuB,EAAE,GAAe;QACnE,0BAA0B,CAAC,kBAAkB,CAAC,KAAK,GAAG,EAAE,CAAC;IAC7D,CAAC;IAEM,MAAM,CAAC,kBAAkB,CAAC,GAA0B,EAAE,GAAe;QACxE,8BAAoB,CAAC,OAAO,EAAE,GAAG,CAAC,IAAI,EAAE,0BAA0B,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;QACxG,8BAAoB,CAAC,QAAQ,EAAE,GAAG,CAAC,IAAI,EAAE,0BAA0B,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;QACzG,8BAAoB,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,EAAE,0BAA0B,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC;IAC5G,CAAC;CACJ;AAnCD,gEAmCC","file":"github.js","sourcesContent":["import { GithubAppLoginContext, GithubLoginContext, GithubListenerConstructorContext, GithubListenerConstructorTypeContext, ServiceNameContext } from '../Antlr/RASPParser';\nimport { BotDetails, ClassType, ServiceDefinition, ServiceListenerDefinition, ServiceType } from '../parser-types';\nimport { MatchAssignByKeyword } from '../helpers';\n\nimport * as _ from 'lodash';\n\nexport class GithubConstructorGenerator {\n    public static serviceConstructor: any;\n\n    // RASP listener methods.\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterGithubListenerConstructor(_ctx: GithubListenerConstructorContext, _bot: BotDetails): void {\n        // Create new Service\n        GithubConstructorGenerator.serviceConstructor = {};\n    }\n\n    public static exitGithubListenerConstructor(ctx: GithubListenerConstructorContext, bot: BotDetails): void {\n        if (bot.currentService) {\n            bot.currentService.constructor = GithubConstructorGenerator.serviceConstructor;\n            console.log(bot.currentService);\n        }\n    }\n\n    // All of the types are unique, so we actually have to ensure that only one per constructor is present\n    public static exitGithubListenerConstructorType(ctx: GithubListenerConstructorTypeContext, bot: BotDetails): void {\n        MatchAssignByKeyword('port', ctx.text, GithubConstructorGenerator.serviceConstructor, ctx.INT());\n        MatchAssignByKeyword('path', ctx.text, GithubConstructorGenerator.serviceConstructor, ctx.path());\n    }\n\n    public static enterGithubLogin(ctx: GithubLoginContext, bot: BotDetails): void {\n        GithubConstructorGenerator.serviceConstructor.login = {};\n    }\n\n    public static exitGithubAppLogin(ctx: GithubAppLoginContext, bot: BotDetails): void {\n        MatchAssignByKeyword('appId', ctx.text, GithubConstructorGenerator.serviceConstructor.login, ctx.INT());\n        MatchAssignByKeyword('secret', ctx.text, GithubConstructorGenerator.serviceConstructor.login, ctx.HEX());\n        MatchAssignByKeyword('pem', ctx.text, GithubConstructorGenerator.serviceConstructor.login, ctx.ALPHA());\n    }\n}\n"],"sourceRoot":"../../../lib"}