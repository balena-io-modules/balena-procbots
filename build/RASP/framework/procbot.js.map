{"version":3,"sources":["RASP/framework/procbot.ts"],"names":[],"mappings":";;AAAA,4BAA4B;AAK5B;IAMW,MAAM,CAAC,kBAAkB,CAAC,GAAyB,EAAE,YAAwB;IACpF,CAAC;IAEM,MAAM,CAAC,iBAAiB,CAAC,GAAyB,EAAE,YAAwB;QAC/E,YAAY,CAAC,OAAO,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC;IACzC,CAAC;CACJ;AAZD,4CAYC;AAED,4BAAmC,QAAyB,EAAE,UAAsB;IAChF,QAAQ,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;IAC/F,QAAQ,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,iBAAiB,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;AACjG,CAAC;AAHD,gDAGC","file":"procbot.js","sourcesContent":["import * as _ from 'lodash';\nimport { BotDefinitionContext } from '../Antlr/RASPParser';\nimport { BotDetails } from '../parser-types';\nimport { ExtRASPListener } from '../parser';\n\nexport class ProcBotGenerator {\n    // RASP listener methods.\n    // The idea here is to generate required TS code on the fly for RASP definitions.\n    // It looks at the contexts and then fills in all required data as it goes. To achieve this,\n    // it fills in the ongoing bot interface so that other listeners can get a full picture of\n    // the structure of the bot.\n    public static enterBotDefinition(ctx: BotDefinitionContext, botStructure: BotDetails): void {\n    }\n\n    public static exitBotDefinition(ctx: BotDefinitionContext, botStructure: BotDetails): void {\n        botStructure.botName = ctx.ID().text;\n    }\n}\n\nexport function addListenerMethods(listener: ExtRASPListener, definition: BotDetails): void {\n    listener['enterBotDefinition'] = _.partial(ProcBotGenerator.enterBotDefinition, _, definition);\n    listener['exitBotDefinition'] = _.partial(ProcBotGenerator.exitBotDefinition, _, definition);\n}"],"sourceRoot":"../../../lib"}