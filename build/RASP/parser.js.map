{"version":3,"sources":["RASP/parser.ts"],"names":[],"mappings":";;AAAA,uCAAkF;AAClF,oCAAoC;AACpC,iDAA8C;AAC9C,mDAA6E;AAE7E,mEAAgE;AAIhE,uCAAyC;AAKzC,yBAAyB;AAEzB,MAAM,UAAU,GAAe,EAAE,CAAC;AAUlC;CAGC;AAHD,0CAGC;AAGD,MAAM,QAAQ,GAAG,EAAE,CAAC,YAAY,CAAC,iDAAiD,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;AAC1G,MAAM,WAAW,GAAG,IAAI,2BAAgB,CAAC,QAAQ,CAAC,CAAC;AAEnD,IAAI,KAAK,GAAG,IAAI,qBAAS,CAAC,WAAW,CAAC,CAAC;AACvC,IAAI,WAAW,GAAG,IAAI,4BAAiB,CAAC,KAAK,CAAC,CAAC;AAC/C,IAAI,MAAM,GAAG,IAAI,uBAAU,CAAC,WAAW,CAAC,CAAC;AACzC,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC;AAC7B,MAAM,CAAC,YAAY,GAAG,IAAI,4BAAiB,EAAE,CAAC;AAG9C,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;AACzB,MAAM,QAAQ,GAAG,IAAI,eAAe,EAAE,CAAC;AAGvC,sBAAY,CAAC,SAAS,EAAE,CAAC,EAAE,KAAK,EAAE,CAAE,OAAO,CAAE,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK;IAGtD,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,IAAY;QACnC,IAAI,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QACpC,EAAE,CAAC,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC,CAAC;YACrC,eAAe,CAAC,kBAAkB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC7D,CAAC;IACL,CAAC,CAAC,CAAC;AACP,CAAC,CAAC,CAAC,IAAI,CAAC;IAEJ,iCAAe,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC7C,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC","file":"parser.js","sourcesContent":["import { ANTLRInputStream, CommonTokenStream, BailErrorStrategy } from 'antlr4ts';\nimport * as Promise from 'bluebird';\nimport { RASPLexer } from './Antlr/RASPLexer';\nimport { RASPParser, RequestServiceEventsContext } from './Antlr/RASPParser';\nimport { RASPListener } from './Antlr/RASPListener';\nimport { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';\n//import { ParserRuleContext } from 'antlr4ts/ParserRuleContext';\n//import { ParseTreeListener } from 'antlr4ts/tree/ParseTreeListener';\n//import { RuleNode } from 'antlr4ts/tree/RuleNode';\nimport { FindAllFiles } from './helpers';\nimport { BotDetails } from './parser-types';\nimport { ProcBotGenerator } from './framework/procbot';\nimport { ServiceGenerator } from './services/service';\nimport * as _ from 'lodash';\nimport * as fs from 'fs';\n\nconst definition: BotDetails = {};\n\n// This is a bit.. well. We implement a RASPListener which knows nothing\n// about any of the grammar it needs to listen to.\n// We then dynamically trawl through all of the subdirectories that make up\n// our grammar types, and call 'addListenerMethods' on each of those modules.\n// This will add all of the required methods to the listener, which is then\n// instanced and starts a parse.\n// It's got several downsides, but a wonderful upside is we can just add new\n// listener modules/methods and not have to update this file.\nexport class ExtRASPListener implements RASPListener {\n    // Yes, yes. I should be shot.\n    [method: string]: object;\n}\n\n// Create the lexer and parser\nconst fileData = fs.readFileSync('/Work/git/resin-procbots/fortuneNoComments.rasp', { encoding: 'utf8' });\nconst inputStream = new ANTLRInputStream(fileData);\n\nlet lexer = new RASPLexer(inputStream);\nlet tokenStream = new CommonTokenStream(lexer);\nlet parser = new RASPParser(tokenStream);\nparser.buildParseTree = true;\nparser.errorHandler = new BailErrorStrategy();\n\n// Parse the input, where `compilationUnit` is whatever entry point you defined\nlet tree = parser.init();\nconst listener = new ExtRASPListener();\n\n// Add all of the required methods dynamically.\nFindAllFiles(__dirname, 1, '.js', [ 'Antlr' ]).then((files) => {\n    // Require them, and if they have an addListenerMethods method, call it\n    // on the parser.\n    return Promise.map(files, (file: string) => {\n        let parserExtension = require(file);\n        if (parserExtension.addListenerMethods) {\n            parserExtension.addListenerMethods(listener, definition);\n        }\n    });\n}).then(() => {\n    // Let's go!\n    ParseTreeWalker.DEFAULT.walk(listener, tree);\n    console.log(definition);\n});\n\n"],"sourceRoot":"../../lib"}