{"version":3,"sources":["RASP/expressions/expr.ts"],"names":[],"mappings":"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","file":"expr.js","sourcesContent":["import * as _ from 'lodash';\nimport { ExprContext } from '../Antlr/RASPParser';\nimport { ArithmeticExpressionGenerator } from './arithmetic';\nimport { BotDetails, Expression, ExpressionOp } from '../parser-types';\nimport { ExtRASPListener } from '../parser';\n\nexport class ExpressionGenerator implements Expression {\n\tpublic type: ExpressionOp;\n\tpublic value: any;\n\tpublic parent: Expression | undefined;\n\n\tpublic static enterExpr(ctx: ExprContext, botStructure: BotDetails): void {\n\t\t// Only do something here if it's an actual expression or a final value atom.\n\t\t// For all other expressions that relate to other rules, we skip and let that\n\t\t// rule explicitly deal with it.\n\n\t\t// This needs to check all of the other types of expression and drive them appropriately.\n\t\t// To start with, we do the atoms, which are the final types.\n\t\tconst atomNumber = ctx.NUMBER();\n\t\tconst atomString = ctx.STRING();\n\t\tconst atomBoolean = ctx.BOOLEAN();\n\t\tconst addition = ctx.ADDED() && ctx.TO();\n\t\tconst subtraction = ctx.SUBTRACTED() && ctx.BY();\n\t\tconst multiplication = ctx.MULTIPLIED() && ctx.BY();\n\t\tconst division = ctx.DIVIDED() && ctx.BY();\n\n\t\tif (atomNumber) {\n\t\t\tconst atomExpr = new ExpressionGenerator();\n\t\t\tatomExpr.parent = botStructure.currentExpression;\n\t\t\tatomExpr.type = ExpressionOp.NUMBER;\n\t\t\tatomExpr.value = atomNumber.text;\n\t\t\tbotStructure.currentExpression = atomExpr;\n\t\t} else if (atomString) {\n\t\t\tconst atomExpr = new ExpressionGenerator();\n\t\t\tatomExpr.parent = botStructure.currentExpression;\n\t\t\tatomExpr.type = ExpressionOp.STRING;\n\t\t\tatomExpr.value = atomString.text;\n\t\t\tbotStructure.currentExpression = atomExpr;\n\t\t} else if (atomBoolean) {\n\t\t\tconst atomExpr = new ExpressionGenerator();\n\t\t\tatomExpr.parent = botStructure.currentExpression;\n\t\t\tatomExpr.type = ExpressionOp.BOOLEAN;\n\t\t\tatomExpr.value = atomBoolean.text;\n\t\t\tbotStructure.currentExpression = atomExpr;\n\t\t} else if (addition || subtraction || multiplication || division) {\n\t\t\t// Create a new Arithmetic expression instance and give it the appropriate\n\t\t\t// type. The instance knows how to assigne the child, based on dual operands.\n\t\t\tconst arithmeticExpr = new ArithmeticExpressionGenerator();\n\t\t\tarithmeticExpr.parent = botStructure.currentExpression;\n\t\t\t\n\t\t\tif (addition) {\n\t\t\t\tarithmeticExpr.type = ExpressionOp.Add;\n\t\t\t} else if (subtraction) {\n\t\t\t\tarithmeticExpr.type = ExpressionOp.Subtract;\n\t\t\t} else if (multiplication) {\n\t\t\t\tarithmeticExpr.type = ExpressionOp.Multiply;\n\t\t\t} else if (division) {\n\t\t\t\tarithmeticExpr.type = ExpressionOp.Divide;\n\t\t\t}\t\t\t\t\n\t\t\tbotStructure.currentExpression = arithmeticExpr;\n\t\t}\n\t}\n\n\tpublic static exitExpr(ctx: ExprContext, botStructure: BotDetails): void {\n\t\tconst atomNumber = ctx.NUMBER();\n\t\tconst atomString = ctx.STRING();\n\t\tconst atomBoolean = ctx.BOOLEAN();\n\t\tconst addition = ctx.ADDED() && ctx.TO();\n\t\tconst subtraction = ctx.SUBTRACTED() && ctx.BY();\n\t\tconst multiplication = ctx.MULTIPLIED() && ctx.BY();\n\t\tconst division = ctx.DIVIDED() && ctx.BY();\t\t\n\t\t// If it's one of our atoms, we assign, else we skip as the actual parent\n\t\t// rule will deal with it.\n\t\tif (atomNumber || atomString || atomBoolean || addition || subtraction || multiplication || division) {\n\t\t\tif (botStructure.currentExpression) {\n\t\t\t\tconst parent = botStructure.currentExpression.parent;\n\t\t\t\t// Either assign current to parent.\n\t\t\t\tif (parent) {\n\t\t\t\t\tparent.assignChild(botStructure.currentExpression);\n\t\t\t\t\tbotStructure.currentExpression = parent;\n\t\t\t\t} else {\n\t\t\t\t\t// Or there's no more parent expressions.\n\t\t\t\t\tbotStructure.currentExpression = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic assignChild(expr: Expression): void {\n\t\tthis.value = expr;\n\t}\n}\n\nexport function addListenerMethods(listener: ExtRASPListener, definition: BotDetails): void {\n\tlistener['enterExpr'] = _.partial(ExpressionGenerator.enterExpr, _, definition);\n\tlistener['exitExpr'] = _.partial(ExpressionGenerator.exitExpr, _, definition);\n}"],"sourceRoot":"../../../lib"}