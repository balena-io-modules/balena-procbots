{"version":3,"sources":["RASP/expressions/expr.ts"],"names":[],"mappings":"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","file":"expr.js","sourcesContent":["import * as _ from 'lodash';\nimport { ExprContext } from '../Antlr/RASPParser';\nimport { ArithmeticExpressionGenerator } from './arithmetic';\nimport { ArithmeticExpression, BotDetails, Expression, ExpressionOp } from '../parser-types';\nimport { ExtRASPListener } from '../parser';\n\nexport class ExpressionGenerator implements Expression {\n    public type: ExpressionOp;\n    public value: any;\n    public parent: Expression | undefined;\n\n    public static enterExpr(ctx: ExprContext, botStructure: BotDetails): void {\n        // Only do something here if it's an actual expression or a final value atom.\n        // For all other expressions that relate to other rules, we skip and let that\n        // rule explicitly deal with it.\n\n        // This needs to check all of the other types of expression and drive them appropriately.\n        // To start with, we do the atoms, which are the final types.\n        const atomNumber = ctx.NUMBER();\n        const atomString = ctx.STRING();\n        const atomBoolean = ctx.BOOLEAN();\n        const addition = ctx.ADDED() && ctx.TO();\n        const subtraction = ctx.SUBTRACTED() && ctx.BY();\n        const multiplication = ctx.MULTIPLIED() && ctx.BY();\n        const division = ctx.DIVIDED() && ctx.BY();\n\n        console.log(ctx.text);\n        if (atomNumber) {\n            const atomExpr = new ExpressionGenerator();\n            atomExpr.parent = botStructure.currentExpression;\n            atomExpr.type = ExpressionOp.NUMBER;\n            atomExpr.value = atomNumber.text;\n            botStructure.currentExpression = atomExpr;\n        } else if (atomString) {\n            const atomExpr = new ExpressionGenerator();\n            atomExpr.parent = botStructure.currentExpression;\n            atomExpr.type = ExpressionOp.STRING;\n            atomExpr.value = atomString.text;\n            botStructure.currentExpression = atomExpr;\n        } else if (atomBoolean) {\n            const atomExpr = new ExpressionGenerator();\n            atomExpr.parent = botStructure.currentExpression;\n            atomExpr.type = ExpressionOp.BOOLEAN;\n            atomExpr.value = atomBoolean.text;\n            botStructure.currentExpression = atomExpr;\n        } else if (addition || subtraction || multiplication || division) {\n            // Create a new Arithmetic expression instance and give it the appropriate\n            // type. The instance knows how to assigne the child, based on dual operands.\n            const arithmeticExpr = new ArithmeticExpressionGenerator();\n            arithmeticExpr.parent = botStructure.currentExpression;\n            \n            if (addition) {\n                arithmeticExpr.type = ExpressionOp.Add;\n            } else if (subtraction) {\n                arithmeticExpr.type = ExpressionOp.Subtract;\n            } else if (multiplication) {\n                arithmeticExpr.type = ExpressionOp.Multiply;\n            } else if (division) {\n                arithmeticExpr.type = ExpressionOp.Divide;\n            }                \n            botStructure.currentExpression = arithmeticExpr;\n        }\n    }\n\n    public static exitExpr(ctx: ExprContext, botStructure: BotDetails): void {\n        const atomNumber = ctx.NUMBER();\n        const atomString = ctx.STRING();\n        const atomBoolean = ctx.BOOLEAN();\n        const addition = ctx.ADDED() && ctx.TO();\n        const subtraction = ctx.SUBTRACTED() && ctx.BY();\n        const multiplication = ctx.MULTIPLIED() && ctx.BY();\n        const division = ctx.DIVIDED() && ctx.BY();        \n        console.log('exit');\n        // If it's one of our atoms, we assign, else we skip as the actual parent\n        // rule will deal with it.\n        if (atomNumber || atomString || atomBoolean || addition || subtraction || multiplication || division) {\n            if (botStructure.currentExpression) {\n                const parent = botStructure.currentExpression.parent;\n                // Either assign current to parent.\n                if (parent) {\n                    parent.assignChild(botStructure.currentExpression);\n                    botStructure.currentExpression = parent;\n                } else {\n                    // Or there's no more parent expressions.\n                    botStructure.currentExpression = undefined;\n                }\n            }\n        }\n    }\n\n    public assignChild(expr: Expression): void {\n        this.value = expr;\n    }\n}\n\nexport function addListenerMethods(listener: ExtRASPListener, definition: BotDetails): void {\n    listener['enterExpr'] = _.partial(ExpressionGenerator.enterExpr, _, definition);\n    listener['exitExpr'] = _.partial(ExpressionGenerator.exitExpr, _, definition);\n}"],"sourceRoot":"../../../lib"}