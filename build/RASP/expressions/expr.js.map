{"version":3,"sources":["RASP/expressions/expr.ts"],"names":[],"mappings":";;AAAA,4BAA4B;AAK5B;IAKW,MAAM,CAAC,aAAa,CAAC,GAAgB,EAAE,YAAwB;QAOlE,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC;QAChC,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC;QAChC,MAAM,WAAW,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QAClC,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACb,MAAM,QAAQ,GAAG,IAAI,mBAAmB,EAAE,CAAC;YAC3C,QAAQ,CAAC,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;YACjD,QAAQ,CAAC,IAAI,KAAsB,CAAC;YACpC,QAAQ,CAAC,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC;YACjC,YAAY,CAAC,iBAAiB,GAAG,QAAQ,CAAC;QAC9C,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACpB,MAAM,QAAQ,GAAG,IAAI,mBAAmB,EAAE,CAAC;YAC3C,QAAQ,CAAC,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;YACjD,QAAQ,CAAC,IAAI,KAAsB,CAAC;YACpC,QAAQ,CAAC,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC;YACjC,YAAY,CAAC,iBAAiB,GAAG,QAAQ,CAAC;QAC9C,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACrB,MAAM,QAAQ,GAAG,IAAI,mBAAmB,EAAE,CAAC;YAC3C,QAAQ,CAAC,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;YACjD,QAAQ,CAAC,IAAI,KAAuB,CAAC;YACrC,QAAQ,CAAC,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC;YAClC,YAAY,CAAC,iBAAiB,GAAG,QAAQ,CAAC;QAC9C,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,YAAY,CAAC,GAAgB,EAAE,YAAwB;QACjE,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC;QAChC,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC;QAChC,MAAM,WAAW,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QAGlC,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,IAAI,WAAW,CAAC,CAAC,CAAC;YAC1C,EAAE,CAAC,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBACjC,MAAM,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC,MAAM,CAAC;gBAErD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACT,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC;oBACnD,YAAY,CAAC,iBAAiB,GAAG,MAAM,CAAC;gBAC5C,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAEJ,YAAY,CAAC,iBAAiB,GAAG,SAAS,CAAC;gBAC/C,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IAEM,WAAW,CAAC,IAAgB;QAC/B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;CACJ;AA5DD,kDA4DC;AAED,4BAAmC,QAAyB,EAAE,UAAsB;IAChF,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,mBAAmB,CAAC,aAAa,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;IACpF,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,mBAAmB,CAAC,YAAY,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;AACtF,CAAC;AAHD,gDAGC","file":"expr.js","sourcesContent":["import * as _ from 'lodash';\nimport { ExprContext } from '../Antlr/RASPParser';\nimport { BotDetails, Expression, ExpressionOp } from '../parser-types';\nimport { ExtRASPListener } from '../parser';\n\nexport class ExpressionGenerator implements Expression {\n    public type: ExpressionOp;\n    public value: any;\n    public parent: Expression | undefined;\n\n    public static enterProperty(ctx: ExprContext, botStructure: BotDetails): void {\n        // Only do something here if it's an actual expression or a final value atom.\n        // For all other expressions that relate to other rules, we skip and let that\n        // rule explicitly deal with it.\n\n        // This needs to check all of the other types of expression and drive them appropriately.\n        // To start with, we do the atoms, which are the final types.\n        const atomNumber = ctx.NUMBER();\n        const atomString = ctx.STRING();\n        const atomBoolean = ctx.BOOLEAN();\n        if (atomNumber) {\n            const atomExpr = new ExpressionGenerator();\n            atomExpr.parent = botStructure.currentExpression;\n            atomExpr.type = ExpressionOp.NUMBER;\n            atomExpr.value = atomNumber.text;\n            botStructure.currentExpression = atomExpr;\n        } else if (atomString) {\n            const atomExpr = new ExpressionGenerator();\n            atomExpr.parent = botStructure.currentExpression;\n            atomExpr.type = ExpressionOp.STRING;\n            atomExpr.value = atomString.text;\n            botStructure.currentExpression = atomExpr;\n        } else if (atomBoolean) {\n            const atomExpr = new ExpressionGenerator();\n            atomExpr.parent = botStructure.currentExpression;\n            atomExpr.type = ExpressionOp.BOOLEAN;\n            atomExpr.value = atomBoolean.text;\n            botStructure.currentExpression = atomExpr;\n        }\n    }\n\n    public static exitProperty(ctx: ExprContext, botStructure: BotDetails): void {\n        const atomNumber = ctx.NUMBER();\n        const atomString = ctx.STRING();\n        const atomBoolean = ctx.BOOLEAN();\n        // If it's one of our atoms, we assign, else we skip as the actual parent\n        // rule will deal with it.\n        if (atomNumber || atomString || atomBoolean) {\n            if (botStructure.currentExpression) {\n                const parent = botStructure.currentExpression.parent;\n                // Either assign current to parent.\n                if (parent) {\n                    parent.assignChild(botStructure.currentExpression);\n                    botStructure.currentExpression = parent;\n                } else {\n                    // Or there's no more parent expressions.\n                    botStructure.currentExpression = undefined;\n                }\n            }\n        }\n    }\n\n    public assignChild(expr: Expression): void {\n        this.value = expr;\n    }\n}\n\nexport function addListenerMethods(listener: ExtRASPListener, definition: BotDetails): void {\n    listener['enterExpr'] = _.partial(ExpressionGenerator.enterProperty, _, definition);\n    listener['exitExpr'] = _.partial(ExpressionGenerator.exitProperty, _, definition);\n}"],"sourceRoot":"../../../lib"}