{"version":3,"sources":["RASP/helpers.ts"],"names":[],"mappings":"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","file":"helpers.js","sourcesContent":["import * as Promise from 'bluebird';\nimport * as _ from 'lodash';\nimport * as FS from 'fs';\nimport { sep } from 'path';\nimport { ArithmeticExpression, ArrayExpression, Expression, ExpressionOp, ObjectExpression, PropertyExpression,\n\t\tVariableExpression } from './parser-types';\n\nconst fs: any = Promise.promisifyAll(FS);\n\nexport function MatchAssignByKeyword(keyword: string, value: string, assignTo: any, assignValue: any) {\n\tif (_.startsWith(value, keyword)) {\n\t\tassignTo[keyword] = assignValue.text;\n\t}\n}\n\nexport function GetSingletonFromRulePotentials(...potentials: any[]) {\n\t// This assumes that there can only be one match in the potentials.\n\tfor (let index = 0; index < potentials.length; index++) {\n\t\tif (potentials[index]) {\n\t\t\treturn potentials[index];\n\t\t}\n\t}\n}\n\nexport function FindAllFiles(dir: string, level: number = 0, filter: string | undefined, excludeDirs: string[] = []): Promise<string[]> {\n\tlet files: string[] = [];\n\n\t// We keep trawling directories and finding files. We only add files\n\t// that are level 'level' under the first directory given or deeper.\n\tconst findEntries = (directory: string, dirLevel: number): Promise<string[]> => {\n\t\t// Get all entries and find files in it. If we find a directory, add a\n\t\t// new object and go into it.\n\t\treturn fs.readdirAsync(directory).map((entry: any) => {\n\t\t\t// Is this a file or a directory?\n\t\t\tconst abEntry = `${directory}${sep}${entry}`;\n\t\t\treturn fs.lstatAsync(abEntry).then((stats: FS.Stats) => {\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tif (!_.find(excludeDirs, (lookupDir) => lookupDir === entry)) {\n\t\t\t\t\t\treturn findEntries(abEntry, dirLevel + 1);\n\t\t\t\t\t}\n\t\t\t\t} else if (stats.isFile()) {\n\t\t\t\t\t// We don't deal with links if they're not transparent.\n\t\t\t\t\t// Ensure that the suffix matches.\n\t\t\t\t\tif (filter) {\n\t\t\t\t\t\tconst extIndex = abEntry.indexOf('.');\n\t\t\t\t\t\tif (!extIndex) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst suffix = abEntry.substring(extIndex);\n\t\t\t\t\t\tif (filter !== suffix) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dirLevel >= level) {\n\t\t\t\t\t\tfiles.push(abEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\treturn findEntries(dir, 0).return(files);\n}\n\nexport function DebugExpression(expr: Expression, indent: number = 0) {\n\t// Print the type\n\tconst lookupType = (id: ExpressionOp) => {\n\t\tswitch (id) {\n\t\t\tcase ExpressionOp.Object:\n\t\t\t\treturn 'Object';\n\t\t\tcase ExpressionOp.Property:\n\t\t\t\treturn 'Property';\n\t\t\tcase ExpressionOp.Variable:\n\t\t\t\treturn 'Variable';\n\t\t\tcase ExpressionOp.Array:\n\t\t\t\treturn 'Array';\n\t\t\tcase ExpressionOp.Variable:\n\t\t\t\treturn 'Variable';\n\n\t\t\tcase ExpressionOp.Add:\n\t\t\t\treturn '+';\n\t\t\tcase ExpressionOp.Subtract:\n\t\t\t\treturn '-';\n\t\t\tcase ExpressionOp.Multiply:\n\t\t\t\treturn '*';\n\t\t\tcase ExpressionOp.Divide:\n\t\t\t\treturn '/';\n\n\t\t\tcase ExpressionOp.NUMBER:\n\t\t\t\treturn 'NUMBER';\n\t\t\tcase ExpressionOp.BOOLEAN:\n\t\t\t\treturn 'BOOLEAN';\n\t\t\tcase ExpressionOp.STRING:\n\t\t\t\treturn 'STRING';\n\n\t\t}\n\t}\n\n\tconst print = (message: string) => {\n\t\tlet finalMessage = '';\n\t\tfor (let loop = 0; loop < indent; loop++) {\n\t\t\tfinalMessage += ' ';\n\t\t}\n\t\tconsole.log(`${finalMessage}${message}`);\n\t}\n\n\tprint(`| ${lookupType(expr.type)}`);\n\n\t// Determine how to get the children, if any.\n\tswitch (expr.type) {\n\t\t// Types\n\t\tcase ExpressionOp.Object:\n\t\t\tconst objExpr = <ObjectExpression>expr;\n\t\t\tfor (let prop of objExpr.properties) {\n\t\t\t\tDebugExpression(prop, indent + 1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ExpressionOp.Property:\n\t\t\tconst propExpr = <PropertyExpression>expr;\n\t\t\tprint(`\\\\ ${propExpr.name}:`);\n\t\t\tDebugExpression(propExpr.value, indent + 1);\n\t\t\tbreak;\n\n\t\tcase ExpressionOp.Array:\n\t\t\tconst arrayExpr = <ArrayExpression>expr;\n\t\t\tfor (let value of arrayExpr.values) {\n\t\t\t\tDebugExpression(value, indent + 1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ExpressionOp.Variable:\n\t\t\tconst varExpr = <VariableExpression>expr;\n\t\t\tprint(`\\\\ ${varExpr.name}:`);\n\t\t\t// If we have a value, then this is of an assignment type, else it's a reference\n\t\t\tif (varExpr.value) {\n\t\t\t\tDebugExpression(varExpr.value, indent + 1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Arithmetic\n\t\tcase ExpressionOp.Add:\n\t\tcase ExpressionOp.Subtract:\n\t\tcase ExpressionOp.Multiply:\n\t\tcase ExpressionOp.Divide:\n\t\t\tconst arithmeticExpr = <ArithmeticExpression>expr;\n\t\t\tDebugExpression(arithmeticExpr.operandOne, indent + 1);\n\t\t\tDebugExpression(arithmeticExpr.operandTwo, indent + 1);\n\t\t\tbreak;\n\n\t\t// Atoms\n\t\tcase ExpressionOp.NUMBER:\n\t\tcase ExpressionOp.BOOLEAN:\n\t\tcase ExpressionOp.STRING:\n\t\t\tprint(`- ${expr.value}`);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.log(`Don't know how to deal with this type: ${expr.type}`);\n\t}\n}"],"sourceRoot":"../../lib"}